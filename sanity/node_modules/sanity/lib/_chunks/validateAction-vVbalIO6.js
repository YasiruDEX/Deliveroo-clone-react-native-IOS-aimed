'use strict';

var logSymbols = require('log-symbols');
var chalk = require('chalk');
var path = require('path');
var worker_threads = require('worker_threads');
var readPkgUp = require('read-pkg-up');
var workerChannels = require('./workerChannels-ZUUNsU1E.js');
var tty = require('tty');
var sanity = require('sanity');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var logSymbols__default = /*#__PURE__*/_interopDefaultCompat(logSymbols);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var readPkgUp__default = /*#__PURE__*/_interopDefaultCompat(readPkgUp);
const DEFAULT_MAX_CUSTOM_VALIDATION_CONCURRENCY = 5;
const defaultReporter = _ref => {
  let {
    stream,
    dispose
  } = _ref;
  async function* createValidationGenerator() {
    for await (const {
      documentId,
      documentType,
      markers,
      revision,
      level
    } of stream.validation()) {
      const result = {
        documentId,
        documentType,
        revision,
        level,
        markers
      };
      yield result;
    }
    await dispose();
  }
  return createValidationGenerator();
};
function validateDocuments(options) {
  var _a;
  const {
    workspace,
    clientConfig,
    configPath,
    dataset,
    projectId,
    workDir = process.cwd(),
    reporter = defaultReporter,
    level,
    maxCustomValidationConcurrency
  } = options;
  const rootPkgPath = (_a = readPkgUp__default.default.sync({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  if (!rootPkgPath) {
    throw new Error("Could not find root directory for `sanity` package");
  }
  const workerPath = path__default.default.join(path__default.default.dirname(rootPkgPath), "lib", "_internal", "cli", "threads", "validateDocuments.js");
  const worker = new worker_threads.Worker(workerPath, {
    workerData: {
      workDir,
      // removes props in the config that make this object fail to serialize
      clientConfig: JSON.parse(JSON.stringify(clientConfig)),
      configPath,
      workspace,
      dataset,
      projectId,
      level,
      maxCustomValidationConcurrency: maxCustomValidationConcurrency != null ? maxCustomValidationConcurrency : DEFAULT_MAX_CUSTOM_VALIDATION_CONCURRENCY
    },
    // eslint-disable-next-line no-process-env
    env: process.env
  });
  return reporter(workerChannels.createReceiver(worker));
}
const isTty = tty.isatty(1);
const levelValues = {
  error: 0,
  warning: 1,
  info: 2
};
const count = (amount, subject) => "".concat(amount.toLocaleString("en-US"), " ").concat(amount === 1 ? subject.substring(0, subject.length - 1) : subject);
const percent = new Intl.NumberFormat("en-US", {
  style: "percent",
  minimumFractionDigits: 1,
  maximumFractionDigits: 1
}).format.bind(Intl.NumberFormat);
const secondFormatter = new Intl.NumberFormat("en-US", {
  minimumFractionDigits: 1,
  maximumFractionDigits: 1
});
const seconds = startTime => {
  const endTime = Date.now();
  return "(".concat(secondFormatter.format((endTime - startTime) / 1e3), "s)");
};
const summary = function (_ref2) {
  let {
    errors,
    infos,
    valid,
    warnings
  } = _ref2;
  let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "warning";
  const levelValue = levelValues[level];
  return ["".concat(logSymbols__default.default.success, " Valid:    ").concat(count(valid.documents, "documents")), "".concat(logSymbols__default.default.error, " Errors:   ").concat(count(errors.documents, "documents"), ", ").concat(count(errors.markers, "errors")), levelValue >= levelValues.warning && "".concat(logSymbols__default.default.warning, " Warnings: ").concat(count(warnings.documents, "documents"), ", ").concat(count(warnings.markers, "warnings")), levelValue >= levelValues.info && "".concat(logSymbols__default.default.info, " Info:     ").concat(count(infos.documents, "documents"), ", ").concat(count(infos.documents, "markers"))].filter(Boolean).join("\n");
};
const levelHeaders = {
  error: isTty ? chalk__default.default.bold(chalk__default.default.bgRed(" ERROR ")) : chalk__default.default.red("[ERROR]"),
  warning: isTty ? chalk__default.default.bold(chalk__default.default.bgYellow(" WARN ")) : chalk__default.default.yellow("[WARN]"),
  info: isTty ? chalk__default.default.bold(chalk__default.default.cyan(" INFO ")) : chalk__default.default.cyan("[INFO]")
};
const link = (text, url) => isTty ? "\x1B]8;;".concat(url, "\x07").concat(text, "\x1B]8;;\x07") : chalk__default.default.underline(text);
const maxKeyLength = function () {
  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return Object.entries(children).map(_ref3 => {
    let [key, child] = _ref3;
    return Math.max(key.length + depth * 2, maxKeyLength(child.children, depth + 1));
  }).reduce((max, next) => next > max ? next : max, 0);
};
const compareLevels = (a, b) => levelValues[a.level] - levelValues[b.level];
const formatTree = function () {
  let node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let paddingLength = arguments.length > 1 ? arguments[1] : undefined;
  let indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  const entries = Object.entries(node);
  return entries.map((_ref4, index) => {
    let [key, child] = _ref4;
    var _a;
    const isLast = index === entries.length - 1;
    const nextIndent = "".concat(indent).concat(isLast ? "  " : "\u2502 ");
    const nested = formatTree(child.children, paddingLength, nextIndent);
    if (!((_a = child.markers) == null ? void 0 : _a.length)) {
      const current2 = "".concat(indent).concat(isLast ? "\u2514" : "\u251C", "\u2500 ").concat(key);
      return [current2, nested].filter(Boolean).join("\n");
    }
    const [first, ...rest] = child.markers.slice().sort(compareLevels);
    const firstPadding = ".".repeat(paddingLength - indent.length - key.length);
    const elbow = isLast ? "\u2514" : "\u251C";
    const firstBullet = logSymbols__default.default[first.level];
    const subsequentPadding = " ".repeat(paddingLength - indent.length + 2);
    const firstMessage = "".concat(indent).concat(elbow, "\u2500 ").concat(key, " ").concat(firstPadding, " ").concat(firstBullet, " ").concat(first.message);
    const subsequentMessages = rest.map(marker => "".concat(nextIndent).concat(subsequentPadding, " ").concat(logSymbols__default.default[marker.level], " ").concat(marker.message)).join("\n");
    const current = [firstMessage, subsequentMessages].filter(Boolean).join("\n");
    return [current, nested].filter(Boolean).join("\n");
  }).join("\n");
};
const formatRootErrors = (root, hasChildren, paddingLength) => {
  if (!root.markers) return "";
  const [first, ...rest] = root.markers.slice().sort(compareLevels);
  if (!first) return "";
  const firstElbow = hasChildren ? "\u2502 " : "\u2514\u2500";
  const firstPadding = ".".repeat(paddingLength - 6);
  const firstLine = "".concat(firstElbow, " (root) ").concat(firstPadding, " ").concat(logSymbols__default.default[first.level], " ").concat(first.message);
  const subsequentPadding = " ".repeat(paddingLength + 2);
  const subsequentElbow = hasChildren ? "\u2502 " : "  ";
  const restOfLines = rest.map(marker => "".concat(subsequentElbow).concat(subsequentPadding, " ").concat(logSymbols__default.default[marker.level], " ").concat(marker.message)).join("\n");
  return [firstLine, restOfLines].filter(Boolean).join("\n");
};
function convertToTree(markers) {
  const root = {};
  function addMarker(marker) {
    let node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;
    if (!marker.path.length) {
      if (!node.markers) node.markers = [];
      node.markers.push({
        level: marker.level,
        message: marker.message
      });
      return;
    }
    const [current, ...rest] = marker.path;
    const key = sanity.pathToString([current]);
    if (!node.children) node.children = {};
    if (!(key in node.children)) node.children[key] = {};
    addMarker({
      ...marker,
      path: rest
    }, node.children[key]);
  }
  for (const marker of markers) addMarker(marker);
  return root;
}
function formatDocumentValidation(_ref5) {
  let {
    basePath,
    documentId,
    documentType,
    level,
    studioHost,
    markers
  } = _ref5;
  const tree = convertToTree(markers);
  const editLink = studioHost && "".concat(studioHost).concat(basePath, "/intent/edit/id=").concat(encodeURIComponent(documentId), ";type=").concat(encodeURIComponent(documentType));
  const documentTypeHeader = isTty ? chalk__default.default.bgWhite(" ".concat(documentType, " ")) : "[".concat(documentType, "]");
  const header = "".concat(levelHeaders[level], " ").concat(documentTypeHeader, " ").concat(editLink ? link(documentId, editLink) : chalk__default.default.underline(documentId));
  const paddingLength = Math.max(maxKeyLength(tree.children) + 2, 30);
  const childErrors = formatTree(tree.children, paddingLength);
  const rootErrors = formatRootErrors(tree, childErrors.length > 0, paddingLength);
  return [header, rootErrors, childErrors].filter(Boolean).join("\n");
}
const pretty = async _ref6 => {
  let {
    output,
    worker,
    flags
  } = _ref6;
  const workspaceLoadStart = Date.now();
  const spinner = output.spinner(flags.workspace ? "Loading workspace '".concat(flags.workspace, "'\u2026") : "Loading workspace\u2026").start();
  const workspace = await worker.event.loadedWorkspace();
  spinner.succeed("Loaded workspace '".concat(workspace.name, "' using project '").concat(workspace.projectId, "' and dataset '").concat(flags.dataset || workspace.dataset, "' ").concat(seconds(workspaceLoadStart)));
  spinner.start("Calculating documents to be validated\u2026");
  const {
    documentCount
  } = await worker.event.loadedDocumentCount();
  const downloadStart = Date.now();
  spinner.text = "Downloading ".concat(count(documentCount, "documents"), "\u2026");
  for await (const {
    downloadedCount
  } of worker.stream.exportProgress()) {
    const percentage = percent(downloadedCount / documentCount);
    spinner.text = "Downloading ".concat(count(documentCount, "documents"), "\u2026 ").concat(percentage);
  }
  spinner.succeed("Downloaded ".concat(count(documentCount, "documents"), " ").concat(seconds(downloadStart)));
  const referenceIntegrityStart = Date.now();
  spinner.start("Checking reference existence\u2026");
  await worker.event.loadedReferenceIntegrity();
  spinner.succeed("Checked all references ".concat(seconds(referenceIntegrityStart)));
  const validationStart = Date.now();
  spinner.start("Validating ".concat(count(documentCount, "documents"), "\u2026"));
  const results = [];
  const totals = {
    valid: {
      documents: 0
    },
    errors: {
      documents: 0,
      markers: 0
    },
    warnings: {
      documents: 0,
      markers: 0
    },
    infos: {
      documents: 0,
      markers: 0
    }
  };
  for await (const {
    validatedCount,
    ...result
  } of worker.stream.validation()) {
    const {
      markers
    } = result;
    if (markers.length) {
      results.push(result);
    }
    const errors = markers.filter(marker => marker.level === "error");
    const warnings = markers.filter(marker => marker.level === "warning");
    const infos = markers.filter(marker => marker.level === "info");
    if (!markers.length) {
      totals.valid.documents += 1;
    }
    if (errors.length) {
      totals.errors.documents += 1;
      totals.errors.markers += errors.length;
    }
    if (warnings.length) {
      totals.warnings.documents += 1;
      totals.warnings.markers += warnings.length;
    }
    if (infos.length) {
      totals.infos.documents += 1;
      totals.infos.markers += infos.length;
    }
    spinner.text = "Validating ".concat(count(documentCount, "documents"), "\u2026\n\n") + "Processed ".concat(count(validatedCount, "documents"), " (").concat(percent(validatedCount / documentCount), "):\n").concat(summary(totals, flags.level));
  }
  spinner.succeed("Validated ".concat(count(documentCount, "documents"), " ").concat(seconds(validationStart)));
  output.print("\nValidation results:\n".concat(summary(totals, flags.level)));
  results.sort((a, b) => {
    if (a.level === b.level) return a.documentType.localeCompare(b.documentType);
    return levelValues[a.level] - levelValues[b.level];
  });
  let overallLevel = "info";
  for (const result of results) {
    if (result.level === "error") overallLevel = "error";
    if (result.level === "warning" && overallLevel !== "error") overallLevel = "warning";
    output.print("".concat(formatDocumentValidation({
      basePath: workspace.basePath,
      studioHost: workspace.studioHost,
      ...result
    }), "\n"));
  }
  await worker.dispose();
  return overallLevel;
};
const ndjson = async _ref7 => {
  let {
    output,
    worker
  } = _ref7;
  let overallLevel = "info";
  for await (const {
    documentId,
    documentType,
    markers,
    revision,
    level
  } of worker.stream.validation()) {
    if (level === "error") overallLevel = "error";
    if (level === "warning" && overallLevel !== "error") overallLevel = "warning";
    if (markers.length) {
      output.print(JSON.stringify({
        documentId,
        documentType,
        revision,
        level,
        markers
      }));
    }
  }
  await worker.dispose();
  return overallLevel;
};
const json = async _ref8 => {
  let {
    output,
    worker
  } = _ref8;
  let overallLevel = "info";
  const results = [];
  for await (const {
    documentId,
    documentType,
    markers,
    revision,
    level
  } of worker.stream.validation()) {
    if (level === "error") overallLevel = "error";
    if (level === "warning" && overallLevel !== "error") overallLevel = "warning";
    results.push({
      documentId,
      documentType,
      revision,
      level,
      markers
    });
  }
  await worker.dispose();
  output.print(JSON.stringify(results));
  return overallLevel;
};
const reporters = {
  pretty,
  ndjson,
  json
};
async function validateAction(args, _ref9) {
  let {
    apiClient,
    workDir,
    output,
    prompt
  } = _ref9;
  const flags = args.extOptions;
  const unattendedMode = Boolean(flags.yes || flags.y);
  if (!unattendedMode) {
    output.print("".concat(chalk__default.default.yellow("".concat(logSymbols__default.default.warning, " Warning:")), " This command downloads all documents from a ") + "dataset and processes them through your local schema within a simulated browser environment.\n");
    output.print("Potential pitfalls:\n");
    output.print("- Downloads all documents locally (excluding assets). Large datasets may require more resources.");
    output.print("- Executes all custom validation functions. Some functions may need to be refactored for compatibility.");
    output.print("- Not all standard browser features are available and may cause issues while loading your Studio.");
    output.print("- Adheres to document permissions. Ensure this account can see all desired documents.");
    output.print();
    output.print("Note: As it's currently in beta, we encourage users to report any issues encountered here:\n");
    output.print("    https://github.com/sanity-io/sanity/issues/5510");
    output.print();
    const confirmed = await prompt.single({
      type: "confirm",
      message: "Are you sure you want to continue?",
      default: true
    });
    if (!confirmed) {
      output.print("User aborted");
      process.exitCode = 1;
      return;
    }
  }
  if (flags.format && !(flags.format in reporters)) {
    const formatter = new Intl.ListFormat("en-US", {
      style: "long",
      type: "conjunction"
    });
    throw new Error("Did not recognize format '".concat(flags.format, "'. Available formats are ").concat(formatter.format(Object.keys(reporters).map(key => "'".concat(key, "'")))));
  }
  const level = flags.level || "warning";
  if (level !== "error" && level !== "warning" && level !== "info") {
    throw new Error("Invalid level. Available levels are 'error', 'warning', and 'info'.");
  }
  const maxCustomValidationConcurrency = flags["max-custom-validation-concurrency"];
  if (maxCustomValidationConcurrency && typeof maxCustomValidationConcurrency !== "number" && !Number.isInteger(maxCustomValidationConcurrency)) {
    throw new Error("'--max-custom-validation-concurrency' must be an integer.");
  }
  const overallLevel = await validateDocuments({
    workspace: flags.workspace,
    dataset: flags.dataset,
    clientConfig: apiClient({
      requireUser: true,
      requireProject: false
      // we'll get this from the workspace
    }).config(),
    workDir,
    level,
    maxCustomValidationConcurrency,
    reporter: worker => {
      const reporter = flags.format && flags.format in reporters ? reporters[flags.format] : reporters.pretty;
      return reporter({
        output,
        worker,
        flags
      });
    }
  });
  process.exitCode = overallLevel === "error" ? 1 : 0;
}
exports.default = validateAction;
//# sourceMappingURL=validateAction-vVbalIO6.js.map
