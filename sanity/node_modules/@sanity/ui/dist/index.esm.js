import { buildTheme, createColorTheme as createColorTheme$1, hexToRgb as hexToRgb$1, hslToRgb as hslToRgb$1, multiply as multiply$1, parseColor as parseColor$1, rgbToHex as rgbToHex$1, rgbToHsl as rgbToHsl$1, rgba as rgba$1, screen as screen$1, getTheme_v2, getScopedTheme } from '@sanity/ui/theme';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useMemo, useState, useRef, useEffect, createContext, useContext, useSyncExternalStore, useLayoutEffect, forwardRef, useId, useCallback, cloneElement, isValidElement, createElement, Component, memo, useReducer, Children, Fragment as Fragment$1, startTransition } from 'react';
import ReactIs, { isElement as isElement$1, isFragment, isValidElementType } from 'react-is';
import styled, { ThemeProvider as ThemeProvider$1, useTheme as useTheme$1, css, keyframes } from 'styled-components';
import { SpinnerIcon, CheckmarkIcon, RemoveIcon, ChevronDownIcon, CloseIcon, ChevronRightIcon, ToggleArrowRightIcon } from '@sanity/icons';
import Refractor from 'react-refractor';
import { detectOverflow, flip, offset, shift, arrow, hide, useFloating, autoUpdate } from '@floating-ui/react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { createPortal } from 'react-dom';
const createColorTheme = createColorTheme$1;
const hexToRgb = hexToRgb$1;
const hslToRgb = hslToRgb$1;
const multiply = multiply$1;
const parseColor = parseColor$1;
const rgbToHex = rgbToHex$1;
const rgbToHsl = rgbToHsl$1;
const rgba = rgba$1;
const screen = screen$1;
const studioTheme = buildTheme();
const EMPTY_ARRAY = [];
const EMPTY_RECORD = {};
const POPOVER_MOTION_CONTENT_OPACITY_PROPERTY = "--motion-content-opacity";
const POPOVER_MOTION_PROPS = {
  initial: {
    opacity: 0.5,
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
    scale: 0.97,
    willChange: "transform"
  },
  animate: {
    opacity: [null, 1, 1],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, null, 1],
    scale: 1
  },
  exit: {
    // @ts-expect-error -- passing null a second time is valid: https://github.com/framer/motion/blob/b9ce4c42914c3916ea523609c5b032dfc72718bb/packages/framer-motion/src/animation/utils/keyframes.ts#L34C22-L34C22
    opacity: [null, null, 0],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, 0, 0],
    scale: 0.97
  },
  transition: {
    duration: 0.4,
    type: "spring"
  }
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key) => {
    style[key] = value;
    return style;
  }, {});
}
function rem(pixelValue) {
  if (pixelValue === 0) return 0;
  return "".concat(pixelValue / 16, "rem");
}
function _responsive(media, values, callback) {
  const statements = (values == null ? void 0 : values.map(callback)) || [];
  return statements.map((statement, mediaIndex) => {
    if (mediaIndex === 0) return statement;
    return {
      ["@media screen and (min-width: ".concat(media[mediaIndex - 1], "px)")]: statement
    };
  });
}
function _getArrayProp(val, defaultVal) {
  if (val === void 0) return defaultVal || EMPTY_ARRAY;
  return Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props) {
  let spaceIndexes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_ARRAY;
  if (!Array.isArray(spaceIndexes)) {
    throw new Error("the property must be array of numbers");
  }
  if (spaceIndexes.length === 0) {
    return null;
  }
  const {
    media,
    space
  } = getTheme_v2(theme);
  return _responsive(media, spaceIndexes, spaceIndex => _fillCSSObject(props, rem(space[spaceIndex])));
}
function responsiveFont(fontKey, props) {
  const {
    $size,
    $weight
  } = props;
  const {
    font,
    media
  } = getTheme_v2(props.theme);
  const {
    family,
    sizes,
    weights
  } = font[fontKey];
  const fontWeight = $weight && weights[$weight] || weights.regular;
  const defaultSize = sizes[2];
  const base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size) {
    if (!responsiveFont.warned) {
      console.warn("No size specified for responsive font", {
        fontKey,
        $size,
        props,
        base
      });
      responsiveFont.warned = true;
    }
    return [base];
  }
  const resp = _responsive(media, $size, sizeIndex => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size;
  const negHeight = ascenderHeight + descenderHeight;
  const capHeight = lineHeight - negHeight;
  const iconOffset = (capHeight - iconSize) / 2;
  const customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1;
  const customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: "calc(".concat(lineHeight, " / ").concat(fontSize2, ")"),
    letterSpacing: rem(letterSpacing),
    transform: "translateY(".concat(rem(descenderHeight), ")"),
    "&:before": {
      marginTop: "calc(".concat(rem(0 - negHeight), " - 1px)")
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: "calc(".concat(customIconSize, " / 16 * 1rem)"),
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: "calc(".concat(iconSize, " / 16 * 1rem)"),
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, textAlign => {
    return {
      textAlign
    };
  });
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = useMemo(() => JSON.stringify(val != null ? val : defaultVal), [defaultVal, val]);
  return useMemo(() => _getArrayProp(val, defaultVal),
  // Improve performance: Keep object identify for a given hash of the value
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [__perf_hash__]);
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg) {
    if (Array.isArray(el)) {
      ret.push(...el);
    } else {
      ret.push(el);
    }
  }
  return ret.filter(Boolean);
}
function useClickOutside(listener) {
  let elementsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_ARRAY;
  let boundaryElement = arguments.length > 2 ? arguments[2] : undefined;
  const [element, setElement] = useState(null);
  const [elements, setElements] = useState(() => _getElements(element, elementsArg));
  const elementsRef = useRef(elements);
  useEffect(() => {
    const prevElements = elementsRef.current;
    const nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements);
      elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements) {
      if (!nextElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
    for (const el of nextElements) {
      if (!prevElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
  }, [element, elementsArg]);
  useEffect(() => {
    if (!listener) return void 0;
    const handleWindowMouseDown = evt => {
      const target = evt.target;
      if (!(target instanceof Node)) {
        return;
      }
      if (boundaryElement && !boundaryElement.contains(target)) {
        return;
      }
      for (const el of elements) {
        if (target === el || el.contains(target)) {
          return;
        }
      }
      listener(evt);
    };
    window.addEventListener("mousedown", handleWindowMouseDown);
    return () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, [boundaryElement, listener, elements]);
  return setElement;
}
var resizeObservers = [];
var hasActiveObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
  var event;
  if (typeof ErrorEvent === 'function') {
    event = new ErrorEvent('error', {
      message: msg
    });
  } else {
    event = document.createEvent('Event');
    event.initEvent('error', false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
  ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function (obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = function () {
  function ResizeObserverSize(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize;
}();
var DOMRectReadOnly = function () {
  function DOMRectReadOnly(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly.prototype.toJSON = function () {
    var _a = this,
      x = _a.x,
      y = _a.y,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom,
      left = _a.left,
      width = _a.width,
      height = _a.height;
    return {
      x: x,
      y: y,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      width: width,
      height: height
    };
  };
  DOMRectReadOnly.fromRect = function (rectangle) {
    return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly;
}();
var isSVG = function (target) {
  return target instanceof SVGElement && 'getBBox' in target;
};
var isHidden = function (target) {
  if (isSVG(target)) {
    var _a = target.getBBox(),
      width = _a.width,
      height = _a.height;
    return !width && !height;
  }
  var _b = target,
    offsetWidth = _b.offsetWidth,
    offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function (obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target) {
  switch (target.tagName) {
    case 'INPUT':
      if (target.type !== 'image') {
        break;
      }
    case 'VIDEO':
    case 'AUDIO':
    case 'EMBED':
    case 'OBJECT':
    case 'CANVAS':
    case 'IFRAME':
    case 'IMG':
      return true;
  }
  return false;
};
var global$1 = typeof window !== 'undefined' ? window : {};
var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function (pixel) {
  return parseFloat(pixel || '0');
};
var size$1 = function (inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === 'border-box';
  var switchSizes = verticalRegexp.test(cs.writingMode || '');
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation),
    borderBoxSize = _a.borderBoxSize,
    contentBoxSize = _a.contentBoxSize,
    devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = function () {
  function ResizeObserverEntry(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry;
}();
var calculateDepthForNode = function (node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function () {
  var shallowestDepth = Infinity;
  var callbacks = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function (depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process = function () {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function () {
  return callbacks.splice(0).forEach(function (cb) {
    return cb();
  });
};
var queueMicroTask = function (callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode('');
    var config = {
      characterData: true
    };
    new MutationObserver(function () {
      return notify();
    }).observe(el_1, config);
    trigger = function () {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function (cb) {
  queueMicroTask(function ResizeObserver() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function () {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
var events = ['resize', 'load', 'transitionend', 'animationend', 'animationstart', 'animationiteration', 'keyup', 'keydown', 'mouseup', 'mousedown', 'mouseover', 'mouseout', 'blur', 'focus'];
var time = function (timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function () {
  function Scheduler() {
    var _this = this;
    this.stopped = true;
    this.listener = function () {
      return _this.schedule();
    };
  }
  Scheduler.prototype.run = function (timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function () {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1000);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler.prototype.schedule = function () {
    this.stop();
    this.run();
  };
  Scheduler.prototype.observe = function () {
    var _this = this;
    var cb = function () {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);
  };
  Scheduler.prototype.start = function () {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function (name) {
        return global$1.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler.prototype.stop = function () {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function (name) {
        return global$1.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler;
}();
var scheduler = new Scheduler();
var updateCount = function (n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function (target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = function () {
  function ResizeObservation(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation.prototype.isActive = function () {
    var size = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size;
    }
    if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation;
}();
var ResizeObserverDetail = function () {
  function ResizeObserverDetail(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail;
}();
var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function () {
  function ResizeObserverController() {}
  ResizeObserverController.connect = function (resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController.observe = function (resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController.unobserve = function (resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController.disconnect = function (resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function (ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController;
}();
var ResizeObserver = function () {
  function ResizeObserver(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== 'function') {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver.prototype.observe = function (target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver.prototype.unobserve = function (target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver.prototype.disconnect = function () {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver.toString = function () {
    return 'function ResizeObserver () { [polyfill code] }';
  };
  return ResizeObserver;
}();
const _ResizeObserver = typeof document !== "undefined" && typeof window !== "undefined" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver;
const _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(_ref => {
        let [entry] = _ref;
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      resizeObserver.observe(element);
      return () => {
        resizeObserver.unobserve(element);
        resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */new WeakMap();
  const subscribersCache = /* @__PURE__ */new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      if (!subscribersCache.has(element)) {
        subscribersCache.set(element, subscribers);
        const listener = _createElementRectValueListener();
        dispose = listener.subscribe(element, elementRect => {
          for (const sub of subscribers) {
            sub(elementRect);
          }
        });
      }
      subscribers.push(subscriber);
      return () => {
        const idx = subscribers.indexOf(subscriber);
        if (idx > -1) {
          subscribers.splice(idx, 1);
        }
        if (subscribers.length === 0) {
          if (dispose) dispose();
        }
      };
    }
  };
}
function useElementSize(element) {
  const [size, setSize] = useState(null);
  useEffect(() => {
    if (!element) return void 0;
    return _elementSizeObserver.subscribe(element, setSize);
  }, [element]);
  return size;
}
function useElementRect(element) {
  const elementSize = useElementSize(element);
  return (elementSize == null ? void 0 : elementSize._contentRect) || null;
}
function useGlobalKeyDown(onKeyDown) {
  return useEffect(() => {
    addEventListener("keydown", onKeyDown);
    return () => removeEventListener("keydown", onKeyDown);
  }, [onKeyDown]);
}
function getGlobalScope() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof window !== "undefined") return window;
  if (typeof self !== "undefined") return self;
  if (typeof global !== "undefined") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope();
const key$8 = Symbol.for("@sanity/ui/context/theme");
globalScope[key$8] = globalScope[key$8] || createContext(null);
const ThemeContext = globalScope[key$8];
function ThemeProvider(props) {
  const parentTheme = useContext(ThemeContext);
  const {
    children,
    scheme = (parentTheme == null ? void 0 : parentTheme.scheme) || "light",
    theme: rootTheme = (parentTheme == null ? void 0 : parentTheme.theme) || null,
    tone = (parentTheme == null ? void 0 : parentTheme.tone) || "default"
  } = props;
  const themeContext = useMemo(() => {
    if (!rootTheme) return null;
    return {
      version: 0,
      theme: rootTheme,
      scheme,
      tone
    };
  }, [rootTheme, scheme, tone]);
  const theme = useMemo(() => {
    if (!rootTheme) return null;
    return getScopedTheme(rootTheme, scheme, tone);
  }, [scheme, rootTheme, tone]);
  if (!theme) {
    return /* @__PURE__ */jsx("pre", {
      children: 'ThemeProvider: no "theme" property provided'
    });
  }
  return /* @__PURE__ */jsx(ThemeContext.Provider, {
    value: themeContext,
    children: /* @__PURE__ */jsx(ThemeProvider$1, {
      theme,
      children
    })
  });
}
function useRootTheme() {
  const value = useContext(ThemeContext);
  if (!value) {
    throw new Error("useRootTheme(): missing context value");
  }
  return value;
}
function ThemeColorProvider(props) {
  const {
    children,
    scheme,
    tone
  } = props;
  const root = useRootTheme();
  return /* @__PURE__ */jsx(ThemeProvider, {
    scheme: scheme || root.scheme,
    theme: root.theme,
    tone,
    children
  });
}
function useTheme() {
  return useTheme$1();
}
function useTheme_v2() {
  return getTheme_v2(useTheme$1());
}
const MEDIA_STORE_CACHE = /* @__PURE__ */new WeakMap();
function _getMediaQuery(media, index) {
  if (index === 0) {
    return "screen and (max-width: ".concat(media[index] - 1, "px)");
  }
  if (index === media.length) {
    return "screen and (min-width: ".concat(media[index - 1], "px)");
  }
  return "screen and (min-width: ".concat(media[index - 1], "px) and (max-width: ").concat(media[index] - 1, "px)");
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index = mediaLen; index > -1; index -= 1) {
        const mediaQuery = _getMediaQuery(media, index);
        sizes.push({
          index,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  const getSnapshot = () => {
    for (const {
      index,
      mq
    } of getSizes()) {
      if (mq.matches) return index;
    }
    return 0;
  };
  const subscribe = onStoreChange => {
    const disposeFns = [];
    for (const {
      mq
    } of getSizes()) {
      const handleChange = () => {
        if (mq.matches) onStoreChange();
      };
      mq.addEventListener("change", handleChange);
      disposeFns.push(() => mq.removeEventListener("change", handleChange));
    }
    return () => {
      for (const disposeFn of disposeFns) {
        disposeFn();
      }
    };
  };
  return {
    getSnapshot,
    subscribe
  };
}
function getServerSnapshot$2() {
  return 0;
}
function useMediaIndex() {
  const {
    media
  } = useTheme_v2();
  let store = MEDIA_STORE_CACHE.get(media);
  if (!store) {
    store = _createMediaStore(media);
    MEDIA_STORE_CACHE.set(media, store);
  }
  return useSyncExternalStore(store.subscribe, store.getSnapshot, getServerSnapshot$2);
}
let MEDIA_QUERY_CACHE$1;
function getMatchMedia$1() {
  if (!MEDIA_QUERY_CACHE$1) {
    MEDIA_QUERY_CACHE$1 = window.matchMedia("(prefers-color-scheme: dark)");
  }
  return MEDIA_QUERY_CACHE$1;
}
function subscribe$1(onStoreChange) {
  const matchMedia = getMatchMedia$1();
  matchMedia.addEventListener("change", onStoreChange);
  return () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot$1() {
  return getMatchMedia$1().matches;
}
function getServerSnapshot$1() {
  return false;
}
function usePrefersDark() {
  return useSyncExternalStore(subscribe$1, getSnapshot$1, getServerSnapshot$1);
}
let MEDIA_QUERY_CACHE;
function getMatchMedia() {
  if (!MEDIA_QUERY_CACHE) {
    MEDIA_QUERY_CACHE = window.matchMedia("(prefers-reduced-motion: reduce)");
  }
  return MEDIA_QUERY_CACHE;
}
function subscribe(onStoreChange) {
  const matchMedia = getMatchMedia();
  matchMedia.addEventListener("change", onStoreChange);
  return () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot() {
  return getMatchMedia().matches;
}
function getServerSnapshot() {
  return false;
}
function usePrefersReducedMotion() {
  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
}
const useIsomorphicEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
function useForwardedRef(ref) {
  const innerRef = useRef(null);
  useIsomorphicEffect(() => {
    if (!ref) return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
function useCustomValidity(ref, customValidity) {
  useEffect(() => {
    if (ref.current) {
      ref.current.setCustomValidity(customValidity || "");
    }
  }, [customValidity, ref]);
}
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  var _a, _b;
  const {
    card,
    media
  } = getTheme_v2(props.theme);
  const borderStyle = "".concat((_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1, "px solid var(--card-border-color)");
  return _responsive(media, props.$border, value => value ? {
    "&&": {
      border: borderStyle
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props) {
  var _a, _b;
  const {
    card,
    media
  } = getTheme_v2(props.theme);
  const borderStyle = "".concat((_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1, "px solid var(--card-border-color)");
  return _responsive(media, props.$borderTop, value => value ? {
    "&&": {
      borderTop: borderStyle
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props) {
  var _a, _b;
  const {
    card,
    media
  } = getTheme_v2(props.theme);
  const borderStyle = "".concat((_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1, "px solid var(--card-border-color)");
  return _responsive(media, props.$borderRight, value => value ? {
    "&&": {
      borderRight: borderStyle
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props) {
  var _a, _b;
  const {
    card,
    media
  } = getTheme_v2(props.theme);
  const borderStyle = "".concat((_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1, "px solid var(--card-border-color)");
  return _responsive(media, props.$borderBottom, value => value ? {
    "&&": {
      borderBottom: borderStyle
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props) {
  var _a, _b;
  const {
    card,
    media
  } = getTheme_v2(props.theme);
  const borderStyle = "".concat((_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1, "px solid var(--card-border-color)");
  return _responsive(media, props.$borderLeft, value => value ? {
    "&&": {
      borderLeft: borderStyle
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
const BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
const BOX_SIZING = {
  content: "content-box",
  border: "border-box"
};
const BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$display, display => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$sizing, sizing => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$height, height => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$overflow, overflow => ({
    overflow
  }));
}
const BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$3, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, align => {
    return {
      alignItems: align
    };
  });
}
function responsiveFlexGapStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, gap => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$wrap, wrap => {
    return {
      flexWrap: wrap
    };
  });
}
function responsiveFlexJustifyStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$justify, justify => {
    return {
      justifyContent: justify
    };
  });
}
function responsiveFlexDirectionStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$direction, direction => {
    return {
      flexDirection: direction
    };
  });
}
const BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  if (!props.$flex) return EMPTY_ARRAY;
  return _responsive(media, props.$flex, flex => ({
    flex
  }));
}
function focusRingBorderStyle(border) {
  return "inset 0 0 0 ".concat(border.width, "px ").concat(border.color);
}
function focusRingStyle(opts) {
  const {
    base,
    border,
    focusRing
  } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border && focusRingBorderStyle(border), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
const GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
const GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
const GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoFlow, autoFlow => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoRows, autoRows => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoCols, autoCols => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columns, columns => ({
    gridTemplateColumns: columns && "repeat(".concat(columns, ",minmax(0,1fr));")
  }));
}
function responsiveGridRowsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rows, rows => ({
    gridTemplateRows: rows && "repeat(".concat(rows, ",minmax(0,1fr));")
  }));
}
function responsiveGridGapStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, gap => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapX, gapX => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapY, gapY => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
const GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
};
const GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$row, row => {
    if (typeof row === "number") {
      return {
        gridRow: "span ".concat(row, " / span ").concat(row)
      };
    }
    return {
      gridRow: GRID_ITEM_ROW[row]
    };
  });
}
function responsiveGridItemRowStartStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowStart, rowStart => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowEnd, rowEnd => ({
    gridRowEnd: rowEnd
  }));
}
function responsiveGridItemColumnStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$column, column => {
    if (typeof column === "number") {
      return {
        gridColumn: "span ".concat(column, " / span ").concat(column)
      };
    }
    return {
      gridColumn: GRID_ITEM_COLUMN[column]
    };
  });
}
function responsiveGridItemColumnStartStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnStart, columnStart => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnEnd, columnEnd => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space
  } = props;
  const {
    font,
    media,
    space
  } = getTheme_v2(props.theme);
  const len = Math.max($padding.length, $space.length, $fontSize.length);
  const _padding = [];
  const _space = [];
  const _fontSize = [];
  for (let i = 0; i < len; i += 1) {
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i];
    _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i];
    _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  }
  return _responsive(media, _padding, (_, i) => {
    const size = font.text.sizes[_fontSize[i]] || font.text.sizes[2];
    const emSize = size.lineHeight - size.ascenderHeight - size.descenderHeight;
    const p = space[_padding[i]];
    const s = space[_space[i]];
    const styles = {
      paddingTop: rem(p - size.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size.descenderHeight),
      paddingLeft: rem(p)
    };
    if ($iconRight) styles.paddingRight = rem(p + emSize + s);
    if ($iconLeft) styles.paddingLeft = rem(p + emSize + s);
    return styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({
    ...props,
    $iconRight: true
  });
}
var __freeze$F = Object.freeze;
var __defProp$G = Object.defineProperty;
var __template$F = (cooked, raw) => __freeze$F(__defProp$G(cooked, "raw", {
  value: __freeze$F(raw || cooked.slice())
}));
var _a$F, _b$n, _c$c;
const ROOT_STYLE = css(_a$F || (_a$F = __template$F(["\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  align-items: center;\n"])));
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const {
    $scheme,
    $tone,
    $weight
  } = props;
  const {
    color,
    font
  } = getTheme_v2(props.theme);
  return css(_b$n || (_b$n = __template$F(["\n    appearance: none;\n    background: none;\n    border: 0;\n    border-radius: 0;\n    outline: none;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: ", ";\n    font-weight: ", ";\n    margin: 0;\n    position: relative;\n    z-index: 1;\n    display: block;\n\n    /* NOTE: This is a hack to disable Chrome\u2019s autofill styles */\n    &:-webkit-autofill,\n    &:-webkit-autofill:hover,\n    &:-webkit-autofill:focus,\n    &:-webkit-autofill:active {\n      -webkit-text-fill-color: var(--input-fg-color) !important;\n      transition: background-color 5000s;\n      transition-delay: 86400s /* 24h */;\n    }\n\n    /* &:is(textarea) */\n    &[data-as='textarea'] {\n      resize: none;\n    }\n\n    color: var(--input-fg-color);\n\n    &::placeholder {\n      color: var(--input-placeholder-color);\n    }\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --input-fg-color: ", ";\n      --input-placeholder-color: ", ";\n\n      /* enabled */\n      &:not(:invalid):not(:disabled):not(:read-only) {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* disabled */\n      &:not(:invalid):disabled {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* invalid */\n      &:invalid {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* readOnly */\n      &:read-only {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n    }\n  "])), font.text.family, $weight && font.text.weights[$weight] || font.text.weights.regular, $scheme, $tone, color.input.default.enabled.fg, color.input.default.enabled.placeholder, color.input.default.enabled.fg, color.input.default.enabled.placeholder, color.input.default.disabled.fg, color.input.default.disabled.placeholder, color.input.invalid.enabled.fg, color.input.invalid.enabled.placeholder, color.input.default.readOnly.fg, color.input.default.readOnly.placeholder);
}
function textInputFontSizeStyle(props) {
  const {
    font,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$fontSize, sizeIndex => {
    const size = font.text.sizes[sizeIndex] || font.text.sizes[2];
    return {
      fontSize: rem(size.fontSize),
      lineHeight: size.lineHeight / size.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    $unstableDisableFocusRing
  } = props;
  const {
    color,
    input
  } = getTheme_v2(props.theme);
  return css(_c$c || (_c$c = __template$F(["\n    --input-box-shadow: none;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: block;\n    pointer-events: none;\n    z-index: 0;\n\n    background-color: var(--card-bg-color);\n    box-shadow: var(--input-box-shadow);\n\n    border-top-left-radius: ", ";\n    border-bottom-left-radius: ", ";\n    border-top-right-radius: ", ";\n    border-bottom-right-radius: ", ";\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --card-bg-color: ", ";\n      --card-fg-color: ", ";\n\n      /* enabled */\n      *:not(:disabled) + &[data-border] {\n        --input-box-shadow: ", ";\n      }\n\n      /* invalid */\n      *:not(:disabled):invalid + & {\n        --card-bg-color: ", ";\n        --card-fg-color: ", ";\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* focused */\n      *:not(:disabled):focus + & {\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n\n        &:not([data-border]) {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* disabled */\n      *:not(:invalid):disabled + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n        --card-icon-color: ", " !important;\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      *:invalid:disabled + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n        --card-icon-color: ", " !important;\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* readOnly */\n      *:not(:invalid):read-only + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n      }\n\n      *:invalid:read-only + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n      }\n\n      /* hovered */\n      @media (hover: hover) {\n        *:not(:disabled):not(:read-only):not(:invalid):hover + & {\n          --card-bg-color: ", ";\n          --card-fg-color: ", ";\n        }\n\n        *:invalid:not(:disabled):not(:read-only):hover + & {\n          --card-bg-color: ", ";\n          --card-fg-color: ", ";\n        }\n\n        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {\n          --input-box-shadow: ", ";\n        }\n\n        *:invalid:not(:disabled):not(:read-only):not(:focus):hover + &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n    }\n  "])), $hasPrefix ? 0 : void 0, $hasPrefix ? 0 : void 0, $hasSuffix ? 0 : void 0, $hasSuffix ? 0 : void 0, $scheme, $tone, color.input.default.enabled.bg, color.input.default.enabled.fg, focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  }), color.input.invalid.enabled.bg, color.input.invalid.enabled.fg, focusRingBorderStyle({
    color: color.input.invalid.enabled.border,
    width: input.border.width
  }), $unstableDisableFocusRing ? void 0 : focusRingStyle({
    border: {
      color: color.input.default.enabled.border,
      width: input.border.width
    },
    focusRing: input.text.focusRing
  }), $unstableDisableFocusRing ? void 0 : focusRingStyle({
    focusRing: input.text.focusRing
  }), color.input.default.disabled.bg, color.input.default.disabled.fg, color.input.default.disabled.fg, focusRingBorderStyle({
    color: color.input.default.disabled.border,
    width: input.border.width
  }), color.input.invalid.disabled.bg, color.input.invalid.disabled.fg, color.input.invalid.disabled.fg, focusRingBorderStyle({
    color: color.input.invalid.disabled.border,
    width: input.border.width
  }), color.input.default.readOnly.bg, color.input.default.readOnly.fg, color.input.invalid.readOnly.bg, color.input.invalid.readOnly.fg, color.input.default.hovered.bg, color.input.default.hovered.fg, color.input.invalid.hovered.bg, color.input.invalid.hovered.fg, focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  }), focusRingBorderStyle({
    color: color.input.invalid.hovered.border,
    width: input.border.width
  }));
}
function responsiveMarginStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["margin"], props.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY), _getResponsiveSpace(theme, ["marginTop"], props.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["padding"], props.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const {
    media,
    radius
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$radius, value => {
    let borderRadius = 0;
    if (typeof value === "number") {
      borderRadius = rem(radius[value]);
    }
    if (value === "full") {
      borderRadius = "9999px";
    }
    return {
      borderRadius
    };
  });
}
function toBoxShadow(shadow, color) {
  return "".concat(shadow.map(rem).join(" "), " ").concat(color);
}
function shadowStyle(shadow) {
  let outlineWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  if (!shadow) return EMPTY_RECORD;
  const outline = "0 0 0 ".concat(rem(outlineWidth), " var(--card-shadow-outline-color)");
  const umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)");
  const penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)");
  const ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: "".concat(outline, ", ").concat(umbra, ", ").concat(penumbra, ", ").concat(ambient)
  };
}
function responsiveShadowStyle(props) {
  const {
    card,
    media,
    shadow
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$shadow, index => shadowStyle(shadow[index], card.shadow.outline));
}
var __freeze$E = Object.freeze;
var __defProp$F = Object.defineProperty;
var __template$E = (cooked, raw) => __freeze$E(__defProp$F(cooked, "raw", {
  value: __freeze$E(raw || cooked.slice())
}));
var _a$E, _b$m, _c$b;
function labelBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props;
  const {
    font
  } = getTheme_v2(props.theme);
  return css(_c$b || (_c$b = __template$E(["\n    text-transform: uppercase;\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && css(_a$E || (_a$E = __template$E(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && css(_b$m || (_b$m = __template$E(["\n      color: var(--card-muted-fg-color);\n    "]))), font.code.family);
}
var __freeze$D = Object.freeze;
var __defProp$E = Object.defineProperty;
var __template$D = (cooked, raw) => __freeze$D(__defProp$E(cooked, "raw", {
  value: __freeze$D(raw || cooked.slice())
}));
var _a$D;
const Root$C = styled.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle);
const SpanWithTextOverflow$2 = styled.span(_a$D || (_a$D = __template$D(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
const Label = forwardRef(function Label2(props, ref) {
  const {
    accent,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsx(SpanWithTextOverflow$2, {
      children
    });
  } else {
    children = /* @__PURE__ */jsx("span", {
      children
    });
  }
  return /* @__PURE__ */jsx(Root$C, {
    "data-ui": "Label",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children
  });
});
const avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle,
  image: avatarImageStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const {
    $color
  } = props;
  const {
    avatar
  } = getTheme_v2(props.theme);
  return {
    "--avatar-bg-color": "var(--card-avatar-".concat($color, "-bg-color)"),
    "--avatar-fg-color": "var(--card-avatar-".concat($color, "-fg-color)"),
    backgroundColor: "var(--avatar-bg-color)",
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing: avatar.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarImageStyle() {
  return {
    position: "relative"
  };
}
function avatarInitialsStyle() {
  return {
    width: "100%",
    height: "100%",
    color: "var(--avatar-fg-color)",
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "2px",
    stroke: "var(--avatar-bg-color)",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
const Root$B = styled.div(responsiveAvatarSizeStyle, avatarStyle.root);
const Arrow$1 = styled.div(avatarStyle.arrow);
const BgStroke = styled.ellipse(avatarStyle.bgStroke);
const Stroke = styled.ellipse(avatarStyle.stroke);
const Initials = styled.div(avatarStyle.initials);
const InitialsLabel = styled(Label)({
  color: "inherit"
});
const Image = styled.svg(avatarStyle.image);
const Avatar = forwardRef(function Avatar2(props, ref) {
  const {
    __unstable_hideInnerStroke,
    as: asProp,
    color = "gray",
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status = "online",
    size: sizeProp = 1,
    ...restProps
  } = props;
  const {
    avatar
  } = useTheme_v2();
  const as = ReactIs.isValidElementType(asProp) ? asProp : "div";
  const size = useArrayProp(sizeProp);
  const avatarSize = avatar.sizes[size[0]] || avatar.sizes[0];
  const _sizeRem = avatarSize.size;
  const _radius = _sizeRem / 2;
  const elementId = useId();
  const [arrowPosition, setArrowPosition] = useState(animateArrowFrom || arrowPositionProp || "inside");
  const [imageFailed, setImageFailed] = useState(false);
  const imageId = "avatar-image-".concat(elementId);
  useEffect(() => {
    if (arrowPosition === arrowPositionProp) return void 0;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, [arrowPosition, arrowPositionProp]);
  useEffect(() => {
    if (src) setImageFailed(false);
  }, [src]);
  const handleImageError = useCallback(() => {
    setImageFailed(true);
    if (onImageLoadError) {
      onImageLoadError(new Error("Avatar: the image failed to load"));
    }
  }, [onImageLoadError]);
  const initialsSize = useMemo(() => size.map(s => {
    if (s === 1) return 1;
    if (s === 2) return 3;
    if (s === 3) return 5;
    return 0;
  }), [size]);
  return /* @__PURE__ */jsxs(Root$B, {
    as,
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Avatar",
    ...restProps,
    $color: color,
    $size: size,
    "aria-label": title,
    "data-arrow-position": arrowPosition,
    "data-status": status,
    ref,
    title,
    children: [/* @__PURE__ */jsx(Arrow$1, {
      children: /* @__PURE__ */jsx("svg", {
        width: "11",
        height: "7",
        viewBox: "0 0 11 7",
        fill: "none",
        children: /* @__PURE__ */jsx("path", {
          d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z",
          fill: color
        })
      })
    }), !imageFailed && src && /* @__PURE__ */jsxs(Image, {
      viewBox: "0 0 ".concat(_sizeRem, " ").concat(_sizeRem),
      fill: "none",
      children: [/* @__PURE__ */jsx("defs", {
        children: /* @__PURE__ */jsx("pattern", {
          id: imageId,
          patternContentUnits: "objectBoundingBox",
          width: "1",
          height: "1",
          children: /* @__PURE__ */jsx("image", {
            href: src,
            width: "1",
            height: "1",
            onError: handleImageError
          })
        })
      }), /* @__PURE__ */jsx("circle", {
        cx: _radius,
        cy: _radius,
        r: _radius,
        fill: "url(#".concat(imageId, ")")
      }), !__unstable_hideInnerStroke && /* @__PURE__ */jsx(BgStroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        vectorEffect: "non-scaling-stroke"
      }), /* @__PURE__ */jsx(Stroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        vectorEffect: "non-scaling-stroke"
      })]
    }), (imageFailed || !src) && initials && /* @__PURE__ */jsx(Fragment, {
      children: /* @__PURE__ */jsx(Initials, {
        children: /* @__PURE__ */jsx(InitialsLabel, {
          forwardedAs: "span",
          size: initialsSize,
          weight: "medium",
          children: initials
        })
      })
    })]
  });
});
var __freeze$C = Object.freeze;
var __defProp$D = Object.defineProperty;
var __template$C = (cooked, raw) => __freeze$C(__defProp$D(cooked, "raw", {
  value: __freeze$C(raw || cooked.slice())
}));
var _a$C;
function _responsiveAvatarCounterSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size];
    if (!avatarSize) return EMPTY_RECORD;
    return {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    };
  });
}
function _avatarCounterBaseStyle(props) {
  const {
    space
  } = getTheme_v2(props.theme);
  return css(_a$C || (_a$C = __template$C(["\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    user-select: none;\n    color: inherit;\n    color: var(--card-fg-color);\n    background: var(--card-bg-color);\n    box-shadow:\n      0 0 0 1px var(--card-bg-color),\n      inset 0 0 0 1px var(--card-hairline-hard-color);\n    padding: 0 ", ";\n\n    &:not([hidden]) {\n      display: flex;\n    }\n  "])), rem(space[2]));
}
const Root$A = styled.div(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle);
const AvatarCounter = forwardRef(function AvatarCounter2(props, ref) {
  const {
    count,
    size: sizeProp = 1
  } = props;
  const size = useArrayProp(sizeProp);
  const fontSize = useMemo(() => size.map(s => {
    if (s === 1) return 1;
    if (s === 2) return 3;
    if (s === 3) return 5;
    return 0;
  }), [size]);
  return /* @__PURE__ */jsx(Root$A, {
    $size: size,
    "data-ui": "AvatarCounter",
    ref,
    children: /* @__PURE__ */jsx(Label, {
      as: "span",
      size: fontSize,
      weight: "medium",
      children: count
    })
  });
});
function childrenToElementArray(children) {
  const childrenArray = Array.isArray(children) ? children : [children];
  return childrenArray.filter(node => isElement$1(node) || isFragment(node) || typeof node === "string");
}
var __freeze$B = Object.freeze;
var __defProp$C = Object.defineProperty;
var __template$B = (cooked, raw) => __freeze$B(__defProp$C(cooked, "raw", {
  value: __freeze$B(raw || cooked.slice())
}));
var _a$B;
const BASE_STYLES = css(_a$B || (_a$B = __template$B(["\n  white-space: nowrap;\n\n  & > div {\n    vertical-align: top;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  }\n"])));
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size];
    if (!avatarSize) return EMPTY_RECORD;
    return {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    };
  });
}
const Root$z = styled.div(responsiveAvatarStackSizeStyle, avatarStackStyle);
const AvatarStack = forwardRef(function AvatarStack2(props, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 1,
    ...restProps
  } = props;
  const children = childrenToElementArray(childrenProp).filter(child => typeof child !== "string");
  const maxLength = Math.max(maxLengthProp, 0);
  const size = useArrayProp(sizeProp);
  const len = children.length;
  const visibleCount = maxLength - 1;
  const extraCount = len - visibleCount;
  const visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return /* @__PURE__ */jsxs(Root$z, {
    "data-ui": "AvatarStack",
    ...restProps,
    ref,
    $size: size,
    children: [len === 0 && /* @__PURE__ */jsx("div", {
      children: /* @__PURE__ */jsx(AvatarCounter, {
        count: len,
        size
      })
    }), len !== 0 && extraCount > 1 && /* @__PURE__ */jsx("div", {
      children: /* @__PURE__ */jsx(AvatarCounter, {
        count: extraCount,
        size
      })
    }), visibleChildren.map((child, childIndex) => /* @__PURE__ */jsx("div", {
      children: cloneElement(child, {
        size
      })
    }, String(childIndex)))]
  });
});
const Root$y = styled.div(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle);
const Box = forwardRef(function Box2(props, ref) {
  const {
    as: asProp = "div",
    column,
    columnStart,
    columnEnd,
    display = "block",
    flex,
    height,
    margin = 0,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding = 0,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$y, {
    "data-as": typeof asProp === "string" ? asProp : void 0,
    "data-ui": "Box",
    ...restProps,
    $column: useArrayProp(column),
    $columnStart: useArrayProp(columnStart),
    $columnEnd: useArrayProp(columnEnd),
    $display: useArrayProp(display),
    $flex: useArrayProp(flex),
    $height: useArrayProp(height),
    $margin: useArrayProp(margin),
    $marginX: useArrayProp(marginX),
    $marginY: useArrayProp(marginY),
    $marginTop: useArrayProp(marginTop),
    $marginRight: useArrayProp(marginRight),
    $marginBottom: useArrayProp(marginBottom),
    $marginLeft: useArrayProp(marginLeft),
    $overflow: useArrayProp(overflow),
    $padding: useArrayProp(padding),
    $paddingX: useArrayProp(paddingX),
    $paddingY: useArrayProp(paddingY),
    $paddingTop: useArrayProp(paddingTop),
    $paddingRight: useArrayProp(paddingRight),
    $paddingBottom: useArrayProp(paddingBottom),
    $paddingLeft: useArrayProp(paddingLeft),
    $row: useArrayProp(row),
    $rowStart: useArrayProp(rowStart),
    $rowEnd: useArrayProp(rowEnd),
    $sizing: useArrayProp(sizing),
    as: asProp,
    ref,
    children: props.children
  });
});
var __freeze$A = Object.freeze;
var __defProp$B = Object.defineProperty;
var __template$A = (cooked, raw) => __freeze$A(__defProp$B(cooked, "raw", {
  value: __freeze$A(raw || cooked.slice())
}));
var _a$A, _b$l, _c$a;
function textBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props;
  const {
    font
  } = getTheme_v2(props.theme);
  return css(_c$a || (_c$a = __template$A(["\n    color: var(--card-fg-color);\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n      background-color: var(--card-code-bg-color);\n      color: var(--card-code-fg-color);\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & strong {\n      font-weight: ", ";\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n      color: var(--card-icon-color);\n\n      & path {\n        vector-effect: non-scaling-stroke !important;\n      }\n    }\n  "])), $accent && css(_a$A || (_a$A = __template$A(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && css(_b$l || (_b$l = __template$A(["\n      color: var(--card-muted-fg-color);\n    "]))), font.code.family, font.text.weights.bold);
}
var __freeze$z = Object.freeze;
var __defProp$A = Object.defineProperty;
var __template$z = (cooked, raw) => __freeze$z(__defProp$A(cooked, "raw", {
  value: __freeze$z(raw || cooked.slice())
}));
var _a$z;
const Root$x = styled.div(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle);
const SpanWithTextOverflow$1 = styled.span(_a$z || (_a$z = __template$z(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
const Text = forwardRef(function Text2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsx(SpanWithTextOverflow$1, {
      children
    });
  }
  return /* @__PURE__ */jsx(Root$x, {
    "data-ui": "Text",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    ref,
    $size: useArrayProp(size),
    $weight: weight,
    children: /* @__PURE__ */jsx("span", {
      children
    })
  });
});
function badgeStyle(props) {
  const {
    $tone
  } = props;
  return {
    "--card-bg-color": "var(--card-badge-".concat($tone, "-bg-color)"),
    "--card-fg-color": "var(--card-badge-".concat($tone, "-fg-color)"),
    backgroundColor: "var(--card-bg-color)",
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block",
      verticalAlign: "top"
    }
  };
}
const Root$w = styled(Box)(responsiveRadiusStyle, badgeStyle);
const Badge = forwardRef(function Badge2(props, ref) {
  const {
    children,
    fontSize = 1,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mode: _deprecated_mode,
    padding = 1,
    radius = "full",
    tone = "default",
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$w, {
    "data-ui": "Badge",
    ...restProps,
    $tone: tone,
    $radius: useArrayProp(radius),
    padding: useArrayProp(padding),
    ref,
    children: /* @__PURE__ */jsx(Text, {
      size: fontSize,
      children
    })
  });
});
const Root$v = styled(Box)(flexItemStyle, responsiveFlexStyle);
const Flex = forwardRef(function Flex2(props, ref) {
  const {
    align,
    as,
    direction = "row",
    gap,
    justify,
    wrap,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$v, {
    "data-ui": "Flex",
    ...restProps,
    $align: useArrayProp(align),
    $direction: useArrayProp(direction),
    $gap: useArrayProp(gap),
    $justify: useArrayProp(justify),
    $wrap: useArrayProp(wrap),
    forwardedAs: as,
    ref
  });
});
var __freeze$y = Object.freeze;
var __defProp$z = Object.defineProperty;
var __template$y = (cooked, raw) => __freeze$y(__defProp$z(cooked, "raw", {
  value: __freeze$y(raw || cooked.slice())
}));
var _a$y, _b$k;
const rotate$1 = keyframes(_a$y || (_a$y = __template$y(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
const Root$u = styled(Text)(_b$k || (_b$k = __template$y(["\n  & > span > svg {\n    animation: ", " 500ms linear infinite;\n  }\n"])), rotate$1);
const Spinner = forwardRef(function Spinner2(props, ref) {
  return /* @__PURE__ */jsx(Root$u, {
    "data-ui": "Spinner",
    ...props,
    ref,
    children: /* @__PURE__ */jsx(SpinnerIcon, {})
  });
});
function _cardColorStyle(base, color) {
  let checkered = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    // from base
    "--card-backdrop-color": base.backdrop,
    "--card-focus-ring-color": base.focusRing,
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    // from state
    "--card-accent-fg-color": color.accent.fg,
    "--card-avatar-gray-bg-color": color.avatar.gray.bg,
    "--card-avatar-gray-fg-color": color.avatar.gray.fg,
    "--card-avatar-blue-bg-color": color.avatar.blue.bg,
    "--card-avatar-blue-fg-color": color.avatar.blue.fg,
    "--card-avatar-purple-bg-color": color.avatar.purple.bg,
    "--card-avatar-purple-fg-color": color.avatar.purple.fg,
    "--card-avatar-magenta-bg-color": color.avatar.magenta.bg,
    "--card-avatar-magenta-fg-color": color.avatar.magenta.fg,
    "--card-avatar-red-bg-color": color.avatar.red.bg,
    "--card-avatar-red-fg-color": color.avatar.red.fg,
    "--card-avatar-orange-bg-color": color.avatar.orange.bg,
    "--card-avatar-orange-fg-color": color.avatar.orange.fg,
    "--card-avatar-yellow-bg-color": color.avatar.yellow.bg,
    "--card-avatar-yellow-fg-color": color.avatar.yellow.fg,
    "--card-avatar-green-bg-color": color.avatar.green.bg,
    "--card-avatar-green-fg-color": color.avatar.green.fg,
    "--card-avatar-cyan-bg-color": color.avatar.cyan.bg,
    "--card-avatar-cyan-fg-color": color.avatar.cyan.fg,
    "--card-bg-color": color.bg,
    "--card-bg-image": checkered ? "repeating-conic-gradient(".concat(color.bg, " 0% 25%, ").concat(color.muted.bg, " 0% 50%)") : void 0,
    "--card-border-color": color.border,
    "--card-badge-default-bg-color": color.badge.default.bg,
    "--card-badge-default-dot-color": color.badge.default.dot,
    "--card-badge-default-fg-color": color.badge.default.fg,
    "--card-badge-default-icon-color": color.badge.default.icon,
    "--card-badge-primary-bg-color": color.badge.primary.bg,
    "--card-badge-primary-dot-color": color.badge.primary.dot,
    "--card-badge-primary-fg-color": color.badge.primary.fg,
    "--card-badge-primary-icon-color": color.badge.primary.icon,
    "--card-badge-positive-bg-color": color.badge.positive.bg,
    "--card-badge-positive-dot-color": color.badge.positive.dot,
    "--card-badge-positive-fg-color": color.badge.positive.fg,
    "--card-badge-positive-icon-color": color.badge.positive.icon,
    "--card-badge-caution-bg-color": color.badge.caution.bg,
    "--card-badge-caution-dot-color": color.badge.caution.dot,
    "--card-badge-caution-fg-color": color.badge.caution.fg,
    "--card-badge-caution-icon-color": color.badge.caution.icon,
    "--card-badge-critical-bg-color": color.badge.critical.bg,
    "--card-badge-critical-dot-color": color.badge.critical.dot,
    "--card-badge-critical-fg-color": color.badge.critical.fg,
    "--card-badge-critical-icon-color": color.badge.critical.icon,
    "--card-code-bg-color": color.code.bg,
    "--card-code-fg-color": color.code.fg,
    "--card-fg-color": color.fg,
    "--card-icon-color": color.icon,
    "--card-kbd-bg-color": color.kbd.bg,
    "--card-kbd-border-color": color.kbd.border,
    "--card-kbd-fg-color": color.kbd.fg,
    "--card-link-fg-color": color.link.fg,
    "--card-muted-bg-color": color.muted.bg,
    "--card-muted-fg-color": color.muted.fg,
    "--card-skeleton-color-from": color.skeleton.from,
    "--card-skeleton-color-to": color.skeleton.to,
    // deprecated variables (kept for legacy)
    "--card-bg2-color": color.muted.bg,
    "--card-link-color": color.link.fg,
    "--card-hairline-soft-color": color.border,
    "--card-hairline-hard-color": color.border
  };
}
var __freeze$x = Object.freeze;
var __defProp$y = Object.defineProperty;
var __template$x = (cooked, raw) => __freeze$x(__defProp$y(cooked, "raw", {
  value: __freeze$x(raw || cooked.slice())
}));
var _a$x, _b$j;
function buttonBaseStyles(props) {
  const {
    $width
  } = props;
  const {
    style
  } = getTheme_v2(props.theme);
  return css(_b$j || (_b$j = __template$x(["\n    ", ";\n\n    -webkit-font-smoothing: inherit;\n    appearance: none;\n    display: inline-flex;\n    align-items: center;\n    font: inherit;\n    border: 0;\n    outline: none;\n    user-select: none;\n    text-decoration: none;\n    border: 0;\n    box-sizing: border-box;\n    padding: 0;\n    margin: 0;\n    white-space: nowrap;\n    text-align: left;\n    position: relative;\n    vertical-align: top;\n\n    ", "\n\n    & > span {\n      display: block;\n      flex: 1;\n      min-width: 0;\n      border-radius: inherit;\n    }\n\n    &::-moz-focus-inner {\n      border: 0;\n      padding: 0;\n    }\n  "])), style == null ? void 0 : style.button, $width === "fill" && css(_a$x || (_a$x = __template$x(["\n      width: -moz-available;\n      width: -webkit-fill-available;\n      width: stretch;\n    "]))));
}
function combineBoxShadow() {
  for (var _len = arguments.length, boxShadows = new Array(_len), _key = 0; _key < _len; _key++) {
    boxShadows[_key] = arguments[_key];
  }
  return boxShadows.filter(Boolean).join(",");
}
function buttonColorStyles(props) {
  var _a2;
  const {
    $mode
  } = props;
  const {
    button,
    color: baseColor,
    style
  } = getTheme_v2(props.theme);
  const shadow = props.$mode === "ghost";
  const mode = baseColor.button[$mode] || baseColor.button.default;
  const color = mode[props.$tone] || mode.default;
  const border = {
    width: button.border.width,
    color: "var(--card-border-color)"
  };
  const defaultBoxShadow = void 0;
  return [_cardColorStyle(baseColor, color.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border),
    '&:disabled, &[data-disabled="true"]': _cardColorStyle(baseColor, color.disabled),
    "&:not([data-disabled='true'])": {
      boxShadow: combineBoxShadow(focusRingBorderStyle(border), shadow ? defaultBoxShadow : void 0),
      "&:focus": {
        boxShadow: focusRingStyle({
          base: baseColor,
          border: {
            width: 2,
            color: baseColor.bg
          },
          focusRing: button.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: combineBoxShadow(focusRingBorderStyle(border), shadow ? defaultBoxShadow : void 0)
      },
      "@media (hover: hover)": {
        "&:hover": _cardColorStyle(baseColor, color.hovered),
        "&:active": _cardColorStyle(baseColor, color.pressed),
        "&[data-hovered]": _cardColorStyle(baseColor, color.hovered)
      },
      "&[data-selected]": _cardColorStyle(baseColor, color.pressed)
    }
  }, (_a2 = style == null ? void 0 : style.button) == null ? void 0 : _a2.root].filter(Boolean);
}
var __freeze$w = Object.freeze;
var __defProp$x = Object.defineProperty;
var __template$w = (cooked, raw) => __freeze$w(__defProp$x(cooked, "raw", {
  value: __freeze$w(raw || cooked.slice())
}));
var _a$w;
const Root$t = styled.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles);
const LoadingBox = styled.div(_a$w || (_a$w = __template$w(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: var(--card-bg-color);\n  border-radius: inherit;\n  z-index: 1;\n  box-shadow: inherit;\n"])));
const Button = forwardRef(function Button2(props, ref) {
  const {
    children,
    disabled,
    fontSize = 1,
    icon,
    iconRight,
    justify: justifyProp = "center",
    loading,
    mode = "default",
    padding: paddingProp = 3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: radiusProp = 2,
    selected,
    space: spaceProp = 3,
    text,
    textAlign,
    tone = "default",
    type = "button",
    muted = false,
    width,
    ...restProps
  } = props;
  const {
    button
  } = useTheme_v2();
  const justify = useArrayProp(justifyProp);
  const padding = useArrayProp(paddingProp);
  const paddingX = useArrayProp(paddingXProp);
  const paddingY = useArrayProp(paddingYProp);
  const paddingTop = useArrayProp(paddingTopProp);
  const paddingBottom = useArrayProp(paddingBottomProp);
  const paddingLeft = useArrayProp(paddingLeftProp);
  const paddingRight = useArrayProp(paddingRightProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const boxProps = useMemo(() => ({
    // flex: 1,
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }), [padding, paddingX, paddingY, paddingTop, paddingBottom, paddingLeft, paddingRight]);
  return /* @__PURE__ */jsxs(Root$t, {
    "data-ui": "Button",
    ...restProps,
    $mode: mode,
    $radius: radius,
    $tone: tone,
    "data-disabled": Boolean(loading || disabled),
    "data-selected": selected ? "" : void 0,
    disabled: Boolean(loading || disabled),
    ref,
    type,
    $width: width,
    children: [Boolean(loading) && /* @__PURE__ */jsx(LoadingBox, {
      children: /* @__PURE__ */jsx(Spinner, {})
    }), (icon || text || iconRight) && /* @__PURE__ */jsx(Box, {
      as: "span",
      ...boxProps,
      children: /* @__PURE__ */jsxs(Flex, {
        as: "span",
        justify,
        gap: space,
        children: [icon && /* @__PURE__ */jsxs(Text, {
          size: fontSize,
          children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
        }), text && /* @__PURE__ */jsx(Text, {
          muted,
          align: textAlign,
          size: fontSize,
          textOverflow: "ellipsis",
          weight: button.textWeight,
          children: text
        }), iconRight && /* @__PURE__ */jsxs(Text, {
          size: fontSize,
          children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
        })]
      })
    }), children && /* @__PURE__ */jsx(Box, {
      as: "span",
      ...boxProps,
      children
    })]
  });
});
var __freeze$v = Object.freeze;
var __defProp$w = Object.defineProperty;
var __template$v = (cooked, raw) => __freeze$v(__defProp$w(cooked, "raw", {
  value: __freeze$v(raw || cooked.slice())
}));
var _a$v, _b$i, _c$9;
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const {
    $checkered
  } = props;
  const {
    space
  } = getTheme_v2(props.theme);
  return css(_b$i || (_b$i = __template$v(["\n    ", "\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -moz-available;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      outline: none;\n      text-decoration: none;\n    }\n\n    /* &:is(pre) */\n    &[data-as='pre'] {\n      font: inherit;\n    }\n  "])), $checkered && css(_a$v || (_a$v = __template$v(["\n      background-size: ", "px ", "px;\n      background-position: 50% 50%;\n      background-image: var(--card-bg-image);\n    "])), space[3], space[3]));
}
function cardColorStyle(props) {
  var _a2;
  const {
    $checkered,
    $focusRing
  } = props;
  const {
    card,
    color,
    style
  } = getTheme_v2(props.theme);
  const border = {
    width: card.border.width,
    color: "var(--card-border-color)"
  };
  return css(_c$9 || (_c$9 = __template$v(["\n    color-scheme: ", ";\n\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      --card-focus-ring-box-shadow: none;\n\n      cursor: default;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus-visible {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      cursor: pointer;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus-visible {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    ", "\n  "])), color._dark ? "dark" : "light", _cardColorStyle(color, color, $checkered), _cardColorStyle(color, color.selectable.default.disabled, $checkered), _cardColorStyle(color, color.selectable.default.pressed, $checkered), _cardColorStyle(color, color.selectable.default.selected, $checkered), _cardColorStyle(color, color.selectable.default.hovered, $checkered), _cardColorStyle(color, color.selectable.default.pressed, $checkered), $focusRing ? focusRingStyle({
    base: color,
    border,
    focusRing: card.focusRing
  }) : void 0, _cardColorStyle(color, color.selectable.default.disabled, $checkered), _cardColorStyle(color, color.selectable.default.pressed, $checkered), _cardColorStyle(color, color.selectable.default.selected, $checkered), _cardColorStyle(color, color.selectable.default.hovered, $checkered), _cardColorStyle(color, color.selectable.default.pressed, $checkered), $focusRing ? focusRingStyle({
    base: color,
    border,
    focusRing: card.focusRing
  }) : void 0, (_a2 = style == null ? void 0 : style.card) == null ? void 0 : _a2.root);
}
const Root$s = styled(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle);
const Card = forwardRef(function Card2(props, ref) {
  const {
    __unstable_checkered: checkered = false,
    __unstable_focusRing: focusRing = false,
    as: asProp,
    border,
    borderTop,
    borderRight,
    borderBottom,
    borderLeft,
    pressed,
    radius = 0,
    scheme,
    selected,
    shadow,
    tone: toneProp = "default",
    ...restProps
  } = props;
  const as = isValidElementType(asProp) ? asProp : "div";
  const rootTheme = useRootTheme();
  const tone = toneProp === "inherit" ? rootTheme.tone : toneProp;
  return /* @__PURE__ */jsx(ThemeColorProvider, {
    scheme,
    tone,
    children: /* @__PURE__ */jsx(Root$s, {
      "data-as": typeof as === "string" ? as : void 0,
      "data-scheme": rootTheme.scheme,
      "data-ui": "Card",
      "data-tone": tone,
      ...restProps,
      $border: useArrayProp(border),
      $borderTop: useArrayProp(borderTop),
      $borderRight: useArrayProp(borderRight),
      $borderBottom: useArrayProp(borderBottom),
      $borderLeft: useArrayProp(borderLeft),
      $checkered: checkered,
      $focusRing: focusRing,
      $radius: useArrayProp(radius),
      $shadow: useArrayProp(shadow),
      $tone: tone,
      "data-checkered": checkered ? "" : void 0,
      "data-pressed": pressed ? "" : void 0,
      "data-selected": selected ? "" : void 0,
      forwardedAs: as,
      ref,
      selected
    })
  });
});
var __freeze$u = Object.freeze;
var __defProp$v = Object.defineProperty;
var __template$u = (cooked, raw) => __freeze$u(__defProp$v(cooked, "raw", {
  value: __freeze$u(raw || cooked.slice())
}));
var _a$u, _b$h;
function checkboxBaseStyles() {
  return css(_a$u || (_a$u = __template$u(["\n    position: relative;\n    display: inline-block;\n  "])));
}
function inputElementStyles(props) {
  const {
    color,
    input,
    radius
  } = getTheme_v2(props.theme);
  const {
    focusRing
  } = input.checkbox;
  return css(_b$h || (_b$h = __template$u(["\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    outline: none;\n    opacity: 0;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n\n    & + span {\n      position: relative;\n      display: block;\n      height: ", ";\n      width: ", ";\n      box-sizing: border-box;\n      box-shadow: ", ";\n      border-radius: ", ";\n      line-height: 1;\n      background-color: ", ";\n\n      & > svg {\n        display: block;\n        position: absolute;\n        opacity: 0;\n        height: 100%;\n        width: 100%;\n\n        & > path {\n          vector-effect: non-scaling-stroke;\n          stroke-width: 1.5px !important;\n        }\n      }\n    }\n\n    &:checked + span {\n      background: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    /* focus */\n    &:not(:disabled):focus:focus-visible + span {\n      box-shadow: ", ";\n    }\n\n    /* focus when checked - uses a different offset */\n    &:not(:disabled):focus:focus-visible&:checked + span {\n      box-shadow: ", ";\n    }\n\n    &[data-error] + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n    &[data-error]&:checked + span {\n      background-color: ", ";\n      color: ", ";\n    }\n    &[data-error]&:checked&:not(:disabled):focus:focus-visible + span {\n      box-shadow: ", ";\n    }\n\n    &:disabled + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n    &:disabled&:checked + span {\n      background-color: ", ";\n    }\n\n    &[data-read-only] + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &[data-read-only]&:checked + span {\n      background-color: ", ";\n    }\n\n    &:checked + span > svg:first-child {\n      opacity: 1;\n    }\n    &:indeterminate + span > svg:last-child {\n      opacity: 1;\n    }\n  "])), rem(input.checkbox.size), rem(input.checkbox.size), focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  }), rem(radius[2]), color.input.default.enabled.bg, color.input.default.enabled.fg, focusRingBorderStyle({
    color: color.input.default.enabled.fg,
    width: input.border.width
  }), color.input.default.enabled.bg, focusRingStyle({
    focusRing
  }), focusRingStyle({
    focusRing: {
      width: 1,
      offset: 1
    }
  }), color.input.invalid.enabled.border, focusRingBorderStyle({
    width: input.border.width,
    color: color.input.invalid.enabled.muted.bg
  }), color.input.default.disabled.fg, color.input.invalid.enabled.muted.bg, color.input.default.enabled.bg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color.input.invalid.readOnly.muted.bg
    },
    focusRing: {
      width: 1,
      offset: 1
    }
  }), color.input.default.disabled.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color.input.default.disabled.border
  }), color.input.default.disabled.fg, color.input.default.disabled.muted.bg, color.input.default.readOnly.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color.input.default.readOnly.border
  }), color.input.default.readOnly.fg, color.input.default.readOnly.muted.bg);
}
const Root$r = styled.div(checkboxBaseStyles);
const Input$5 = styled.input(inputElementStyles);
const Checkbox = forwardRef(function Checkbox2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  useEffect(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return /* @__PURE__ */jsxs(Root$r, {
    className,
    "data-ui": "Checkbox",
    style,
    children: [/* @__PURE__ */jsx(Input$5, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      "data-error": customValidity ? "" : void 0,
      ...restProps,
      checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      readOnly,
      ref
    }), /* @__PURE__ */jsxs("span", {
      children: [/* @__PURE__ */jsx(CheckmarkIcon, {}), /* @__PURE__ */jsx(RemoveIcon, {})]
    })]
  });
});
var __freeze$t = Object.freeze;
var __defProp$u = Object.defineProperty;
var __template$t = (cooked, raw) => __freeze$t(__defProp$u(cooked, "raw", {
  value: __freeze$t(raw || cooked.slice())
}));
var _a$t;
function codeSyntaxHighlightingStyle(_ref2) {
  let {
    theme
  } = _ref2;
  const {
    color: {
      syntax: color
    }
  } = getTheme_v2(theme);
  return {
    "&.atrule": {
      color: color.atrule
    },
    "&.attr-name": {
      color: color.attrName
    },
    "&.attr-value": {
      color: color.attrValue
    },
    "&.attribute": {
      color: color.attribute
    },
    "&.boolean": {
      color: color.boolean
    },
    "&.builtin": {
      color: color.builtin
    },
    "&.cdata": {
      color: color.cdata
    },
    "&.char": {
      color: color.char
    },
    "&.class": {
      color: color.class
    },
    "&.class-name": {
      color: color.className
    },
    "&.comment": {
      color: color.comment
    },
    "&.constant": {
      color: color.constant
    },
    "&.deleted": {
      color: color.deleted
    },
    "&.doctype": {
      color: color.doctype
    },
    "&.entity": {
      color: color.entity
    },
    "&.function": {
      color: color.function
    },
    "&.hexcode": {
      color: color.hexcode
    },
    "&.id": {
      color: color.id
    },
    "&.important": {
      color: color.important
    },
    "&.inserted": {
      color: color.inserted
    },
    "&.keyword": {
      color: color.keyword
    },
    "&.number": {
      color: color.number
    },
    "&.operator": {
      color: color.operator
    },
    "&.prolog": {
      color: color.prolog
    },
    "&.property": {
      color: color.property
    },
    "&.pseudo-class": {
      color: color.pseudoClass
    },
    "&.pseudo-element": {
      color: color.pseudoElement
    },
    "&.punctuation": {
      color: color.punctuation
    },
    "&.regex": {
      color: color.regex
    },
    "&.selector": {
      color: color.selector
    },
    "&.string": {
      color: color.string
    },
    "&.symbol": {
      color: color.symbol
    },
    "&.tag": {
      color: color.tag
    },
    "&.unit": {
      color: color.unit
    },
    "&.url": {
      color: color.url
    },
    "&.variable": {
      color: color.variable
    }
  };
}
function codeBaseStyle() {
  return css(_a$t || (_a$t = __template$t(["\n    color: var(--card-code-fg-color);\n\n    & code {\n      font-family: inherit;\n\n      &.refractor .token {\n        ", "\n      }\n    }\n\n    & a {\n      color: inherit;\n      text-decoration: underline;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), codeSyntaxHighlightingStyle);
}
const Root$q = styled.pre(codeBaseStyle, responsiveCodeFontStyle);
const Code = forwardRef(function Code2(props, ref) {
  const {
    children,
    language: languageProp,
    size = 2,
    weight,
    ...restProps
  } = props;
  const language = typeof languageProp === "string" ? languageProp : void 0;
  const registered = language ? Refractor.hasLanguage(language) : false;
  return /* @__PURE__ */jsxs(Root$q, {
    "data-ui": "Code",
    ...restProps,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children: [!(language && registered) && /* @__PURE__ */jsx("code", {
      children
    }), language && registered && /* @__PURE__ */jsx(Refractor, {
      inline: true,
      language,
      value: String(children)
    })]
  });
});
const BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const {
    container,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$width, val => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
const Root$p = styled(Box)(containerBaseStyle, responsiveContainerWidthStyle);
const Container = forwardRef(function Container2(props, ref) {
  const {
    as,
    width = 2,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$p, {
    "data-ui": "Container",
    ...restProps,
    $width: useArrayProp(width),
    forwardedAs: as,
    ref
  });
});
const Root$o = styled(Box)(responsiveGridStyle);
const Grid = forwardRef(function Grid2(props, ref) {
  const {
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$o, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Grid",
    ...restProps,
    $autoRows: useArrayProp(autoRows),
    $autoCols: useArrayProp(autoCols),
    $autoFlow: useArrayProp(autoFlow),
    $columns: useArrayProp(columns),
    $gap: useArrayProp(gap),
    $gapX: useArrayProp(gapX),
    $gapY: useArrayProp(gapY),
    $rows: useArrayProp(rows),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$s = Object.freeze;
var __defProp$t = Object.defineProperty;
var __template$s = (cooked, raw) => __freeze$s(__defProp$t(cooked, "raw", {
  value: __freeze$s(raw || cooked.slice())
}));
var _a$s, _b$g, _c$8;
function headingBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props;
  const {
    font
  } = getTheme_v2(props.theme);
  return css(_c$8 || (_c$8 = __template$s(["\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & strong {\n      font-weight: ", ";\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && css(_a$s || (_a$s = __template$s(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && css(_b$g || (_b$g = __template$s(["\n      color: var(--card-muted-fg-color);\n    "]))), font.code.family, font.heading.weights.bold);
}
var __freeze$r = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$r = (cooked, raw) => __freeze$r(__defProp$s(cooked, "raw", {
  value: __freeze$r(raw || cooked.slice())
}));
var _a$r;
const Root$n = styled.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont);
const SpanWithTextOverflow = styled.span(_a$r || (_a$r = __template$r(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
const Heading = forwardRef(function Heading2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsx(SpanWithTextOverflow, {
      children
    });
  }
  return /* @__PURE__ */jsx(Root$n, {
    "data-ui": "Heading",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children: /* @__PURE__ */jsx("span", {
      children
    })
  });
});
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, spaceIndex => {
    const _space = rem(spaceIndex === 0.5 ? space[1] / 2 : space[spaceIndex]);
    return {
      margin: "-".concat(_space, " 0 0 -").concat(_space),
      "& > div": {
        padding: "".concat(_space, " 0 0 ").concat(_space)
      }
    };
  });
}
const Root$m = styled(Box)(inlineBaseStyle, inlineSpaceStyle);
const Inline = forwardRef(function Inline2(props, ref) {
  const {
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props;
  const children = useMemo(() => childrenToElementArray(childrenProp).filter(Boolean).map((child, idx) => /* @__PURE__ */jsx("div", {
    children: child
  }, idx)), [childrenProp]);
  return /* @__PURE__ */jsx(Root$m, {
    "data-ui": "Inline",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$q = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$q = (cooked, raw) => __freeze$q(__defProp$r(cooked, "raw", {
  value: __freeze$q(raw || cooked.slice())
}));
var _a$q;
function kbdStyle() {
  return css(_a$q || (_a$q = __template$q(["\n    --card-bg-color: var(--card-kbd-bg-color);\n    --card-border-color: var(--card-kbd-border-color);\n    --card-fg-color: var(--card-kbd-fg-color);\n\n    box-shadow: inset 0 0 0 1px var(--card-border-color);\n    background: var(--card-bg-color);\n    font: inherit;\n\n    vertical-align: top;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
const Root$l = styled.kbd(responsiveRadiusStyle, kbdStyle);
const KBD = forwardRef(function KBD2(props, ref) {
  const {
    children,
    fontSize = 0,
    padding = 1,
    radius = 2,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$l, {
    "data-ui": "KBD",
    ...restProps,
    $radius: useArrayProp(radius),
    ref,
    children: /* @__PURE__ */jsx(Box, {
      as: "span",
      padding,
      children: /* @__PURE__ */jsx(Text, {
        as: "span",
        size: fontSize,
        weight: "semibold",
        children
      })
    })
  });
});
const origin = {
  name: "@sanity/ui/origin",
  fn(_ref3) {
    let {
      middlewareData,
      placement,
      rects
    } = _ref3;
    var _a, _b;
    const [side] = placement.split("-");
    const floatingWidth = rects.floating.width;
    const floatingHeight = rects.floating.height;
    const shiftX = ((_a = middlewareData.shift) == null ? void 0 : _a.x) || 0;
    const shiftY = ((_b = middlewareData.shift) == null ? void 0 : _b.y) || 0;
    if (floatingWidth <= 0 || floatingHeight <= 0) {
      return {};
    }
    const isVerticalPlacement = ["bottom", "top"].includes(side);
    const {
      originX,
      originY
    } = isVerticalPlacement ? {
      originX: clamp(0.5 - shiftX / floatingWidth, 0, 1),
      originY: side === "bottom" ? 0 : 1
    } : {
      originX: side === "left" ? 1 : 0,
      originY: clamp(0.5 - shiftY / floatingHeight, 0, 1)
    };
    return {
      data: {
        originX,
        originY
      }
    };
  }
};
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function moveTowardsLength(movingPoint, targetPoint, amount) {
  const width = targetPoint.x - movingPoint.x;
  const height = targetPoint.y - movingPoint.y;
  const distance = Math.sqrt(width * width + height * height);
  return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));
}
function moveTowardsFractional(movingPoint, targetPoint, fraction) {
  return {
    x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
    y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
  };
}
function getRoundedCommands(points) {
  const len = points.length;
  const cmds = [];
  for (let i = 0; i < len; i += 1) {
    const point = points[i];
    const prevPoint = points[i - 1];
    const nextPoint = points[i + 1];
    if (prevPoint && point.radius) {
      const curveStart = moveTowardsLength(point, prevPoint, point.radius);
      const curveEnd = moveTowardsLength(point, nextPoint, point.radius);
      const startControl = moveTowardsFractional(curveStart, point, 0.5);
      const endControl = moveTowardsFractional(point, curveEnd, 0.5);
      cmds.push({
        type: "point",
        ...curveStart
      });
      cmds.push({
        type: "curve",
        curveEnd,
        startControl,
        endControl
      });
    } else {
      cmds.push({
        type: "point",
        ...point
      });
    }
  }
  return cmds;
}
function compileCommands(cmds) {
  return cmds.map((n, idx) => {
    if (n.type === "point") {
      return "".concat(idx === 0 ? "M" : "L", " ").concat(n.x, " ").concat(n.y);
    }
    if (n.type === "curve") {
      return "C ".concat(n.startControl.x, " ").concat(n.startControl.y, " ").concat(n.endControl.x, " ").concat(n.endControl.y, " ").concat(n.curveEnd.x, " ").concat(n.curveEnd.y);
    }
    return "";
  }).join(" ");
}
var __freeze$p = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$p = (cooked, raw) => __freeze$p(__defProp$q(cooked, "raw", {
  value: __freeze$p(raw || cooked.slice())
}));
var _a$p, _b$f, _c$7;
const Root$k = styled.div(_ref4 => {
  let {
    $w: w
  } = _ref4;
  return css(_a$p || (_a$p = __template$p(["\n    position: absolute;\n    width: ", "px;\n    height: ", "px;\n\n    :empty + & {\n      display: none;\n    }\n\n    & > svg {\n      display: block;\n      line-height: 0;\n      transform-origin: ", "px ", "px;\n    }\n\n    [data-placement^='top'] > & {\n      bottom: -", "px;\n\n      & > svg {\n        transform: rotate(0);\n      }\n    }\n\n    [data-placement^='right'] > & {\n      left: -", "px;\n\n      & > svg {\n        transform: rotate(90deg);\n      }\n    }\n\n    [data-placement^='left'] > & {\n      right: -", "px;\n\n      & > svg {\n        transform: rotate(-90deg);\n      }\n    }\n\n    [data-placement^='bottom'] > & {\n      top: -", "px;\n\n      & > svg {\n        transform: rotate(180deg);\n      }\n    }\n  "])), w, w, w / 2, w / 2, w, w, w, w);
});
const StrokePath = styled.path(_b$f || (_b$f = __template$p(["\n  stroke: var(--card-shadow-outline-color);\n"])));
const ShapePath = styled.path(_c$7 || (_c$7 = __template$p(["\n  fill: var(--card-bg-color);\n"])));
const Arrow = forwardRef(function Arrow2(props, ref) {
  const {
    width: w,
    height: h,
    radius = 0,
    ...restProps
  } = props;
  const {
    card
  } = useTheme_v2();
  const strokeWidth = card.shadow.outline;
  const center = w / 2;
  const points = [{
    x: 0,
    y: 0
  }, {
    x: radius,
    y: 0,
    radius
  }, {
    x: center,
    y: h - 1,
    radius
  }, {
    x: w - radius,
    y: 0,
    radius
  }, {
    x: w,
    y: 0
  }];
  const cmds = getRoundedCommands(points);
  const path = compileCommands(cmds);
  const strokePath = "".concat(path);
  const fillPath = "".concat(path, " M ").concat(w, " -1 M 0 -1 Z");
  return /* @__PURE__ */jsx(Root$k, {
    ...restProps,
    $w: w,
    ref,
    children: /* @__PURE__ */jsxs("svg", {
      width: w,
      height: w,
      viewBox: "0 0 ".concat(w, " ").concat(w),
      children: [/* @__PURE__ */jsx("mask", {
        id: "stroke-mask",
        children: /* @__PURE__ */jsx("rect", {
          x: 0,
          y: strokeWidth,
          width: w,
          height: w,
          fill: "white"
        })
      }), /* @__PURE__ */jsx(StrokePath, {
        d: strokePath,
        mask: "url(#stroke-mask)",
        strokeWidth: strokeWidth * 2
      }), /* @__PURE__ */jsx(ShapePath, {
        d: fillPath
      })]
    })
  });
});
const key$7 = Symbol.for("@sanity/ui/context/boundaryElement");
globalScope[key$7] = globalScope[key$7] || createContext(null);
const BoundaryElementContext = globalScope[key$7];
function BoundaryElementProvider(props) {
  const {
    children,
    element
  } = props;
  const value = useMemo(() => ({
    version: 0,
    element
  }), [element]);
  return /* @__PURE__ */jsx(BoundaryElementContext.Provider, {
    value,
    children
  });
}
function isRecord(value) {
  return Boolean(value && typeof value === "object" && !Array.isArray(value));
}
const DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = useContext(BoundaryElementContext);
  if (value && (!isRecord(value) || value.version !== 0)) {
    throw new Error("useBoundaryElement(): the context value is not compatible");
  }
  return value || DEFAULT_VALUE;
}
function ConditionalWrapper(_ref5) {
  let {
    children,
    condition,
    wrapper
  } = _ref5;
  if (!condition) {
    return children;
  }
  return wrapper(children);
}
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp > width) {
      ret.push(i);
    }
  }
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp <= width) {
      ret.push(i);
    }
  }
  return ret;
}
const ElementQuery = forwardRef(function ElementQuery2(props, ref) {
  const theme = useTheme_v2();
  const {
    children,
    media = theme.media,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [element, setElement] = useState(null);
  const elementSize = useElementSize(element);
  const width = useMemo(() => {
    var _a;
    return (_a = elementSize == null ? void 0 : elementSize.border.width) != null ? _a : window.innerWidth;
  }, [elementSize]);
  const max = useMemo(() => findMaxBreakpoints(media, width), [media, width]);
  const min = useMemo(() => findMinBreakpoints(media, width), [media, width]);
  const setRef = useCallback(el => {
    forwardedRef.current = el;
    setElement(el);
  }, [forwardedRef]);
  return /* @__PURE__ */jsx("div", {
    "data-ui": "ElementQuery",
    ...restProps,
    "data-eq-max": max.length ? max.join(" ") : void 0,
    "data-eq-min": min.length ? min.join(" ") : void 0,
    ref: setRef,
    children
  });
});
var __defProp$p = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$p(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ErrorBoundary extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      error: null
    });
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({
      error,
      info
    });
  }
  render() {
    const {
      error
    } = this.state;
    if (error) {
      const message = typeof (error == null ? void 0 : error.message) === "string" ? error.message : "Error";
      return /* @__PURE__ */jsx(Code, {
        children: message
      });
    }
    return this.props.children;
  }
}
function getLayerContext(contextValue) {
  if (!isRecord(contextValue) || contextValue.version !== 0) {
    throw new Error("the context value is not compatible");
  }
  if (!contextValue) {
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  }
  if (contextValue.version === 0) {
    return contextValue;
  }
  throw new Error("could not get layer context");
}
const key$6 = Symbol.for("@sanity/ui/context/layer");
globalScope[key$6] = globalScope[key$6] || createContext(null);
const LayerContext = globalScope[key$6];
function useLayer() {
  const value = useContext(LayerContext);
  if (!value) {
    throw new Error("useLayer(): missing context value");
  }
  try {
    return getLayerContext(value);
  } catch (err) {
    if (err instanceof Error) {
      throw new Error("useLayer(): ".concat(err.message));
    } else {
      throw new Error("useLayer(): ".concat(err));
    }
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    if (innerDispose) innerDispose();
    outerDispose();
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node) {
  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node) {
  return element.contains(node) || element === node;
}
function _hasFocus(element) {
  return Boolean(document.activeElement) && element.contains(document.activeElement);
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (isHTMLAnchorElement(element)) {
    return Boolean(element.href) && element.rel !== "ignore";
  }
  if (isHTMLInputElement(element)) {
    return element.type !== "hidden" && element.type !== "file" && !element.disabled;
  }
  if (isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element)) {
    return !element.disabled;
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus();
  } catch (_) {}
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child))) {
      return true;
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child))) {
      return true;
    }
  }
  return false;
}
function _isScrollable(el) {
  if (!(el instanceof Element)) return false;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function LayerProvider(props) {
  var _a;
  const {
    children,
    zOffset: zOffsetProp = 0
  } = props;
  const parentContextValue = useContext(LayerContext);
  const parent = parentContextValue && getLayerContext(parentContextValue);
  const parentRegisterChild = parent == null ? void 0 : parent.registerChild;
  const parentLevel = (_a = parent == null ? void 0 : parent.level) != null ? _a : 0;
  const level = parentLevel + 1;
  const zOffset = useArrayProp(zOffsetProp);
  const maxMediaIndex = zOffset.length - 1;
  const mediaIndex = Math.min(useMediaIndex(), maxMediaIndex);
  const zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex];
  const [, setChildLayers] = useState({});
  const [size, setSize] = useState(0);
  const isTopLayer = size === 0;
  const registerChild = useCallback(childLevel => {
    const parentDispose = parentRegisterChild == null ? void 0 : parentRegisterChild(childLevel);
    if (childLevel !== void 0) {
      setChildLayers(state => {
        var _a2;
        const prevLen = (_a2 = state[childLevel]) != null ? _a2 : 0;
        const nextState = {
          ...state,
          [childLevel]: prevLen + 1
        };
        setSize(Object.keys(nextState).length);
        return nextState;
      });
    } else {
      setSize(v => v + 1);
    }
    return () => {
      if (childLevel !== void 0) {
        setChildLayers(state => {
          const nextState = {
            ...state
          };
          if (nextState[childLevel] === 1) {
            delete nextState[childLevel];
            setSize(Object.keys(nextState).length);
          } else {
            nextState[childLevel] -= 1;
          }
          return nextState;
        });
      } else {
        setSize(v => v - 1);
      }
      parentDispose == null ? void 0 : parentDispose();
    };
  }, [parentRegisterChild]);
  useEffect(() => parentRegisterChild == null ? void 0 : parentRegisterChild(level), [level, parentRegisterChild]);
  const value = useMemo(() => ({
    version: 0,
    isTopLayer,
    level,
    registerChild,
    size,
    zIndex
  }), [isTopLayer, level, registerChild, size, zIndex]);
  return /* @__PURE__ */jsx(LayerContext.Provider, {
    value,
    children
  });
}
const Root$j = styled.div({
  position: "relative"
});
const LayerChildren = forwardRef(function LayerChildren2(props, ref) {
  const {
    children,
    onActivate,
    onFocus,
    style = EMPTY_RECORD,
    ...restProps
  } = props;
  const {
    zIndex,
    isTopLayer
  } = useLayer();
  const lastFocusedRef = useRef(null);
  const forwardedRef = useForwardedRef(ref);
  const isTopLayerRef = useRef(isTopLayer);
  useEffect(() => {
    const becameTopLayer = isTopLayerRef.current !== isTopLayer && isTopLayer;
    if (becameTopLayer) {
      onActivate == null ? void 0 : onActivate({
        activeElement: lastFocusedRef.current
      });
    }
    isTopLayerRef.current = isTopLayer;
  }, [isTopLayer, onActivate]);
  const handleFocus = useCallback(event => {
    onFocus == null ? void 0 : onFocus(event);
    const rootElement = forwardedRef.current;
    const target = document.activeElement;
    if (!isTopLayer || !rootElement || !target) return;
    if (isHTMLElement(target) && containsOrEqualsElement(rootElement, target)) {
      lastFocusedRef.current = target;
    }
  }, [forwardedRef, isTopLayer, onFocus]);
  return /* @__PURE__ */jsx(Root$j, {
    ...restProps,
    "data-ui": "Layer",
    onFocus: handleFocus,
    ref: forwardedRef,
    style: {
      ...style,
      zIndex
    },
    children
  });
});
const Layer = forwardRef(function Layer2(props, ref) {
  const {
    children,
    zOffset = 1,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(LayerProvider, {
    zOffset,
    children: /* @__PURE__ */jsx(LayerChildren, {
      ...restProps,
      ref,
      children
    })
  });
});
const key$5 = Symbol.for("@sanity/ui/context/portal");
const elementKey = Symbol.for("@sanity/ui/context/portal/element");
globalScope[elementKey] = null;
const defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    if (typeof document === "undefined") {
      return null;
    }
    if (globalScope[elementKey]) {
      return globalScope[elementKey];
    }
    globalScope[elementKey] = document.createElement("div");
    globalScope[elementKey].setAttribute("data-portal", "");
    document.body.appendChild(globalScope[elementKey]);
    return globalScope[elementKey];
  }
};
globalScope[key$5] = globalScope[key$5] || createContext(defaultContextValue);
const PortalContext = globalScope[key$5];
function usePortal() {
  const value = useContext(PortalContext);
  if (!value) {
    throw new Error("usePortal(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("usePortal(): the context value is not compatible");
  }
  return value;
}
function Portal(props) {
  var _a;
  const {
    children,
    __unstable_name: name
  } = props;
  const portal = usePortal();
  const portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || ((_a = portal.elements) == null ? void 0 : _a.default);
  if (!portalElement) {
    return null;
  }
  return createPortal(children, portalElement);
}
function useUnique(value) {
  const valueRef = useRef(value);
  if (!_isEqual(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
function _isEqual(objA, objB) {
  if (!objA || !objB) {
    return objA === objB;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every(key => objA[key] === objB[key]);
}
const __BROWSER__ = typeof document !== "undefined";
function PortalProvider(props) {
  const {
    boundaryElement,
    children,
    element,
    __unstable_elements: elementsProp
  } = props;
  const elements = useUnique(elementsProp);
  const value = useMemo(() => {
    return {
      version: 0,
      boundaryElement: boundaryElement || null,
      element: element || __BROWSER__ && document.body || null,
      elements
    };
  }, [boundaryElement, element, elements]);
  return /* @__PURE__ */jsx(PortalContext.Provider, {
    value,
    children
  });
}
var __freeze$o = Object.freeze;
var __defProp$o = Object.defineProperty;
var __template$o = (cooked, raw) => __freeze$o(__defProp$o(cooked, "raw", {
  value: __freeze$o(raw || cooked.slice())
}));
var _a$o;
const Root$i = styled.div(_a$o || (_a$o = __template$o(["\n  display: block;\n  width: 0;\n  height: 0;\n  position: absolute;\n  overflow: hidden;\n  overflow: clip;\n"])));
const SrOnly = forwardRef(function SrOnly2(props, ref) {
  const {
    as,
    children
  } = props;
  return /* @__PURE__ */jsx(Root$i, {
    "aria-hidden": true,
    as,
    "data-ui": "SrOnly",
    ref,
    children
  });
});
var __freeze$n = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$n = (cooked, raw) => __freeze$n(__defProp$n(cooked, "raw", {
  value: __freeze$n(raw || cooked.slice())
}));
var _a$n, _b$e;
const Root$h = styled.div(_a$n || (_a$n = __template$n(["\n  position: relative;\n"])));
const ItemWrapper = styled.div(_b$e || (_b$e = __template$n(["\n  position: absolute;\n  left: 0;\n  right: 0;\n"])));
const VirtualList = forwardRef(function VirtualList2(props, ref) {
  const {
    as = "div",
    gap = 0,
    getItemKey,
    items = [],
    onChange,
    renderItem,
    ...restProps
  } = props;
  const {
    space
  } = useTheme_v2();
  const forwardedRef = useForwardedRef(ref);
  const wrapperRef = useRef(null);
  const [scrollTop, setScrollTop] = useState(0);
  const [scrollHeight, setScrollHeight] = useState(0);
  const [itemHeight, setItemHeight] = useState(-1);
  useEffect(() => {
    if (!wrapperRef.current) return;
    const firstElement = wrapperRef.current.firstChild;
    if (firstElement instanceof HTMLElement) {
      setItemHeight(firstElement.offsetHeight);
    }
  }, [renderItem]);
  useEffect(() => {
    if (!forwardedRef.current) return;
    let _scrollEl = forwardedRef.current.parentNode;
    while (_scrollEl && !_isScrollable(_scrollEl)) {
      _scrollEl = _scrollEl.parentNode;
    }
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement)) return;
      const handleScroll2 = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll2, {
        passive: true
      });
      const ro = new _ResizeObserver(entries => {
        setScrollHeight(entries[0].contentRect.height);
      });
      ro.observe(scrollEl);
      handleScroll2();
      return () => {
        scrollEl.removeEventListener("scroll", handleScroll2);
        ro.unobserve(scrollEl);
        ro.disconnect();
      };
    }
    const handleScroll = () => {
      setScrollTop(window.scrollY);
    };
    const handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    window.addEventListener("scroll", handleScroll, {
      passive: true
    });
    window.addEventListener("resize", handleResize);
    setScrollHeight(window.innerHeight);
    handleScroll();
    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [forwardedRef]);
  const len = items.length;
  const height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0;
  const fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0;
  const toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  useEffect(() => {
    if (!onChange) return;
    onChange({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex]);
  const children = useMemo(() => {
    if (!renderItem || items.length === 0) return null;
    if (itemHeight === -1) {
      return [/* @__PURE__ */jsx(ItemWrapper, {
        children: renderItem(items[0])
      }, 0)];
    }
    return items.slice(fromIndex, toIndex).map((item, _itemIndex) => {
      const itemIndex = fromIndex + _itemIndex;
      const node = renderItem(item);
      const key = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
      return /* @__PURE__ */jsx(ItemWrapper, {
        style: {
          top: itemIndex * (itemHeight + space[gap])
        },
        children: node
      }, key);
    });
  }, [fromIndex, gap, getItemKey, itemHeight, items, renderItem, space, toIndex]);
  const wrapperStyle = useMemo(() => ({
    height
  }), [height]);
  return /* @__PURE__ */jsx(Root$h, {
    as,
    "data-ui": "VirtualList",
    ...restProps,
    ref: forwardedRef,
    children: /* @__PURE__ */jsx("div", {
      ref: wrapperRef,
      style: wrapperStyle,
      children
    })
  });
});
const DEFAULT_POPOVER_DISTANCE = 4;
const DEFAULT_POPOVER_PADDING = 4;
const DEFAULT_POPOVER_ARROW_WIDTH = 19;
const DEFAULT_POPOVER_ARROW_HEIGHT = 8;
const DEFAULT_POPOVER_ARROW_RADIUS = 2;
const DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0];
const DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size(options) {
  const {
    apply,
    margins,
    padding = 0
  } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform,
        rects
      } = args;
      const {
        floating,
        reference
      } = rects;
      const overflow = await detectOverflow(args, {
        altBoundary: true,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = Infinity;
      let maxHeight = Infinity;
      const floatingW = floating.width;
      const floatingH = floating.height;
      if (placement.includes("top")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.top;
      }
      if (placement.includes("right")) {
        maxWidth = floatingW - overflow.right;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      if (placement.includes("bottom")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.bottom;
      }
      if (placement.includes("left")) {
        maxWidth = floatingW - overflow.left;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      const targetH = nextDimensions.height;
      const targetW = nextDimensions.width;
      if (floatingW !== targetW || floatingH !== targetH) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
}
function calcCurrentWidth(params) {
  const {
    container,
    mediaIndex,
    width
  } = params;
  const w = width[mediaIndex];
  const currentWidth = w === void 0 ? width[width.length - 1] : w;
  return typeof currentWidth === "number" ? container[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const {
    boundaryWidth,
    currentWidth
  } = params;
  if (currentWidth === void 0 && boundaryWidth === void 0) {
    return void 0;
  }
  return Math.min(currentWidth != null ? currentWidth : Infinity, (boundaryWidth || Infinity) - DEFAULT_POPOVER_PADDING * 2);
}
var __freeze$m = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$m = (cooked, raw) => __freeze$m(__defProp$m(cooked, "raw", {
  value: __freeze$m(raw || cooked.slice())
}));
var _a$m;
const MotionCard$1 = styled(motion(Card))(_a$m || (_a$m = __template$m(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  flex-direction: column;\n  width: max-content;\n  min-width: min-content;\n  & > * {\n    opacity: var(", ", 1);\n    will-change: opacity;\n  }\n"])), POPOVER_MOTION_CONTENT_OPACITY_PROPERTY);
const PopoverCard = memo(forwardRef(function PopoverCard2(props, ref) {
  const {
    __unstable_margins: marginsProp,
    animate,
    arrow,
    arrowRef,
    arrowX,
    arrowY,
    children,
    padding,
    placement,
    originX,
    originY,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width,
    x: xProp,
    y: yProp,
    ...restProps
  } = props;
  const {
    zIndex
  } = useLayer();
  const margins = useMemo(() => marginsProp || DEFAULT_POPOVER_MARGINS, [marginsProp]);
  const x = (xProp != null ? xProp : 0) + margins[3];
  const y = (yProp != null ? yProp : 0) + margins[0];
  const rootStyle = useMemo(() => ({
    left: x,
    originX,
    originY,
    position: strategy,
    top: y,
    width,
    zIndex,
    willChange: animate ? "transform" : void 0,
    ...style
  }), [animate, originX, originY, strategy, style, width, x, y, zIndex]);
  const arrowStyle = useMemo(() => ({
    left: arrowX !== null ? arrowX : void 0,
    top: arrowY !== null ? arrowY : void 0,
    right: void 0,
    bottom: void 0
  }), [arrowX, arrowY]);
  return /* @__PURE__ */jsxs(MotionCard$1, {
    "data-ui": "Popover",
    ...restProps,
    "data-placement": placement,
    radius,
    ref,
    scheme,
    shadow,
    sizing: "border",
    style: rootStyle,
    tone,
    ...(animate ? POPOVER_MOTION_PROPS : {}),
    children: [/* @__PURE__ */jsx(Flex, {
      "data-ui": "Popover__wrapper",
      direction: "column",
      flex: 1,
      overflow,
      children: /* @__PURE__ */jsx(Flex, {
        direction: "column",
        flex: 1,
        padding,
        children
      })
    }), arrow && /* @__PURE__ */jsx(Arrow, {
      ref: arrowRef,
      style: arrowStyle,
      width: DEFAULT_POPOVER_ARROW_WIDTH,
      height: DEFAULT_POPOVER_ARROW_HEIGHT,
      radius: DEFAULT_POPOVER_ARROW_RADIUS
    })]
  });
}));
PopoverCard.displayName = "PopoverCard";
const Popover = memo(forwardRef(function Popover2(props, ref) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const {
    container,
    layer
  } = useTheme_v2();
  const boundaryElementContext = useBoundaryElement();
  const {
    __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
    animate = false,
    arrow: arrowProp = false,
    boundaryElement = boundaryElementContext.element,
    children: childProp,
    constrainSize = false,
    content,
    disabled,
    fallbackPlacements = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS$1[(_a = props.placement) != null ? _a : "bottom"],
    matchReferenceWidth,
    floatingBoundary = (_c = props.boundaryElement) != null ? _c : boundaryElementContext.element,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onActivate,
    open,
    overflow = "hidden",
    padding: paddingProp,
    placement: placementProp = "bottom",
    portal,
    preventOverflow = true,
    radius: radiusProp = 3,
    referenceBoundary = (_d = props.boundaryElement) != null ? _d : boundaryElementContext.element,
    referenceElement,
    scheme,
    shadow: shadowProp = 3,
    tone = "inherit",
    width: widthProp = "auto",
    zOffset: zOffsetProp = layer.popover.zOffset,
    updateRef,
    ...restProps
  } = props;
  const boundarySize = (_e = useElementSize(boundaryElement)) == null ? void 0 : _e.border;
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const widthArrayProp = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const forwardedRef = useForwardedRef(ref);
  const arrowRef = useRef(null);
  const rootBoundary = "viewport";
  const mediaIndex = useMediaIndex();
  const boundaryWidth = constrainSize || preventOverflow ? boundarySize == null ? void 0 : boundarySize.width : void 0;
  const width = calcCurrentWidth({
    container,
    mediaIndex,
    width: widthArrayProp
  });
  const widthRef = useRef(width);
  useEffect(() => {
    widthRef.current = width;
  }, [width]);
  const maxWidth = calcMaxWidth({
    boundaryWidth,
    currentWidth: width
  });
  const maxWidthRef = useRef(maxWidth);
  useEffect(() => {
    maxWidthRef.current = maxWidth;
  }, [maxWidth]);
  const referenceWidthRef = useRef();
  useEffect(() => {
    const floatingElement = forwardedRef.current;
    if (!open || !floatingElement) return;
    const referenceWidth = referenceWidthRef.current;
    if (matchReferenceWidth) {
      if (referenceWidth !== void 0) {
        floatingElement.style.width = "".concat(referenceWidth, "px");
      }
    } else if (width !== void 0) {
      floatingElement.style.width = "".concat(width, "px");
    }
    if (typeof maxWidth === "number") {
      floatingElement.style.maxWidth = "".concat(maxWidth, "px");
    }
  }, [width, forwardedRef, matchReferenceWidth, maxWidth, open]);
  const middleware = useMemo(() => {
    const ret = [];
    if (constrainSize || preventOverflow) {
      ret.push(flip({
        boundary: floatingBoundary || void 0,
        fallbackPlacements,
        padding: DEFAULT_POPOVER_PADDING,
        rootBoundary
      }));
    }
    ret.push(offset({
      mainAxis: DEFAULT_POPOVER_DISTANCE
    }));
    if (constrainSize || matchReferenceWidth) {
      ret.push(size({
        apply(_ref6) {
          let {
            availableWidth,
            availableHeight,
            elements,
            referenceWidth
          } = _ref6;
          referenceWidthRef.current = referenceWidth;
          const _currentWidth = widthRef.current;
          const _maxWidth = maxWidthRef.current;
          if (matchReferenceWidth) {
            elements.floating.style.width = "".concat(referenceWidth, "px");
          } else if (_currentWidth !== void 0) {
            elements.floating.style.width = "".concat(_currentWidth, "px");
          }
          if (constrainSize) {
            elements.floating.style.maxWidth = "".concat(Math.min(availableWidth, _maxWidth != null ? _maxWidth : Infinity), "px");
            elements.floating.style.maxHeight = "".concat(availableHeight, "px");
          }
        },
        boundaryElement: floatingBoundary || void 0,
        constrainSize,
        margins,
        matchReferenceWidth,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (preventOverflow) {
      ret.push(shift({
        boundary: floatingBoundary || void 0,
        rootBoundary,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (arrowProp) {
      ret.push(arrow({
        element: arrowRef,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (animate) {
      ret.push(origin);
    }
    ret.push(hide({
      boundary: referenceBoundary || void 0,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    }));
    return ret;
  }, [animate, arrowProp, constrainSize, fallbackPlacements, floatingBoundary, margins, matchReferenceWidth, preventOverflow, referenceBoundary]);
  const {
    x,
    y,
    middlewareData,
    placement,
    refs,
    strategy,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  });
  const referenceHidden = (_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden;
  const arrowX = (_g = middlewareData.arrow) == null ? void 0 : _g.x;
  const arrowY = (_h = middlewareData.arrow) == null ? void 0 : _h.y;
  const originX = (_i = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _i.originX;
  const originY = (_j = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _j.originY;
  const setArrow = useCallback(arrowEl => {
    arrowRef.current = arrowEl;
  }, []);
  const setFloating = useCallback(node => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const setReference = useCallback(node => {
    refs.setReference(node);
    const childRef = childProp == null ? void 0 : childProp.ref;
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
  }, [childProp, refs]);
  const child = useMemo(() => {
    if (!childProp || referenceElement) return null;
    return cloneElement(childProp, {
      ref: setReference
    });
  }, [childProp, referenceElement, setReference]);
  useEffect(() => {
    if (updateRef) {
      if (typeof updateRef === "function") {
        updateRef(update);
      } else if (updateRef) {
        updateRef.current = update;
      }
    }
  }, [update, updateRef]);
  useEffect(() => {
    if (child) return;
    refs.setReference(referenceElement || null);
  }, [referenceElement, refs, child]);
  if (disabled) {
    return childProp || /* @__PURE__ */jsx(Fragment, {});
  }
  const popover = /* @__PURE__ */jsx(LayerProvider, {
    zOffset,
    children: /* @__PURE__ */jsx(PopoverCard, {
      ...restProps,
      __unstable_margins: margins,
      animate,
      arrow: arrowProp,
      arrowRef: setArrow,
      arrowX,
      arrowY,
      hidden: referenceHidden,
      overflow,
      padding,
      placement,
      radius,
      ref: setFloating,
      scheme,
      shadow,
      originX,
      originY,
      strategy,
      tone,
      width: matchReferenceWidth ? referenceWidthRef.current : width,
      x,
      y,
      children: content
    })
  });
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx(ConditionalWrapper, {
      condition: animate,
      wrapper: children => /* @__PURE__ */jsx(AnimatePresence, {
        children
      }),
      children: open && /* @__PURE__ */jsx(ConditionalWrapper, {
        condition: !!portal,
        wrapper: children => /* @__PURE__ */jsx(Portal, {
          __unstable_name: typeof portal === "string" ? portal : void 0,
          children
        }),
        children: popover
      })
    }), child]
  });
}));
Popover.displayName = "Popover";
var __freeze$l = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$l = (cooked, raw) => __freeze$l(__defProp$l(cooked, "raw", {
  value: __freeze$l(raw || cooked.slice())
}));
var _a$l, _b$d;
function radioBaseStyle() {
  return css(_a$l || (_a$l = __template$l(["\n    position: relative;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n\n    &[data-read-only] {\n      outline: 1px solid red;\n    }\n  "])));
}
function inputElementStyle(props) {
  const {
    color,
    input
  } = getTheme_v2(props.theme);
  const dist = (input.radio.size - input.radio.markSize) / 2;
  return css(_b$d || (_b$d = __template$l(["\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n    border-radius: ", ";\n    border: none;\n\n    /* enabled */\n    & + span {\n      display: block;\n      position: relative;\n      height: ", ";\n      width: ", ";\n      border-radius: ", ";\n      background: ", ";\n      box-shadow: ", ";\n\n      &::after {\n        content: '';\n        position: absolute;\n        top: ", ";\n        left: ", ";\n        height: ", ";\n        width: ", ";\n        border-radius: ", ";\n        background: ", ";\n        opacity: 0;\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span::after {\n      opacity: 1;\n    }\n\n    /* customValidity */\n    &[data-error] + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      &::after {\n        background: ", ";\n      }\n    }\n\n    /* read only */\n    &[data-read-only] + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n  "])), rem(input.radio.size / 2), rem(input.radio.size), rem(input.radio.size), rem(input.radio.size / 2), color.input.default.enabled.bg, focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  }), rem(dist), rem(dist), rem(input.radio.markSize), rem(input.radio.markSize), rem(input.radio.markSize / 2), color.input.default.enabled.fg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color.input.default.enabled.border
    },
    focusRing: input.radio.focusRing
  }), focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  }), color.input.invalid.enabled.border, focusRingBorderStyle({
    width: input.border.width,
    color: color.input.invalid.enabled.muted.bg
  }), color.input.invalid.enabled.muted.bg, color.input.default.readOnly.border, color.input.default.readOnly.bg, color.input.default.readOnly.border, color.input.default.disabled.border, color.input.default.disabled.bg, color.input.default.disabled.border);
}
const Root$g = styled.div(radioBaseStyle);
const Input$4 = styled.input(inputElementStyle);
const Radio = forwardRef(function Radio2(props, forwardedRef) {
  const {
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsxs(Root$g, {
    className,
    "data-ui": "Radio",
    style,
    children: [/* @__PURE__ */jsx(Input$4, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      "data-error": customValidity ? "" : void 0,
      ...restProps,
      disabled: disabled || readOnly,
      readOnly,
      ref,
      type: "radio"
    }), /* @__PURE__ */jsx("span", {})]
  });
});
var __freeze$k = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$k = (cooked, raw) => __freeze$k(__defProp$k(cooked, "raw", {
  value: __freeze$k(raw || cooked.slice())
}));
var _a$k, _b$c, _c$6, _d$5;
function rootStyle() {
  return css(_a$k || (_a$k = __template$k(["\n    position: relative;\n    width: -moz-available;\n    width: -webkit-fill-available;\n    width: stretch;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function inputBaseStyle(props) {
  const {
    font
  } = getTheme_v2(props.theme);
  return css(_b$c || (_b$c = __template$k(["\n    -webkit-font-smoothing: antialiased;\n    appearance: none;\n    border: 0;\n    font-family: ", ";\n    color: inherit;\n    width: 100%;\n    outline: none;\n    margin: 0;\n\n    &:disabled {\n      opacity: 1;\n    }\n  "])), font.text.family);
}
function inputColorStyle(props) {
  const {
    color,
    input
  } = getTheme_v2(props.theme);
  return css(_c$6 || (_c$6 = __template$k(["\n    /* enabled */\n    background-color: ", ";\n    color: ", ";\n    box-shadow: ", ";\n\n    /* hovered */\n    @media (hover: hover) {\n      &:not(:disabled):hover {\n        background-color: ", ";\n        color: ", ";\n        box-shadow: ", ";\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus {\n      box-shadow: ", ";\n    }\n\n    /* read-only */\n    &[data-read-only] {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n  "])), color.input.default.enabled.bg, color.input.default.enabled.fg, focusRingBorderStyle({
    color: color.input.default.enabled.border,
    width: input.border.width
  }), color.input.default.hovered.bg, color.input.default.hovered.fg, focusRingBorderStyle({
    color: color.input.default.hovered.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      width: input.border.width,
      color: color.input.default.enabled.border
    },
    focusRing: input.select.focusRing
  }), color.input.default.readOnly.bg, color.input.default.readOnly.fg, focusRingBorderStyle({
    color: color.input.default.readOnly.border,
    width: input.border.width
  }), color.input.default.disabled.bg, color.input.default.disabled.fg, focusRingBorderStyle({
    color: color.input.default.disabled.border,
    width: input.border.width
  }));
}
function textSize(size) {
  return {
    fontSize: rem(size.fontSize),
    lineHeight: rem(size.lineHeight)
  };
}
function inputTextSizeStyle(props) {
  const {
    $fontSize
  } = props;
  const {
    font,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, $fontSize, sizeIndex => textSize(font.text.sizes[sizeIndex] || font.text.sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props) {
  const {
    color
  } = getTheme_v2(props.theme);
  return css(_d$5 || (_d$5 = __template$k(["\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n\n    /* enabled */\n    --card-fg-color: ", ";\n\n    /* hover */\n    @media (hover: hover) {\n      select:not(disabled):not(:read-only):hover + && {\n        --card-fg-color: ", ";\n      }\n    }\n\n    /* disabled */\n    select:disabled + && {\n      --card-fg-color: ", ";\n    }\n\n    /* read-only */\n    select[data-read-only] + && {\n      --card-fg-color: ", ";\n    }\n  "])), color.input.default.enabled.fg, color.input.default.hovered.fg, color.input.default.disabled.fg, color.input.default.readOnly.fg);
}
const selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
};
const Root$f = styled.div(selectStyle.root);
const Input$3 = styled.select(selectStyle.input);
const IconBox = styled(Box)(selectStyle.iconBox);
const Select = forwardRef(function Select2(props, forwardedRef) {
  const {
    children,
    customValidity,
    disabled,
    fontSize = 2,
    padding = 3,
    radius = 2,
    readOnly,
    space = 3,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsxs(Root$f, {
    "data-ui": "Select",
    children: [/* @__PURE__ */jsx(Input$3, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      "data-ui": "Select",
      ...restProps,
      $fontSize: useArrayProp(fontSize),
      $padding: useArrayProp(padding),
      $radius: useArrayProp(radius),
      $space: useArrayProp(space),
      disabled: disabled || readOnly,
      ref,
      children
    }), /* @__PURE__ */jsx(IconBox, {
      padding,
      children: /* @__PURE__ */jsx(Text, {
        size: fontSize,
        children: /* @__PURE__ */jsx(ChevronDownIcon, {})
      })
    })]
  });
});
const BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, spaceIndex => ({
    gridGap: rem(space[spaceIndex])
  }));
}
const Root$e = styled(Box)(stackBaseStyle, responsiveStackSpaceStyle);
const Stack = forwardRef(function Stack2(props, ref) {
  const {
    as,
    space,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$e, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Stack",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref
  });
});
var __freeze$j = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$j = (cooked, raw) => __freeze$j(__defProp$j(cooked, "raw", {
  value: __freeze$j(raw || cooked.slice())
}));
var _a$j, _b$b, _c$5, _d$4, _e$2, _f$2, _g;
function switchBaseStyles() {
  return css(_a$j || (_a$j = __template$j(["\n    position: relative;\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function switchInputStyles() {
  return css(_b$b || (_b$b = __template$j(["\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    padding: 0;\n    margin: 0;\n\n    /* Place the input element above the representation element */\n    z-index: 1;\n  "])));
}
function switchRepresentationStyles(props) {
  const {
    color,
    input
  } = getTheme_v2(props.theme);
  return css(_c$5 || (_c$5 = __template$j(["\n    --switch-bg-color: ", ";\n    --switch-fg-color: ", ";\n    --switch-box-shadow: none;\n\n    &:not([hidden]) {\n      display: block;\n    }\n    position: relative;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n\n    /* Make sure it\u2019s not possible to interact with the wrapper element */\n    pointer-events: none;\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      z-index: 1;\n      box-shadow: var(--switch-box-shadow);\n      border-radius: inherit;\n    }\n\n    /* Focus styles */\n    input:focus + && {\n      --switch-box-shadow: ", ";\n    }\n\n    input:focus:not(:focus-visible) + && {\n      --switch-box-shadow: none;\n    }\n\n    input:checked + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n\n    @media (hover: hover) {\n      input:not(:disabled):hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n\n      input:not(:disabled):checked:hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n    }\n\n    input:not([data-read-only]):disabled + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n\n    input[data-read-only]:disabled + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n\n    input:checked[data-read-only]:disabled + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n  "])), color.input.default.enabled.border, color.input.default.enabled.bg, rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2), focusRingStyle({
    focusRing: input.switch.focusRing
  }), color.input.default.enabled.fg, color.input.default.enabled.bg, color.input.default.hovered.border, color.input.default.hovered.bg, color.input.default.enabled.fg, color.input.default.enabled.bg, color.input.default.disabled.border, color.input.default.disabled.bg, color.input.default.readOnly.border, color.input.default.readOnly.bg, color.input.default.readOnly.fg, color.input.default.readOnly.bg);
}
function switchTrackStyles(props) {
  const {
    input
  } = getTheme_v2(props.theme);
  return css(_d$4 || (_d$4 = __template$j(["\n    &:not([hidden]) {\n      display: block;\n    }\n    background-color: var(--switch-bg-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n  "])), rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2));
}
function switchThumbStyles(props) {
  const {
    $indeterminate
  } = props;
  const {
    input
  } = getTheme_v2(props.theme);
  const trackWidth = input.switch.width;
  const trackHeight = input.switch.height;
  const trackPadding = input.switch.padding;
  const size = trackHeight - input.switch.padding * 2;
  const checkedOffset = trackWidth - trackPadding * 2 - size;
  const indeterminateOffset = trackWidth / 2 - size / 2 - trackPadding;
  const checked = $indeterminate !== true && props.$checked === true;
  return css(_g || (_g = __template$j(["\n    &:not([hidden]) {\n      display: block;\n    }\n    position: absolute;\n    left: ", ";\n    top: ", ";\n    height: ", ";\n    width: ", ";\n    border-radius: ", ";\n    transition-property: transform;\n    transition-duration: ", "ms;\n    transition-timing-function: ", ";\n    background: var(--switch-fg-color);\n    transform: translate3d(0, 0, 0);\n    box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.05);\n\n    ", "\n\n    ", "\n  "])), rem(trackPadding), rem(trackPadding), rem(size), rem(size), rem(size / 2), input.switch.transitionDurationMs, input.switch.transitionTimingFunction, checked && css(_e$2 || (_e$2 = __template$j(["\n      transform: translate3d(", "px, 0, 0);\n    "])), checkedOffset), $indeterminate && css(_f$2 || (_f$2 = __template$j(["\n      transform: translate3d(", "px, 0, 0);\n    "])), indeterminateOffset));
}
const Root$d = styled.span(switchBaseStyles);
const Input$2 = styled.input(switchInputStyles);
const Representation = styled.span(switchRepresentationStyles);
const Track = styled.span(switchTrackStyles);
const Thumb = styled.span(switchThumbStyles);
const Switch = forwardRef(function Switch2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useEffect(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return /* @__PURE__ */jsxs(Root$d, {
    className,
    "data-ui": "Switch",
    style,
    children: [/* @__PURE__ */jsx(Input$2, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked: indeterminate !== true && checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      ref
    }), /* @__PURE__ */jsxs(Representation, {
      "aria-hidden": true,
      "data-name": "representation",
      children: [/* @__PURE__ */jsx(Track, {}), /* @__PURE__ */jsx(Thumb, {
        $checked: checked,
        $indeterminate: indeterminate
      })]
    })]
  });
});
var __freeze$i = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$i = (cooked, raw) => __freeze$i(__defProp$i(cooked, "raw", {
  value: __freeze$i(raw || cooked.slice())
}));
var _a$i;
const Root$c = styled.span(textInputRootStyle);
const InputRoot$1 = styled.span(_a$i || (_a$i = __template$i(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
const Input$1 = styled.textarea(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
const Presentation$1 = styled.div(responsiveRadiusStyle, textInputRepresentationStyle);
const TextArea = forwardRef(function TextArea2(props, forwardedRef) {
  const {
    border = true,
    customValidity,
    disabled = false,
    fontSize = 2,
    padding = 3,
    radius = 2,
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsx(Root$c, {
    "data-ui": "TextArea",
    children: /* @__PURE__ */jsxs(InputRoot$1, {
      children: [/* @__PURE__ */jsx(Input$1, {
        "data-as": "textarea",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: useArrayProp(fontSize),
        $padding: useArrayProp(padding),
        $scheme: rootTheme.scheme,
        $space: useArrayProp(0),
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        ref
      }), /* @__PURE__ */jsx(Presentation$1, {
        $radius: useArrayProp(radius),
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone
      })]
    })
  });
});
var __freeze$h = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$h = (cooked, raw) => __freeze$h(__defProp$h(cooked, "raw", {
  value: __freeze$h(raw || cooked.slice())
}));
var _a$h, _b$a, _c$4, _d$3, _e$1, _f$1;
const CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
};
const Root$b = styled(Card).attrs({
  forwardedAs: "span"
})(textInputRootStyle);
const InputRoot = styled.span(_a$h || (_a$h = __template$h(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
const Prefix = styled(Card).attrs({
  forwardedAs: "span"
})(_b$a || (_b$a = __template$h(["\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
const Suffix = styled(Card).attrs({
  forwardedAs: "span"
})(_c$4 || (_c$4 = __template$h(["\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
const Input = styled.input(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
const Presentation = styled.span(responsiveRadiusStyle, textInputRepresentationStyle);
const LeftBox = styled(Box)(_d$3 || (_d$3 = __template$h(["\n  position: absolute;\n  top: 0;\n  left: 0;\n"])));
const RightBox = styled(Box)(_e$1 || (_e$1 = __template$h(["\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
const RightCard = styled(Card)(_f$1 || (_f$1 = __template$h(["\n  background-color: transparent;\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
const TextInputClearButton = styled(Button)({
  "&:not([hidden])": {
    display: "block"
  }
});
const TextInput = forwardRef(function TextInput2(props, forwardedRef) {
  const {
    __unstable_disableFocusRing,
    border = true,
    clearButton,
    disabled = false,
    fontSize: fontSizeProp = 2,
    icon,
    iconRight,
    onClear,
    padding: paddingProp = 3,
    prefix,
    radius: radiusProp = 2,
    readOnly,
    space: spaceProp = 3,
    suffix,
    customValidity,
    type = "text",
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  const fontSize = useArrayProp(fontSizeProp);
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const $hasClearButton = Boolean(clearButton);
  const $hasIcon = Boolean(icon);
  const $hasIconRight = Boolean(iconRight);
  const $hasSuffix = Boolean(suffix);
  const $hasPrefix = Boolean(prefix);
  useCustomValidity(ref, customValidity);
  const handleClearMouseDown = useCallback(event => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleClearClick = useCallback(event => {
    var _a2;
    event.preventDefault();
    event.stopPropagation();
    if (onClear) onClear();
    (_a2 = ref.current) == null ? void 0 : _a2.focus();
  }, [onClear, ref]);
  const prefixNode = useMemo(() => prefix && /* @__PURE__ */jsx(Prefix, {
    borderTop: true,
    borderLeft: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: /* @__PURE__ */jsx("span", {
      children: prefix
    })
  }), [prefix, radius]);
  const presentationNode = useMemo(() => /* @__PURE__ */jsxs(Presentation, {
    $hasPrefix,
    $unstableDisableFocusRing: __unstable_disableFocusRing,
    $hasSuffix,
    $radius: radius,
    $scheme: rootTheme.scheme,
    $tone: rootTheme.tone,
    "data-border": border ? "" : void 0,
    "data-scheme": rootTheme.scheme,
    "data-tone": rootTheme.tone,
    children: [icon && /* @__PURE__ */jsx(LeftBox, {
      padding,
      children: /* @__PURE__ */jsxs(Text, {
        size: fontSize,
        children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
      })
    }), !$hasClearButton && iconRight && /* @__PURE__ */jsx(RightBox, {
      padding,
      children: /* @__PURE__ */jsxs(Text, {
        size: fontSize,
        children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
      })
    })]
  }), [__unstable_disableFocusRing, border, fontSize, icon, iconRight, padding, radius, rootTheme, $hasClearButton, $hasPrefix, $hasSuffix]);
  const clearButtonBoxPadding = useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 1;
    if (v === 2) return 1;
    return v - 2;
  }), [padding]);
  const clearButtonPadding = useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 0;
    if (v === 2) return 1;
    return v - 1;
  }), [padding]);
  const clearButtonProps = useMemo(() => typeof clearButton === "object" ? clearButton : EMPTY_RECORD, [clearButton]);
  const clearButtonNode = useMemo(() => !disabled && !readOnly && clearButton && /* @__PURE__ */jsx(RightCard, {
    forwardedAs: "span",
    padding: clearButtonBoxPadding,
    style: CLEAR_BUTTON_BOX_STYLE,
    tone: customValidity ? "critical" : "inherit",
    children: /* @__PURE__ */jsx(TextInputClearButton, {
      "aria-label": "Clear",
      "data-qa": "clear-button",
      fontSize,
      icon: CloseIcon,
      mode: "bleed",
      padding: clearButtonPadding,
      radius,
      ...clearButtonProps,
      onClick: handleClearClick,
      onMouseDown: handleClearMouseDown
    })
  }), [clearButton, clearButtonBoxPadding, clearButtonPadding, clearButtonProps, customValidity, disabled, fontSize, handleClearClick, handleClearMouseDown, radius, readOnly]);
  const suffixNode = useMemo(() => suffix && /* @__PURE__ */jsx(Suffix, {
    borderTop: true,
    borderRight: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: /* @__PURE__ */jsx("span", {
      children: suffix
    })
  }), [radius, suffix]);
  return /* @__PURE__ */jsxs(Root$b, {
    "data-ui": "TextInput",
    tone: rootTheme.tone,
    children: [prefixNode, /* @__PURE__ */jsxs(InputRoot, {
      children: [/* @__PURE__ */jsx(Input, {
        "data-as": "input",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: fontSize,
        $iconLeft: $hasIcon,
        $iconRight: $hasIconRight || $hasClearButton,
        $padding: padding,
        $scheme: rootTheme.scheme,
        $space: space,
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        readOnly,
        ref,
        type
      }), presentationNode, clearButtonNode]
    }), suffixNode]
  });
});
function useDelayedState(initialState) {
  const [state, setState] = useState(initialState);
  const delayedAction = useRef();
  const onStateChange = useCallback((nextState, delay) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current) {
      clearTimeout(delayedAction.current);
      delayedAction.current = void 0;
    }
    if (!delay) return action();
    delayedAction.current = setTimeout(action, delay);
  }, []);
  return [state, onStateChange];
}
const DEFAULT_TOOLTIP_ARROW_WIDTH = 15;
const DEFAULT_TOOLTIP_ARROW_HEIGHT = 6;
const DEFAULT_TOOLTIP_ARROW_RADIUS = 2;
const DEFAULT_TOOLTIP_DISTANCE = 4;
const DEFAULT_TOOLTIP_PADDING = 4;
const DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["top-end", "top-start", "bottom", "left", "right"],
  "top-start": ["top", "top-end", "bottom-start", "left-start", "right-start"],
  "top-end": ["top", "top-start", "bottom-end", "left-end", "right-end"],
  bottom: ["bottom-end", "bottom-start", "top", "left", "right"],
  "bottom-start": ["bottom", "bottom-end", "top-start", "left-start", "right-start"],
  "bottom-end": ["bottom", "bottom-start", "top-end", "left-end", "right-end"],
  left: ["left-end", "left-start", "right", "top", "bottom"],
  "left-start": ["left", "left-end", "right-start", "top-start", "bottom-start"],
  "left-end": ["left", "left-start", "right-end", "top-end", "bottom-end"],
  right: ["right-end", "right-start", "left", "top", "bottom"],
  "right-start": ["right", "right-end", "left-start", "top-start", "bottom-start"],
  "right-end": ["right", "right-start", "left-end", "top-end", "bottom-end"]
};
var __freeze$g = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$g = (cooked, raw) => __freeze$g(__defProp$g(cooked, "raw", {
  value: __freeze$g(raw || cooked.slice())
}));
var _a$g;
const MotionCard = styled(motion(Card))(_a$g || (_a$g = __template$g(["\n  & > * {\n    opacity: var(", ", 1);\n    will-change: opacity;\n  }\n"])), POPOVER_MOTION_CONTENT_OPACITY_PROPERTY);
const TooltipCard = memo(forwardRef(function TooltipCard2(props, ref) {
  const {
    animate,
    arrow,
    arrowRef,
    arrowX,
    arrowY,
    children,
    originX,
    originY,
    padding,
    placement,
    radius,
    scheme,
    shadow,
    style,
    ...restProps
  } = props;
  const rootStyle = useMemo(() => ({
    originX,
    originY,
    willChange: animate ? "transform" : void 0,
    ...style
  }), [animate, originX, originY, style]);
  const arrowStyle = useMemo(() => ({
    left: arrowX !== null ? arrowX : void 0,
    top: arrowY !== null ? arrowY : void 0,
    right: void 0,
    bottom: void 0
  }), [arrowX, arrowY]);
  return /* @__PURE__ */jsxs(MotionCard, {
    "data-ui": "Tooltip__card",
    ...restProps,
    "data-placement": placement,
    padding,
    radius,
    ref,
    scheme,
    shadow,
    style: rootStyle,
    ...(animate ? POPOVER_MOTION_PROPS : {}),
    children: [children, arrow && /* @__PURE__ */jsx(Arrow, {
      ref: arrowRef,
      style: arrowStyle,
      width: DEFAULT_TOOLTIP_ARROW_WIDTH,
      height: DEFAULT_TOOLTIP_ARROW_HEIGHT,
      radius: DEFAULT_TOOLTIP_ARROW_RADIUS
    })]
  });
}));
TooltipCard.displayName = "TooltipCard";
const key$4 = Symbol.for("@sanity/ui/context/tooltipDelayGroup");
globalScope[key$4] = globalScope[key$4] || createContext(null);
const TooltipDelayGroupContext = globalScope[key$4];
function useTooltipDelayGroup() {
  const value = useContext(TooltipDelayGroupContext);
  return value;
}
function TooltipDelayGroupProvider(props) {
  const {
    children,
    delay
  } = props;
  const [isGroupActive, setIsGroupActive] = useDelayedState(false);
  const [openTooltipId, setOpenTooltipId] = useDelayedState(null);
  const openDelay = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.open) || 0;
  const closeDelay = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.close) || 0;
  const value = useMemo(() => ({
    isGroupActive,
    setIsGroupActive,
    openTooltipId,
    setOpenTooltipId,
    // When the group is active, we want the next tooltip to open immediately.
    openDelay: isGroupActive ? 1 : openDelay,
    closeDelay
  }), [closeDelay, isGroupActive, openDelay, openTooltipId, setIsGroupActive, setOpenTooltipId]);
  return /* @__PURE__ */jsx(TooltipDelayGroupContext.Provider, {
    value,
    children
  });
}
var __freeze$f = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template$f = (cooked, raw) => __freeze$f(__defProp$f(cooked, "raw", {
  value: __freeze$f(raw || cooked.slice())
}));
var _a$f;
const Root$a = styled(Layer)(_a$f || (_a$f = __template$f(["\n  pointer-events: none;\n  max-width: ", "px;\n"])), _ref7 => {
  let {
    $maxWidth
  } = _ref7;
  return $maxWidth;
});
const Tooltip = forwardRef(function Tooltip2(props, ref) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const boundaryElementContext = useBoundaryElement();
  const {
    layer
  } = useTheme_v2();
  const {
    animate = false,
    arrow: arrowProp = false,
    boundaryElement = boundaryElementContext == null ? void 0 : boundaryElementContext.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS[(_a2 = props.placement) != null ? _a2 : "bottom"],
    padding = 2,
    placement: placementProp = "bottom",
    portal: portalProp,
    radius = 2,
    scheme,
    shadow = 2,
    zOffset = layer.tooltip.zOffset,
    delay,
    ...restProps
  } = props;
  const fallbackPlacements = useArrayProp(fallbackPlacementsProp);
  const forwardedRef = useForwardedRef(ref);
  const [referenceElement, setReferenceElement] = useState(null);
  const arrowRef = useRef(null);
  const rootBoundary = "viewport";
  const portal = usePortal();
  const portalElement = typeof portalProp === "string" ? ((_c = portal.elements) == null ? void 0 : _c[portalProp]) || null : portal.element;
  const tooltipWidth = useMemo(() => {
    const availableWidths = [...(boundaryElement ? [boundaryElement.offsetWidth] : []), (portalElement == null ? void 0 : portalElement.offsetWidth) || document.body.offsetWidth];
    return Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2;
  }, [boundaryElement, portalElement == null ? void 0 : portalElement.offsetWidth]);
  const middleware = useMemo(() => {
    const ret = [];
    ret.push(flip({
      boundary: boundaryElement || void 0,
      fallbackPlacements,
      padding: DEFAULT_TOOLTIP_PADDING,
      rootBoundary
    }));
    ret.push(offset({
      mainAxis: DEFAULT_TOOLTIP_DISTANCE
    }));
    ret.push(shift({
      boundary: boundaryElement || void 0,
      rootBoundary,
      padding: DEFAULT_TOOLTIP_PADDING
    }));
    if (arrowProp) {
      ret.push(arrow({
        element: arrowRef,
        padding: DEFAULT_TOOLTIP_PADDING
      }));
    }
    if (animate) {
      ret.push(origin);
    }
    return ret;
  }, [animate, arrowProp, boundaryElement, fallbackPlacements]);
  const {
    floatingStyles,
    placement,
    middlewareData,
    refs,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  });
  const arrowX = (_d = middlewareData.arrow) == null ? void 0 : _d.x;
  const arrowY = (_e = middlewareData.arrow) == null ? void 0 : _e.y;
  const originX = (_f = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _f.originX;
  const originY = (_g = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _g.originY;
  const tooltipId = useId();
  const [isOpen, setIsOpen] = useDelayedState(false);
  const delayGroupContext = useTooltipDelayGroup();
  const showTooltip = isOpen || (delayGroupContext == null ? void 0 : delayGroupContext.openTooltipId) === tooltipId;
  const isInsideGroup = delayGroupContext !== null;
  const openDelayProp = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.open) || 0;
  const closeDelayProp = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.close) || 0;
  const openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp;
  const closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp;
  const handleIsOpenChange = useCallback((open, immediate) => {
    if (isInsideGroup) {
      if (open) {
        const groupedOpenDelay = immediate ? 0 : openDelay;
        delayGroupContext.setIsGroupActive(open, groupedOpenDelay);
        delayGroupContext.setOpenTooltipId(tooltipId, groupedOpenDelay);
      } else {
        const minimumGroupDeactivateDelay = 200;
        const groupDeactivateDelay = closeDelay > minimumGroupDeactivateDelay ? closeDelay : minimumGroupDeactivateDelay;
        delayGroupContext.setIsGroupActive(open, groupDeactivateDelay);
        delayGroupContext.setOpenTooltipId(null, immediate ? 0 : closeDelay);
      }
    } else {
      const standaloneDelay = immediate ? 0 : open ? openDelay : closeDelay;
      setIsOpen(open, standaloneDelay);
    }
  }, [isInsideGroup, delayGroupContext, openDelay, tooltipId, closeDelay, setIsOpen]);
  const handleBlur = useCallback(e => {
    var _a3, _b2;
    handleIsOpenChange(false);
    (_b2 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onBlur) == null ? void 0 : _b2.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleClick = useCallback(e => {
    var _a3, _b2;
    handleIsOpenChange(false, true);
    (_b2 = childProp == null ? void 0 : (_a3 = childProp.props).onClick) == null ? void 0 : _b2.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleContextMenu = useCallback(e => {
    var _a3, _b2;
    handleIsOpenChange(false, true);
    (_b2 = childProp == null ? void 0 : (_a3 = childProp.props).onContextMenu) == null ? void 0 : _b2.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleFocus = useCallback(e => {
    var _a3, _b2;
    handleIsOpenChange(true);
    (_b2 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onFocus) == null ? void 0 : _b2.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleMouseEnter = useCallback(e => {
    var _a3, _b2;
    handleIsOpenChange(true);
    (_b2 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onMouseEnter) == null ? void 0 : _b2.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleMouseLeave = useCallback(e => {
    var _a3, _b2;
    handleIsOpenChange(false);
    (_b2 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onMouseLeave) == null ? void 0 : _b2.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  useEffect(() => {
    if (!showTooltip) return;
    function handleWindowMouseMove(event) {
      if (!referenceElement) return;
      const isHoveringReference = referenceElement === event.target || event.target instanceof Node && referenceElement.contains(event.target);
      if (!isHoveringReference) {
        handleIsOpenChange(false);
        window.removeEventListener("mousemove", handleWindowMouseMove);
      }
    }
    window.addEventListener("mousemove", handleWindowMouseMove);
    return () => {
      window.removeEventListener("mousemove", handleWindowMouseMove);
    };
  }, [showTooltip, referenceElement, handleIsOpenChange]);
  useEffect(() => {
    if (disabled && showTooltip) handleIsOpenChange(false);
  }, [disabled, handleIsOpenChange, showTooltip]);
  useEffect(() => {
    if (!content && showTooltip) handleIsOpenChange(false);
  }, [content, handleIsOpenChange, showTooltip]);
  useEffect(() => refs.setReference(referenceElement), [referenceElement, refs]);
  useEffect(() => {
    if (!showTooltip) return;
    function handleWindowKeyDown(event) {
      if (event.key === "Escape") {
        handleIsOpenChange(false, true);
      }
    }
    window.addEventListener("keydown", handleWindowKeyDown);
    return () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, [handleIsOpenChange, showTooltip]);
  const setArrow = useCallback(arrowEl => {
    arrowRef.current = arrowEl;
    update();
  }, [update]);
  const setFloating = useCallback(node => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const childRef = childProp == null ? void 0 : childProp.ref;
  const setReference = useCallback(node => {
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
    setReferenceElement(node);
  }, [childRef]);
  const child = useMemo(() => {
    if (!childProp) return null;
    return cloneElement(childProp, {
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onContextMenu: handleContextMenu,
      ref: setReference
    });
  }, [childProp, handleBlur, handleClick, handleContextMenu, handleFocus, handleMouseEnter, handleMouseLeave, setReference]);
  if (!child) return /* @__PURE__ */jsx(Fragment, {});
  if (disabled) return child;
  const tooltip = /* @__PURE__ */jsx(Root$a, {
    "data-ui": "Tooltip",
    ...restProps,
    ref: setFloating,
    style: floatingStyles,
    zOffset,
    $maxWidth: tooltipWidth,
    children: /* @__PURE__ */jsx(TooltipCard, {
      ...restProps,
      animate,
      arrow: arrowProp,
      arrowRef: setArrow,
      arrowX,
      arrowY,
      originX,
      originY,
      padding,
      placement,
      radius,
      ref: setFloating,
      scheme,
      shadow,
      children: content
    })
  });
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx(ConditionalWrapper, {
      condition: animate,
      wrapper: children => /* @__PURE__ */jsx(AnimatePresence, {
        children
      }),
      children: showTooltip && /* @__PURE__ */jsx(ConditionalWrapper, {
        condition: !!portalProp,
        wrapper: children => /* @__PURE__ */jsx(Portal, {
          __unstable_name: typeof portalProp === "string" ? portalProp : void 0,
          children
        }),
        children: tooltip
      })
    }), child]
  });
});
var __freeze$e = Object.freeze;
var __defProp$e = Object.defineProperty;
var __template$e = (cooked, raw) => __freeze$e(__defProp$e(cooked, "raw", {
  value: __freeze$e(raw || cooked.slice())
}));
var _a$e, _b$9, _c$3, _d$2;
const Root$9 = styled.div(_a$e || (_a$e = __template$e(["\n  line-height: 0;\n"])));
const ListBox = styled(Box)(_b$9 || (_b$9 = __template$e(["\n  & > ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n"])));
const rotate = keyframes(_c$3 || (_c$3 = __template$e(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
const AnimatedSpinnerIcon = styled(SpinnerIcon)(_d$2 || (_d$2 = __template$e(["\n  animation: ", " 500ms linear infinite;\n"])), rotate);
function AutocompleteOption(props) {
  const {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  const handleClick = useCallback(() => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, [onSelect, value]);
  const handleKeyDown = useCallback(event => {
    if (event.key === "Enter" && !_isEnterToClickElement(event.currentTarget)) {
      handleClick();
    }
  }, [handleClick]);
  return /* @__PURE__ */jsx("li", {
    "aria-selected": selected,
    "data-ui": "AutocompleteOption",
    id,
    role: "option",
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    children
  });
}
function autocompleteReducer(state, msg) {
  if (msg.type === "input/change") {
    return {
      ...state,
      activeValue: null,
      focused: true,
      query: msg.query
    };
  }
  if (msg.type === "input/focus") {
    return {
      ...state,
      focused: true
    };
  }
  if (msg.type === "root/blur") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg.type === "root/clear") {
    return {
      ...state,
      activeValue: null,
      query: null,
      value: null
    };
  }
  if (msg.type === "root/escape") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg.type === "root/open") {
    return {
      ...state,
      query: state.query || msg.query
    };
  }
  if (msg.type === "root/setActiveValue") {
    return {
      ...state,
      activeValue: msg.value,
      listFocused: msg.listFocused || state.listFocused
    };
  }
  if (msg.type === "root/setListFocused") {
    return {
      ...state,
      listFocused: msg.listFocused
    };
  }
  if (msg.type === "value/change") {
    return {
      ...state,
      activeValue: msg.value,
      query: null,
      value: msg.value
    };
  }
  return state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
const AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start";
const AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"];
const DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value;
const DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1;
const InnerAutocomplete = forwardRef(function InnerAutocomplete2(props, ref) {
  const {
    border = true,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize = 2,
    icon,
    id,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix,
    radius = 2,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props;
  const [state, dispatch] = useReducer(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: false,
    listFocused: false,
    query: null,
    value: valueProp || null
  });
  const {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state;
  const defaultRenderOption = useCallback(_ref8 => {
    let {
      value: value2
    } = _ref8;
    return /* @__PURE__ */jsx(Card, {
      "data-as": "button",
      padding: paddingProp,
      radius: 2,
      tone: "inherit",
      children: /* @__PURE__ */jsx(Text, {
        size: fontSize,
        textOverflow: "ellipsis",
        children: value2
      })
    });
  }, [fontSize, paddingProp]);
  const renderOption = typeof renderOptionProp === "function" ? renderOptionProp : defaultRenderOption;
  const filterOption = typeof filterOptionProp === "function" ? filterOptionProp : DEFAULT_FILTER_OPTION;
  const rootElementRef = useRef(null);
  const resultsPopoverElementRef = useRef(null);
  const inputElementRef = useRef(null);
  const listBoxElementRef = useRef(null);
  const listFocusedRef = useRef(false);
  const valueRef = useRef(value);
  const valuePropRef = useRef(valueProp);
  const popoverMouseWithinRef = useRef(false);
  const forwardedRef = useForwardedRef(ref);
  const listBoxId = "".concat(id, "-listbox");
  const options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY;
  const padding = useArrayProp(paddingProp);
  const currentOption = useMemo(() => value !== null ? options.find(o => o.value === value) : void 0, [options, value]);
  const filteredOptions = useMemo(() => options.filter(option => query ? filterOption(query, option) : true), [filterOption, options, query]);
  const filteredOptionsLen = filteredOptions.length;
  const activeItemId = activeValue ? "".concat(id, "-option-").concat(activeValue) : void 0;
  const expanded = query !== null && loading || focused && query !== null;
  const handleRootBlur = useCallback(event => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current) {
        return;
      }
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = false;
      if (document.activeElement) {
        for (const e of elements) {
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = true;
            break;
          }
        }
      }
      if (focusInside === false) {
        dispatch({
          type: "root/blur"
        });
        popoverMouseWithinRef.current = false;
        if (onQueryChange) onQueryChange(null);
        if (onBlur) onBlur(event);
      }
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]);
  const handleRootFocus = useCallback(event => {
    const listBoxElement = listBoxElementRef.current;
    const focusedElement = event.target instanceof HTMLElement ? event.target : null;
    const listFocused2 = (listBoxElement == null ? void 0 : listBoxElement.contains(focusedElement)) || false;
    if (listFocused2 !== listFocusedRef.current) {
      listFocusedRef.current = listFocused2;
      dispatch({
        type: "root/setListFocused",
        listFocused: listFocused2
      });
    }
  }, []);
  const handleOptionSelect = useCallback(v => {
    var _a;
    dispatch({
      type: "value/change",
      value: v
    });
    popoverMouseWithinRef.current = false;
    if (onSelect) onSelect(v);
    valueRef.current = v;
    if (onChange) onChange(v);
    if (onQueryChange) onQueryChange(null);
    (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onSelect, onQueryChange]);
  const handleRootKeyDown = useCallback(event => {
    var _a, _b;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      if (!filteredOptionsLen) return;
      const activeOption = filteredOptions.find(o => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      if (!filteredOptionsLen) return;
      const activeOption = filteredOptions.find(o => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[activeIndex === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex - 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "Escape") {
      dispatch({
        type: "root/escape"
      });
      popoverMouseWithinRef.current = false;
      if (onQueryChange) onQueryChange(null);
      (_a = inputElementRef.current) == null ? void 0 : _a.focus();
      return;
    }
    const target = event.target;
    const listEl = listBoxElementRef.current;
    if ((listEl === target || (listEl == null ? void 0 : listEl.contains(target))) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event.key)) {
      (_b = inputElementRef.current) == null ? void 0 : _b.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]);
  const handleInputChange = useCallback(event => {
    const nextQuery = event.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    });
    if (onQueryChange) onQueryChange(nextQuery);
  }, [onQueryChange]);
  const handleInputFocus = useCallback(event => {
    if (!focused) {
      dispatch({
        type: "input/focus"
      });
      if (onFocus) onFocus(event);
    }
  }, [focused, onFocus]);
  const handlePopoverMouseEnter = useCallback(() => {
    popoverMouseWithinRef.current = true;
  }, []);
  const handlePopoverMouseLeave = useCallback(() => {
    popoverMouseWithinRef.current = false;
  }, []);
  const handleClearButtonClick = useCallback(() => {
    var _a;
    dispatch({
      type: "root/clear"
    });
    valueRef.current = "";
    if (onChange) onChange("");
    if (onQueryChange) onQueryChange(null);
    (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onQueryChange]);
  const handleClearButtonFocus = useCallback(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  useEffect(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp;
      if (valueProp !== void 0) {
        dispatch({
          type: "value/change",
          value: valueProp
        });
        valueRef.current = valueProp;
      }
      return;
    }
    if (valueProp !== valueRef.current) {
      valueRef.current = valueProp || null;
      dispatch({
        type: "value/change",
        value: valueProp || null
      });
    }
  }, [valueProp]);
  useEffect(() => {
    if (!focused && valueRef.current) {
      dispatch({
        type: "root/setActiveValue",
        value: valueRef.current
      });
    }
  }, [focused]);
  useEffect(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement) return;
    const activeOption = filteredOptions.find(o => o.value === activeValue);
    if (activeOption) {
      const activeIndex = filteredOptions.indexOf(activeOption);
      const activeItemElement = listElement.childNodes[activeIndex];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement)) {
          return;
        }
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const setRef = useCallback(el => {
    inputElementRef.current = el;
    forwardedRef.current = el;
  }, [forwardedRef]);
  const clearButton = useMemo(() => {
    if (!loading && !disabled && value) {
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
    }
    return void 0;
  }, [disabled, handleClearButtonFocus, loading, value]);
  const openButtonBoxPadding = useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 1;
    if (v === 2) return 1;
    return v - 2;
  }), [padding]);
  const openButtonPadding = useMemo(() => padding.map(v => Math.max(v - 1, 0)), [padding]);
  const openButtonProps = useMemo(() => typeof openButton === "object" ? openButton : EMPTY_RECORD, [openButton]);
  const handleOpenClick = useCallback(event => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
    if (openButtonProps.onClick) openButtonProps.onClick(event);
    _raf(() => {
      var _a;
      return (_a = inputElementRef.current) == null ? void 0 : _a.focus();
    });
  }, [currentOption, openButtonProps, renderValue, value]);
  const openButtonNode = useMemo(() => !disabled && !readOnly && openButton ? /* @__PURE__ */jsx(Box, {
    "aria-hidden": expanded,
    padding: openButtonBoxPadding,
    children: /* @__PURE__ */jsx(Button, {
      "aria-label": "Open",
      disabled: expanded,
      fontSize,
      icon: ChevronDownIcon,
      mode: "bleed",
      padding: openButtonPadding,
      ...openButtonProps,
      onClick: handleOpenClick
    })
  }) : void 0, [disabled, expanded, fontSize, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]);
  const inputValue = useMemo(() => {
    if (query === null) {
      if (value !== null) {
        return renderValue(value, currentOption);
      }
      return "";
    }
    return query;
  }, [currentOption, query, renderValue, value]);
  const input = /* @__PURE__ */jsx(TextInput, {
    ...restProps,
    "aria-activedescendant": activeItemId,
    "aria-autocomplete": "list",
    "aria-expanded": expanded,
    "aria-owns": listBoxId,
    autoCapitalize: "off",
    autoComplete: "off",
    autoCorrect: "off",
    border,
    clearButton,
    customValidity,
    disabled,
    fontSize,
    icon,
    iconRight: loading && AnimatedSpinnerIcon,
    id,
    inputMode: "search",
    onChange: handleInputChange,
    onClear: handleClearButtonClick,
    onFocus: handleInputFocus,
    padding,
    prefix,
    radius,
    readOnly,
    ref: setRef,
    role: "combobox",
    spellCheck: false,
    suffix: suffix || openButtonNode,
    value: inputValue
  });
  const handleListBoxKeyDown = useCallback(event => {
    var _a;
    if (event.key === "Tab") {
      if (listFocused) (_a = inputElementRef.current) == null ? void 0 : _a.focus();
    }
  }, [listFocused]);
  const content = useMemo(() => {
    if (filteredOptions.length === 0) return null;
    return /* @__PURE__ */jsx(ListBox, {
      "data-ui": "AutoComplete__results",
      onKeyDown: handleListBoxKeyDown,
      padding: 1,
      ...listBox,
      tabIndex: -1,
      children: /* @__PURE__ */jsx(Stack, {
        as: "ul",
        "aria-multiselectable": false,
        "data-ui": "AutoComplete__resultsList",
        id: listBoxId,
        ref: listBoxElementRef,
        role: "listbox",
        space: 1,
        children: filteredOptions.map(option => {
          const active = activeValue !== null ? option.value === activeValue : currentOption === option;
          return /* @__PURE__ */jsx(AutocompleteOption, {
            id: "".concat(id, "-option-").concat(option.value),
            onSelect: handleOptionSelect,
            selected: active,
            value: option.value,
            children: cloneElement(renderOption(option), {
              disabled: loading,
              selected: active,
              tabIndex: listFocused && active ? 0 : -1
            })
          }, option.value);
        })
      })
    });
  }, [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id, listBox, listBoxId, listFocused, loading, renderOption]);
  const results = useMemo(() => {
    if (renderPopover) {
      return renderPopover({
        content,
        hidden: !expanded,
        inputElement: inputElementRef.current,
        onMouseEnter: handlePopoverMouseEnter,
        onMouseLeave: handlePopoverMouseLeave
      }, resultsPopoverElementRef);
    }
    if (filteredOptionsLen === 0) {
      return null;
    }
    return /* @__PURE__ */jsx(Popover, {
      arrow: false,
      constrainSize: true,
      content,
      fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS,
      matchReferenceWidth: true,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave,
      open: expanded,
      overflow: "auto",
      placement: AUTOCOMPLETE_POPOVER_PLACEMENT,
      portal: true,
      radius,
      ref: resultsPopoverElementRef,
      referenceElement: inputElementRef.current,
      ...popover
    });
  }, [content, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return /* @__PURE__ */jsxs(Root$9, {
    "data-ui": "Autocomplete",
    onBlur: handleRootBlur,
    onFocus: handleRootFocus,
    onKeyDown: handleRootKeyDown,
    ref: rootElementRef,
    children: [input, results]
  });
});
const Autocomplete = InnerAutocomplete;
var __freeze$d = Object.freeze;
var __defProp$d = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$d(cooked, "raw", {
  value: __freeze$d(raw || cooked.slice())
}));
var _a$d, _b$8;
const Root$8 = styled.ol(_a$d || (_a$d = __template$d(["\n  margin: 0;\n  padding: 0;\n  display: flex;\n  list-style: none;\n  align-items: center;\n  white-space: nowrap;\n  line-height: 0;\n"])));
const ExpandButton = styled(Button)(_b$8 || (_b$8 = __template$d(["\n  appearance: none;\n  margin: -4px;\n"])));
const Breadcrumbs = forwardRef(function Breadcrumbs2(props, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props;
  const space = useArrayProp(spaceRaw);
  const [open, setOpen] = useState(false);
  const [expandElement, setExpandElement] = useState(null);
  const [popoverElement, setPopoverElement] = useState(null);
  const collapse = useCallback(() => setOpen(false), []);
  const expand = useCallback(() => setOpen(true), []);
  useClickOutside(collapse, [expandElement, popoverElement]);
  const rawItems = useMemo(() => Children.toArray(children).filter(child => {
    return isValidElement(child);
  }), [children]);
  const items = useMemo(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2);
      const afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), /* @__PURE__ */jsx(Popover, {
        constrainSize: true,
        content: /* @__PURE__ */jsx(Stack, {
          as: "ol",
          overflow: "auto",
          padding: space,
          space,
          children: rawItems.slice(beforeLength - 1, len - afterLength)
        }),
        open,
        placement: "top",
        portal: true,
        ref: setPopoverElement,
        children: /* @__PURE__ */jsx(ExpandButton, {
          fontSize: 1,
          mode: "bleed",
          onClick: open ? collapse : expand,
          padding: 1,
          ref: setExpandElement,
          selected: open,
          text: "\u2026"
        })
      }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return /* @__PURE__ */jsx(Root$8, {
    "data-ui": "Breadcrumbs",
    ...restProps,
    ref,
    children: items.map((item, itemIndex) => /* @__PURE__ */jsxs(Fragment$1, {
      children: [itemIndex > 0 && /* @__PURE__ */jsx(Box, {
        "aria-hidden": true,
        as: "li",
        paddingX: space,
        children: separator || /* @__PURE__ */jsx(Text, {
          muted: true,
          children: "/"
        })
      }), /* @__PURE__ */jsx(Box, {
        as: "li",
        children: item
      })]
    }, itemIndex))
  });
});
var __freeze$c = Object.freeze;
var __defProp$c = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$c(cooked, "raw", {
  value: __freeze$c(raw || cooked.slice())
}));
var _a$c, _b$7;
function dialogStyle(_ref9) {
  let {
    theme
  } = _ref9;
  const {
    color
  } = getTheme_v2(theme);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$position, position => ({
    "&&": {
      position
    }
  }));
}
function animationDialogStyle(props) {
  if (!props.$animate) return css(_a$c || (_a$c = __template$c([""])));
  return css(_b$7 || (_b$7 = __template$c(["\n    @keyframes zoomIn {\n      from {\n        opacity: 0;\n        transform: scale(0.95);\n      }\n      to {\n        opacity: 1;\n        transform: scale(1);\n      }\n    }\n    @keyframes fadeIn {\n      from {\n        opacity: 0;\n      }\n      to {\n        opacity: 1;\n      }\n    }\n\n    animation: fadeIn 200ms ease-out;\n    // Animates the dialog card.\n    & > [data-ui='DialogCard'] {\n      animation: zoomIn 200ms ease-out;\n    }\n  "])));
}
const key$3 = Symbol.for("@sanity/ui/context/dialog");
globalScope[key$3] = globalScope[key$3] || createContext({
  version: 0
});
const DialogContext = globalScope[key$3];
function useDialog() {
  return useContext(DialogContext);
}
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b, _b$6, _c$2, _d$1, _e, _f;
function isTargetWithinScope(boundaryElement, portalElement, target) {
  if (!boundaryElement || !portalElement) return true;
  return containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
const Root$7 = styled(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle);
const DialogContainer = styled(Container)(_a$b || (_a$b = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n"])));
const DialogCardRoot = styled(Card)(_b$6 || (_b$6 = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  min-height: 0;\n  max-height: 100%;\n  overflow: hidden;\n  overflow: clip;\n"])));
const DialogLayout = styled(Flex)(_c$2 || (_c$2 = __template$b(["\n  flex: 1;\n  min-height: 0;\n  width: 100%;\n"])));
const DialogHeader = styled(Box)(_d$1 || (_d$1 = __template$b(["\n  position: relative;\n  z-index: 2;\n"])));
const DialogContent = styled(Box)(_e || (_e = __template$b(["\n  position: relative;\n  z-index: 1;\n  overflow: auto;\n  outline: none;\n"])));
const DialogFooter = styled(Box)(_f || (_f = __template$b(["\n  position: relative;\n  z-index: 3;\n"])));
const DialogCard = forwardRef(function DialogCard2(props, ref) {
  var _a2;
  const {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props;
  const portal = usePortal();
  const portalElement = portalProp ? ((_a2 = portal.elements) == null ? void 0 : _a2[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const width = useArrayProp(widthProp);
  const forwardedRef = useForwardedRef(ref);
  const [rootElement, setRootElement] = useState(null);
  const localContentRef = useRef(null);
  const layer = useLayer();
  const {
    isTopLayer
  } = layer;
  const labelId = "".concat(id, "_label");
  const showCloseButton = Boolean(onClose) && hideCloseButton === false;
  const showHeader = Boolean(header) || showCloseButton;
  useEffect(() => {
    if (!autoFocus) return;
    if (forwardedRef.current) {
      focusFirstDescendant(forwardedRef.current);
    }
  }, [autoFocus, forwardedRef]);
  useGlobalKeyDown(useCallback(event => {
    if (!isTopLayer || !onClose) return;
    const target = document.activeElement;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      onClose();
    }
  }, [boundaryElement, isTopLayer, onClose, portalElement]));
  useClickOutside(useCallback(event => {
    if (!isTopLayer || !onClickOutside) return;
    const target = event.target;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    onClickOutside();
  }, [boundaryElement, isTopLayer, onClickOutside, portalElement]), [rootElement]);
  const setRef = useCallback(el => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef]);
  const setContentRef = useCallback(el => {
    localContentRef.current = el;
    if (typeof contentRef === "function") contentRef(el);else if (contentRef) contentRef.current = el;
  }, [contentRef]);
  return /* @__PURE__ */jsx(DialogContainer, {
    "data-ui": "DialogCard",
    width,
    children: /* @__PURE__ */jsx(DialogCardRoot, {
      radius,
      ref: setRef,
      scheme,
      shadow,
      children: /* @__PURE__ */jsxs(DialogLayout, {
        direction: "column",
        children: [showHeader && /* @__PURE__ */jsx(DialogHeader, {
          children: /* @__PURE__ */jsxs(Flex, {
            align: "center",
            padding: 3,
            children: [/* @__PURE__ */jsx(Box, {
              flex: 1,
              padding: 2,
              children: header && /* @__PURE__ */jsx(Text, {
                id: labelId,
                size: 1,
                weight: "semibold",
                children: header
              })
            }), showCloseButton && /* @__PURE__ */jsx(Box, {
              flex: "none",
              children: /* @__PURE__ */jsx(Button, {
                "aria-label": "Close dialog",
                disabled: !onClose,
                icon: CloseIcon,
                mode: "bleed",
                onClick: onClose,
                padding: 2
              })
            })]
          })
        }), /* @__PURE__ */jsx(DialogContent, {
          flex: 1,
          ref: setContentRef,
          tabIndex: -1,
          children
        }), footer && /* @__PURE__ */jsx(DialogFooter, {
          children: footer
        })]
      })
    })
  });
});
const Dialog = forwardRef(function Dialog2(props, ref) {
  var _a2;
  const dialog = useDialog();
  const {
    layer
  } = useTheme_v2();
  const {
    __unstable_autoFocus: autoFocus = true,
    __unstable_hideCloseButton: hideCloseButton = false,
    cardRadius: cardRadiusProp = 4,
    cardShadow = 3,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: paddingProp = 3,
    portal: portalProp,
    position: positionProp = dialog.position || "fixed",
    scheme,
    width: widthProp = 0,
    zOffset: zOffsetProp = dialog.zOffset || layer.dialog.zOffset,
    animate = false,
    ...restProps
  } = props;
  const portal = usePortal();
  const portalElement = portalProp ? ((_a2 = portal.elements) == null ? void 0 : _a2[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const cardRadius = useArrayProp(cardRadiusProp);
  const padding = useArrayProp(paddingProp);
  const position = useArrayProp(positionProp);
  const width = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const preDivRef = useRef(null);
  const postDivRef = useRef(null);
  const cardRef = useRef(null);
  const focusedElementRef = useRef(null);
  const handleFocus = useCallback(event => {
    onFocus == null ? void 0 : onFocus(event);
    const target = event.target;
    const cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    if (isHTMLElement(event.target)) {
      focusedElementRef.current = event.target;
    }
  }, [onFocus]);
  const labelId = "".concat(id, "_label");
  const rootClickTimeoutRef = useRef();
  const handleRootClick = useCallback(() => {
    if (rootClickTimeoutRef.current) {
      clearTimeout(rootClickTimeoutRef.current);
    }
    rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target = focusedElementRef.current;
        if (!target || !document.body.contains(target)) {
          const cardElement = cardRef.current;
          if (cardElement) focusFirstDescendant(cardElement);
          return;
        }
        target.focus();
      }
    }, 0);
  }, [boundaryElement, portalElement]);
  return /* @__PURE__ */jsx(Portal, {
    __unstable_name: portalProp,
    children: /* @__PURE__ */jsxs(Root$7, {
      ...restProps,
      $animate: animate,
      $padding: padding,
      $position: position,
      "aria-labelledby": labelId,
      "aria-modal": true,
      "data-ui": "Dialog",
      id,
      onActivate,
      onClick: handleRootClick,
      onFocus: handleFocus,
      ref,
      role: "dialog",
      zOffset,
      children: [/* @__PURE__ */jsx("div", {
        ref: preDivRef,
        tabIndex: 0
      }), /* @__PURE__ */jsx(DialogCard, {
        __unstable_autoFocus: autoFocus,
        __unstable_hideCloseButton: hideCloseButton,
        contentRef,
        footer,
        header,
        id,
        onClickOutside,
        onClose,
        portal: portalProp,
        radius: cardRadius,
        ref: cardRef,
        scheme,
        shadow: cardShadow,
        width,
        children
      }), /* @__PURE__ */jsx("div", {
        ref: postDivRef,
        tabIndex: 0
      })]
    })
  });
});
function DialogProvider(props) {
  const {
    children,
    position,
    zOffset
  } = props;
  const contextValue = useMemo(() => ({
    version: 0,
    position,
    zOffset
  }), [position, zOffset]);
  return /* @__PURE__ */jsx(DialogContext.Provider, {
    value: contextValue,
    children
  });
}
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a, _b$5;
const Root$6 = styled.kbd(_a$a || (_a$a = __template$a(["\n  font: inherit;\n  padding: 1px;\n\n  &:not([hidden]) {\n    display: block;\n  }\n"])));
const Key = styled(KBD)(_b$5 || (_b$5 = __template$a(["\n  &:not([hidden]) {\n    display: block;\n  }\n"])));
const Hotkeys = forwardRef(function Hotkeys2(props, ref) {
  const {
    fontSize,
    keys,
    padding,
    radius,
    space: spaceProp = 0.5,
    ...restProps
  } = props;
  const space = useArrayProp(spaceProp);
  if (!keys || keys.length === 0) {
    return /* @__PURE__ */jsx(Fragment, {});
  }
  return /* @__PURE__ */jsx(Root$6, {
    "data-ui": "Hotkeys",
    ...restProps,
    ref,
    children: /* @__PURE__ */jsx(Inline, {
      as: "span",
      space,
      children: keys.map((key, i) => /* @__PURE__ */jsx(Key, {
        fontSize,
        padding,
        radius,
        children: key
      }, i))
    })
  });
});
const key$2 = Symbol.for("@sanity/ui/context/menu");
globalScope[key$2] = globalScope[key$2] || createContext(null);
const MenuContext = globalScope[key$2];
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  while (e !== rootElement) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e);
    path.unshift(index);
    if (parentElement === rootElement) {
      return path;
    }
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement) return;
  const map = /* @__PURE__ */new WeakMap();
  for (const el of elements) {
    map.set(el, _getDOMPath(rootElement, el));
  }
  const _sort = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH;
    const _b = map.get(b) || EMPTY_PATH;
    const len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1;
      const bIndex = _b[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const {
    onKeyDown,
    originElement,
    shouldFocus
  } = props;
  const elementsRef = useRef([]);
  const [rootElement, setRootElement] = useState(null);
  const [activeIndex, _setActiveIndex] = useState(-1);
  const activeIndexRef = useRef(activeIndex);
  const activeElement = elementsRef.current[activeIndex] || null;
  const mounted = Boolean(rootElement);
  const setActiveIndex = useCallback(nextActiveIndex => {
    _setActiveIndex(nextActiveIndex);
    activeIndexRef.current = nextActiveIndex;
  }, []);
  const mount = useCallback((element, selected) => {
    if (!element) return () => void 0;
    if (elementsRef.current.indexOf(element) === -1) {
      elementsRef.current.push(element);
      _sortElements(rootElement, elementsRef.current);
    }
    if (selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      if (idx > -1) {
        elementsRef.current.splice(idx, 1);
      }
    };
  }, [rootElement, setActiveIndex]);
  const handleKeyDown = useCallback(event => {
    if (event.key === "Tab") {
      if (originElement) {
        originElement.focus();
      }
      return;
    }
    if (event.key === "Home") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[0];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[focusableElements.length - 1];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex + 1) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onKeyDown, originElement, setActiveIndex]);
  const handleItemMouseEnter = useCallback(event => {
    const element = event.currentTarget;
    const currentIndex = elementsRef.current.indexOf(element);
    setActiveIndex(currentIndex);
  }, [setActiveIndex]);
  const handleItemMouseLeave = useCallback(() => {
    setActiveIndex(-2);
    rootElement == null ? void 0 : rootElement.focus();
  }, [setActiveIndex, rootElement]);
  useEffect(() => {
    if (!mounted) return;
    const rafId = window.requestAnimationFrame(() => {
      const _activeIndex = activeIndexRef.current;
      if (_activeIndex === -1) {
        if (shouldFocus === "first") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[0];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        if (shouldFocus === "last") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[focusableElements.length - 1];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        return;
      }
      const element = elementsRef.current[_activeIndex] || null;
      element == null ? void 0 : element.focus();
    });
    return () => {
      window.cancelAnimationFrame(rafId);
    };
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]);
  return {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  };
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
const Root$5 = styled(Box)(_a$9 || (_a$9 = __template$9(["\n  outline: none;\n  overflow: auto;\n"])));
const Menu = forwardRef(function Menu2(props, ref) {
  const {
    children,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusFirst,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusLast,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemSelect,
    onKeyDown,
    originElement,
    padding = 1,
    registerElement,
    shouldFocus = props.focusFirst && "first" || props.focusLast && "last" || null,
    space = 1,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const {
    isTopLayer
  } = useLayer();
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  } = useMenuController({
    onKeyDown,
    originElement,
    shouldFocus
  });
  const handleRefChange = useCallback(el => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef, setRootElement]);
  useEffect(() => {
    if (onItemSelect) onItemSelect(activeIndex);
  }, [activeIndex, onItemSelect]);
  useClickOutside(useCallback(event => isTopLayer && onClickOutside && onClickOutside(event), [isTopLayer, onClickOutside]), [rootElement]);
  useGlobalKeyDown(useCallback(event => {
    if (!isTopLayer) return;
    if (event.key === "Escape") {
      event.stopPropagation();
      if (onEscape) onEscape();
    }
  }, [isTopLayer, onEscape]));
  useEffect(() => {
    if (!rootElement || !registerElement) return;
    return registerElement(rootElement);
  }, [registerElement, rootElement]);
  const value = useMemo(() => ({
    version: 0,
    activeElement,
    activeIndex,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement,
    // deprecated
    onMouseEnter: handleItemMouseEnter,
    onMouseLeave: handleItemMouseLeave
  }), [activeElement, activeIndex, mount, handleItemMouseEnter, handleItemMouseLeave, onClickOutside, onEscape, onItemClick, registerElement]);
  return /* @__PURE__ */jsx(MenuContext.Provider, {
    value,
    children: /* @__PURE__ */jsx(Root$5, {
      "data-ui": "Menu",
      ...restProps,
      onKeyDown: handleKeyDown,
      padding,
      ref: handleRefChange,
      role: "menu",
      tabIndex: -1,
      children: /* @__PURE__ */jsx(Stack, {
        space,
        children
      })
    })
  });
});
const MenuButton = forwardRef(function MenuButton2(props, ref) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = false,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = true,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props;
  const [open, setOpen] = useState(false);
  const [shouldFocus, setShouldFocus] = useState(null);
  const [buttonElement, setButtonElement] = useState(null);
  const [menuElements, setChildMenuElements] = useState([]);
  const openRef = useRef(open);
  useEffect(() => {
    if (onOpen && open && !openRef.current) {
      onOpen();
    }
  }, [onOpen, open]);
  useEffect(() => {
    if (onClose && !open && openRef.current) {
      onClose();
    }
  }, [onClose, open]);
  useEffect(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = useCallback(() => {
    setOpen(v => !v);
    setShouldFocus(null);
  }, []);
  const handleMouseDown = useCallback(event => {
    if (open) event.preventDefault();
  }, [open]);
  const handleButtonKeyDown = useCallback(event => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("first");
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("last");
      return;
    }
  }, []);
  const handleMenuClickOutside = useCallback(event => {
    const target = event.target;
    if (!(target instanceof Node)) {
      return;
    }
    if (buttonElement && (target === buttonElement || buttonElement.contains(target))) {
      return;
    }
    for (const el of menuElements) {
      if (target === el || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [buttonElement, menuElements]);
  const handleMenuEscape = useCallback(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose) return;
    if (buttonElement) buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const handleBlur = useCallback(event => {
    const target = event.relatedTarget;
    if (!(target instanceof Node)) {
      return;
    }
    for (const el of menuElements) {
      if (el === target || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [menuElements]);
  const handleItemClick = useCallback(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose) return;
    if (buttonElement) buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const registerElement = useCallback(el => {
    setChildMenuElements(els => els.concat([el]));
    return () => {
      setChildMenuElements(els => {
        return els.filter(_el => _el !== el);
      });
    };
  }, []);
  const menuProps = useMemo(() => ({
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), [buttonElement, handleMenuClickOutside, handleMenuEscape, handleItemClick, id, handleBlur, registerElement, shouldFocus]);
  const menu = isElement$1(menuProp) ? cloneElement(menuProp, menuProps) : null;
  const setButtonRef = useCallback(el => {
    if (typeof ref === "function") {
      ref(el);
    } else if (ref) {
      ref.current = el;
    }
    setButtonElement(el);
  }, [ref]);
  const button = useMemo(() => isElement$1(buttonProp) ? cloneElement(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    onMouseDown: handleMouseDown,
    "aria-haspopup": true,
    "aria-expanded": open,
    ref: setButtonRef,
    selected: open
  }) : null, [buttonProp, handleButtonClick, handleButtonKeyDown, handleMouseDown, id, open, setButtonRef]);
  const popoverProps = useMemo(() => ({
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...(popover || {})
  }), [deprecated_boundaryElement, deprecated_placement, deprecated_popoverRadius, deprecated_popoverScheme, deprecated_portal, deprecated_preventOverflow, popover]);
  return /* @__PURE__ */jsx(Popover, {
    "data-ui": "MenuButton__popover",
    ...popoverProps,
    content: menu,
    open,
    children: button || /* @__PURE__ */jsx(Fragment, {})
  });
});
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8;
const MenuDivider = styled.hr(_a$8 || (_a$8 = __template$8(["\n  height: 1px;\n  border: 0;\n  background: var(--card-hairline-soft-color);\n  margin: 0;\n"])));
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7, _b$4;
function selectableBaseStyle() {
  return css(_a$7 || (_a$7 = __template$7(["\n    background-color: inherit;\n    color: inherit;\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -moz-available;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])));
}
function selectableColorStyle(props) {
  var _a2;
  const {
    $tone
  } = props;
  const {
    color,
    style
  } = getTheme_v2(props.theme);
  const tone = color.selectable[$tone];
  return css(_b$4 || (_b$4 = __template$7(["\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n    outline: none;\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[aria-pressed='true'] {\n          ", "\n        }\n\n        &[data-selected],\n        &[aria-selected='true'] > & {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    ", "\n  "])), _cardColorStyle(color, tone.enabled), _cardColorStyle(color, tone.disabled), _cardColorStyle(color, tone.pressed), _cardColorStyle(color, tone.selected), _cardColorStyle(color, tone.hovered), _cardColorStyle(color, tone.pressed), _cardColorStyle(color, tone.disabled), _cardColorStyle(color, tone.pressed), _cardColorStyle(color, tone.selected), _cardColorStyle(color, tone.hovered), _cardColorStyle(color, tone.pressed), (_a2 = style == null ? void 0 : style.card) == null ? void 0 : _a2.root);
}
const Selectable = styled(Box)(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
function useMenu() {
  const value = useContext(MenuContext);
  if (!value) {
    throw new Error("useMenu(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useMenu(): the context value is not compatible");
  }
  return value;
}
function MenuGroup(props) {
  const {
    as = "button",
    children,
    fontSize = 1,
    icon,
    onClick,
    padding = 3,
    popover,
    radius = 2,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props;
  const menu = useMenu();
  const {
    scheme
  } = useRootTheme();
  const {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    registerElement
  } = menu;
  const [rootElement, setRootElement] = useState(null);
  const [open, setOpen] = useState(false);
  const shouldFocusRef = useRef(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  const [withinMenu, setWithinMenu] = useState(false);
  const handleMouseEnter = useCallback(event => {
    setWithinMenu(false);
    onItemMouseEnter(event);
    setOpen(true);
  }, [onItemMouseEnter]);
  const handleMenuKeyDown = useCallback(event => {
    if (event.key === "ArrowLeft") {
      event.stopPropagation();
      setOpen(false);
      requestAnimationFrame(() => {
        rootElement == null ? void 0 : rootElement.focus();
      });
    }
  }, [rootElement]);
  const handleClick = useCallback(event => {
    if (onClick) onClick(event);
    shouldFocusRef.current = "first";
    setOpen(true);
    requestAnimationFrame(() => {
      shouldFocusRef.current = null;
    });
  }, [onClick]);
  const handleChildItemClick = useCallback(() => {
    setOpen(false);
    if (onItemClick) onItemClick();
  }, [onItemClick]);
  const handleMenuMouseEnter = useCallback(() => setWithinMenu(true), []);
  useEffect(() => mount(rootElement), [mount, rootElement]);
  useEffect(() => {
    if (!active) setOpen(false);
  }, [active]);
  useEffect(() => {
    if (!open) setWithinMenu(false);
  }, [open]);
  const childMenu = /* @__PURE__ */jsx(Menu, {
    onClickOutside,
    onEscape,
    onItemClick: handleChildItemClick,
    onKeyDown: handleMenuKeyDown,
    onMouseEnter: handleMenuMouseEnter,
    registerElement,
    shouldFocus: shouldFocusRef.current,
    children
  });
  const handleKeyDown = useCallback(event => {
    const target = event.currentTarget;
    if (document.activeElement !== target) {
      return;
    }
    if (event.key === "ArrowRight") {
      shouldFocusRef.current = "first";
      setOpen(true);
      setWithinMenu(true);
      requestAnimationFrame(() => {
        shouldFocusRef.current = null;
      });
      return;
    }
  }, []);
  return /* @__PURE__ */jsx(Popover, {
    ...popover,
    content: childMenu,
    "data-ui": "MenuGroup__popover",
    open,
    children: /* @__PURE__ */jsx(Selectable, {
      "data-as": as,
      "data-ui": "MenuGroup",
      forwardedAs: as,
      ...restProps,
      "aria-pressed": as === "button" ? withinMenu : void 0,
      "data-pressed": as !== "button" ? withinMenu : void 0,
      "data-selected": !withinMenu && active ? "" : void 0,
      $radius: useArrayProp(radius),
      $tone: tone,
      $scheme: scheme,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onMouseEnter: handleMouseEnter,
      ref: setRootElement,
      tabIndex: -1,
      type: as === "button" ? "button" : void 0,
      children: /* @__PURE__ */jsxs(Flex, {
        gap: space,
        padding,
        children: [icon && /* @__PURE__ */jsxs(Text, {
          size: fontSize,
          children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
        }), /* @__PURE__ */jsx(Box, {
          flex: 1,
          children: /* @__PURE__ */jsx(Text, {
            size: fontSize,
            textOverflow: "ellipsis",
            weight: "medium",
            children: text
          })
        }), /* @__PURE__ */jsx(Text, {
          size: fontSize,
          children: /* @__PURE__ */jsx(ChevronRightIcon, {})
        })]
      })
    })
  });
}
const MenuItem = forwardRef(function MenuItem2(props, forwardedRef) {
  const {
    as = "button",
    children,
    disabled,
    fontSize = 1,
    hotkeys,
    icon,
    iconRight,
    onClick,
    padding = 3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius = 2,
    selected: selectedProp,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props;
  const {
    scheme
  } = useRootTheme();
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    onItemMouseLeave = menu.onMouseLeave
  } = menu;
  const [rootElement, setRootElement] = useState(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  useEffect(() => mount(rootElement, selectedProp), [mount, rootElement, selectedProp]);
  const ref = useForwardedRef(forwardedRef);
  const handleClick = useCallback(event => {
    if (disabled) return;
    if (onClick) onClick(event);
    if (onItemClick) onItemClick();
  }, [disabled, onClick, onItemClick]);
  const paddingProps = useMemo(() => ({
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }), [padding, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft]);
  const hotkeysFontSize = useArrayProp(fontSize).map(s => s - 1);
  const setRef = useCallback(el => {
    ref.current = el;
    setRootElement(el);
  }, [ref]);
  return /* @__PURE__ */jsxs(Selectable, {
    "data-ui": "MenuItem",
    ...restProps,
    "aria-pressed": as === "button" && pressed,
    "data-pressed": as !== "button" && pressed ? "" : void 0,
    "data-selected": active ? "" : void 0,
    "data-disabled": disabled ? "" : void 0,
    forwardedAs: as,
    $radius: useArrayProp(radius),
    $padding: useArrayProp(0),
    $tone: disabled ? "default" : tone,
    $scheme: scheme,
    disabled,
    onClick: handleClick,
    onMouseEnter: onItemMouseEnter,
    onMouseLeave: onItemMouseLeave,
    ref: setRef,
    role: "menuitem",
    tabIndex: -1,
    type: as === "button" ? "button" : void 0,
    children: [(icon || text || iconRight) && /* @__PURE__ */jsxs(Flex, {
      as: "span",
      gap: space,
      align: "center",
      ...paddingProps,
      children: [icon && /* @__PURE__ */jsxs(Text, {
        size: fontSize,
        children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
      }), text && /* @__PURE__ */jsx(Box, {
        flex: 1,
        children: /* @__PURE__ */jsx(Text, {
          size: fontSize,
          textOverflow: "ellipsis",
          weight: "medium",
          children: text
        })
      }), hotkeys && /* @__PURE__ */jsx(Hotkeys, {
        fontSize: hotkeysFontSize,
        keys: hotkeys,
        style: {
          marginTop: -4,
          marginBottom: -4
        }
      }), iconRight && /* @__PURE__ */jsxs(Text, {
        size: fontSize,
        children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
      })]
    }), children && /* @__PURE__ */jsx(Box, {
      as: "span",
      ...paddingProps,
      children
    })]
  });
});
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6, _b$3, _c$1, _d;
const keyframe = keyframes(_a$6 || (_a$6 = __template$6(["\n  0% {\n    background-position: 100%;\n  }\n  100% {\n    background-position: -100%;\n  }\n"])));
const animation = css(_b$3 || (_b$3 = __template$6(["\n  background-image: linear-gradient(\n    to right,\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-to),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from)\n  );\n  background-position: 100%;\n  background-size: 200% 100%;\n  background-attachment: fixed;\n  animation-name: ", ";\n  animation-timing-function: ease-in-out;\n  animation-iteration-count: infinite;\n  animation-duration: 2000ms;\n"])), keyframe);
const skeletonStyle = css(_d || (_d = __template$6(["\n  opacity: ", ";\n  transition: opacity 200ms ease-in;\n\n  @media screen and (prefers-reduced-motion: no-preference) {\n    ", "\n  }\n\n  @media screen and (prefers-reduced-motion: reduce) {\n    background-color: var(--card-skeleton-color-from);\n  }\n"])), _ref10 => {
  let {
    $visible
  } = _ref10;
  return $visible ? 1 : 0;
}, _ref11 => {
  let {
    $animated
  } = _ref11;
  return $animated ? animation : css(_c$1 || (_c$1 = __template$6(["\n            background-color: var(--card-skeleton-color-from);\n          "])));
});
const Root$4 = styled(Box)(responsiveRadiusStyle, skeletonStyle);
const Skeleton = forwardRef(function Skeleton2(props, ref) {
  const {
    animated = false,
    delay,
    radius,
    ...restProps
  } = props;
  const [visible, setVisible] = useState(delay ? false : true);
  useEffect(() => {
    if (!delay) {
      return setVisible(true);
    }
    const timeout = setTimeout(() => {
      setVisible(true);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, [delay]);
  return /* @__PURE__ */jsx(Root$4, {
    ...restProps,
    $animated: animated,
    $radius: useArrayProp(radius),
    $visible: visible,
    ref
  });
});
const Root$3 = styled(Skeleton)(props => {
  const {
    $size,
    $style
  } = props;
  const {
    font,
    media
  } = getTheme_v2(props.theme);
  const fontStyle = font[$style];
  const styles = _responsive(media, $size, sizeIndex => {
    const fontSize = fontStyle.sizes[sizeIndex];
    const capHeight = fontSize.lineHeight - fontSize.ascenderHeight - fontSize.descenderHeight;
    return {
      height: capHeight
    };
  });
  return styles;
});
const TextSkeleton = forwardRef(function TextSkeleton2(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "text"
  });
});
const LabelSkeleton = forwardRef(function TextSkeleton3(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "label"
  });
});
const HeadingSkeleton = forwardRef(function TextSkeleton4(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "heading"
  });
});
const CodeSkeleton = forwardRef(function TextSkeleton5(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "code"
  });
});
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
const CustomButton = styled(Button)(_a$5 || (_a$5 = __template$5(["\n  max-width: 100%;\n"])));
const Tab = forwardRef(function Tab2(props, forwardedRef) {
  const {
    icon,
    id,
    focused,
    fontSize = 1,
    label,
    onClick,
    onFocus,
    padding = 2,
    selected,
    ...restProps
  } = props;
  const elementRef = useRef(null);
  const focusedRef = useRef(false);
  const handleBlur = useCallback(() => {
    focusedRef.current = false;
  }, []);
  const handleFocus = useCallback(event => {
    focusedRef.current = true;
    if (onFocus) onFocus(event);
  }, [onFocus]);
  const ref = useForwardedRef(forwardedRef);
  useEffect(() => {
    if (focused && !focusedRef.current) {
      if (elementRef.current) elementRef.current.focus();
      focusedRef.current = true;
    }
  }, [focused]);
  const setRef = el => {
    elementRef.current = el;
    ref.current = el;
  };
  return /* @__PURE__ */jsx(CustomButton, {
    "data-ui": "Tab",
    ...restProps,
    "aria-selected": selected ? "true" : "false",
    fontSize,
    icon,
    id,
    mode: "bleed",
    onClick,
    onBlur: handleBlur,
    onFocus: handleFocus,
    padding,
    ref: setRef,
    role: "tab",
    selected,
    tabIndex: selected ? 0 : -1,
    text: label,
    type: "button"
  });
});
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
function _isReactElement(node) {
  return Boolean(node);
}
const CustomInline = styled(Inline)(_a$4 || (_a$4 = __template$4(["\n  & > div {\n    display: inline-block;\n    vertical-align: middle;\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n"])));
const TabList = forwardRef(function TabList2(props, ref) {
  const {
    children: childrenProp,
    ...restProps
  } = props;
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const children = useMemo(() => childrenProp.filter(_isReactElement), [childrenProp]);
  const tabs = children.map((child, childIndex) => cloneElement(child, {
    focused: focusedIndex === childIndex,
    key: childIndex,
    onFocus: () => handleTabFocus(childIndex)
  }));
  const numTabs = tabs.length;
  const handleTabFocus = useCallback(tabIdx => {
    setFocusedIndex(tabIdx);
  }, []);
  const handleKeyDown = useCallback(event => {
    if (event.key === "ArrowLeft") {
      setFocusedIndex(prevIndex => (prevIndex + numTabs - 1) % numTabs);
    }
    if (event.key === "ArrowRight") {
      setFocusedIndex(prevIndex => (prevIndex + 1) % numTabs);
    }
  }, [numTabs]);
  return /* @__PURE__ */jsx(CustomInline, {
    "data-ui": "TabList",
    ...restProps,
    onKeyDown: handleKeyDown,
    ref,
    role: "tablist",
    children: tabs
  });
});
const TabPanel = forwardRef(function TabPanel2(props, ref) {
  const {
    flex,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Box, {
    "data-ui": "TabPanel",
    ...restProps,
    flex,
    ref,
    role: "tabpanel",
    tabIndex: props.tabIndex === void 0 ? 0 : props.tabIndex,
    children: props.children
  });
});
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3, _b$2;
const STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
};
const BUTTON_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
};
const ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
};
const Root$2 = styled(Card)(_a$3 || (_a$3 = __template$3(["\n  pointer-events: all;\n  & > * {\n    opacity: var(", ", 1);\n    will-change: opacity;\n  }\n"])), POPOVER_MOTION_CONTENT_OPACITY_PROPERTY);
const TextBox = styled(Flex)(_b$2 || (_b$2 = __template$3(["\n  overflow-x: auto;\n"])));
function Toast(props) {
  const {
    closable,
    description,
    onClose,
    radius = 3,
    title,
    status,
    ...restProps
  } = props;
  const cardTone = status ? STATUS_CARD_TONE[status] : "default";
  const buttonTone = status ? BUTTON_TONE[status] : "default";
  const role = status ? ROLES[status] : "status";
  return /* @__PURE__ */jsx(Root$2, {
    "data-ui": "Toast",
    role,
    ...restProps,
    marginTop: 3,
    radius,
    shadow: 2,
    tone: cardTone,
    children: /* @__PURE__ */jsxs(Flex, {
      align: "flex-start",
      children: [/* @__PURE__ */jsx(TextBox, {
        flex: 1,
        padding: 3,
        children: /* @__PURE__ */jsxs(Stack, {
          space: 3,
          children: [title && /* @__PURE__ */jsx(Text, {
            size: 1,
            weight: "medium",
            children: title
          }), description && /* @__PURE__ */jsx(Text, {
            muted: true,
            size: 1,
            children: description
          })]
        })
      }), closable && /* @__PURE__ */jsx(Box, {
        padding: 1,
        children: /* @__PURE__ */jsx(Button, {
          as: "button",
          icon: CloseIcon,
          mode: "bleed",
          padding: 2,
          tone: buttonTone,
          onClick: onClose,
          style: {
            verticalAlign: "top"
          }
        })
      })]
    })
  });
}
function useMounted() {
  const [mounted, mount] = useReducer(() => true, false);
  useEffect(mount, [mount]);
  return mounted;
}
const key$1 = Symbol.for("@sanity/ui/context/toast");
globalScope[key$1] = globalScope[key$1] || createContext(null);
const ToastContext = globalScope[key$1];
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2, _b$1;
const Root$1 = styled(Layer)(_a$2 || (_a$2 = __template$2(["\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n"])));
const ToastContainer = styled.div(_b$1 || (_b$1 = __template$2(["\n  box-sizing: border-box;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  max-width: 420px;\n  width: 100%;\n"])));
let toastId = 0;
function ToastProvider(props) {
  const {
    children,
    padding = 4,
    paddingX,
    paddingY,
    zOffset
  } = props;
  const [state, _setState] = useState([]);
  const toastsRef = useRef({});
  const push = useCallback(params => {
    const setState = state2 => startTransition(() => _setState(state2));
    const id = params.id || String(toastId++);
    const duration = params.duration || 5e3;
    const dismiss = () => {
      var _a2;
      const timeoutId = (_a2 = toastsRef.current[id]) == null ? void 0 : _a2.timeoutId;
      setState(prevState => {
        const idx = prevState.findIndex(t => t.id === id);
        if (idx > -1) {
          const toasts = prevState.slice(0);
          toasts.splice(idx, 1);
          return toasts;
        }
        return prevState;
      });
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
        delete toastsRef.current[id];
      }
    };
    setState(prevState => {
      return prevState.filter(t => t.id !== id).concat([{
        dismiss,
        id,
        params: {
          ...params,
          duration
        }
      }]);
    });
    if (toastsRef.current[id]) {
      clearTimeout(toastsRef.current[id].timeoutId);
      delete toastsRef.current[id];
    }
    toastsRef.current[id] = {
      timeoutId: setTimeout(dismiss, duration)
    };
    return id;
  }, []);
  useEffect(() => () => {
    for (const {
      timeoutId
    } of Object.values(toastsRef.current)) {
      clearTimeout(timeoutId);
    }
    toastsRef.current = {};
  }, []);
  const value = useMemo(() => ({
    version: 0,
    push
  }), [push]);
  const mounted = useMounted();
  return /* @__PURE__ */jsxs(ToastContext.Provider, {
    value,
    children: [children, mounted && /* @__PURE__ */jsx(Root$1, {
      "data-ui": "ToastProvider",
      zOffset,
      children: /* @__PURE__ */jsx(ToastContainer, {
        children: /* @__PURE__ */jsx(Box, {
          padding,
          paddingX,
          paddingY,
          children: /* @__PURE__ */jsx(AnimatePresence, {
            initial: false,
            children: state.map(_ref12 => {
              let {
                dismiss,
                id,
                params
              } = _ref12;
              return /* @__PURE__ */jsx(motion.div, {
                animate: {
                  opacity: [0, 1, 1],
                  [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [0, 0, 1],
                  y: 0,
                  scale: 1
                },
                exit: {
                  opacity: [1, 1, 0],
                  [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [1, 0, 0],
                  scale: 0.5,
                  transition: {
                    duration: 0.2
                  }
                },
                initial: {
                  opacity: 0,
                  [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
                  y: 32,
                  scale: 0.25,
                  willChange: "transform"
                },
                layout: "position",
                transition: {
                  type: "spring",
                  damping: 30,
                  stiffness: 400
                },
                children: /* @__PURE__ */jsx(Toast, {
                  closable: params.closable,
                  description: params.description,
                  onClose: dismiss,
                  status: params.status,
                  title: params.title
                })
              }, id);
            })
          })
        })
      })
    })]
  });
}
function useToast() {
  const value = useContext(ToastContext);
  if (!value) {
    throw new Error("useToast(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useToast(): the context value is not compatible");
  }
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(0, idx);
  const len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(idx);
  const len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i]) {
      continue;
    }
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem") {
    el.focus();
  }
  if (el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    if (firstChild && firstChild instanceof HTMLElement) {
      firstChild.focus();
    }
  }
}
const key = Symbol.for("@sanity/ui/context/tree");
globalScope[key] = globalScope[key] || createContext(null);
const TreeContext = globalScope[key];
const Tree = memo(forwardRef(function Tree2(props, ref) {
  const {
    children,
    space = 1,
    onFocus,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [focusedElement, setFocusedElement] = useState(null);
  const focusedElementRef = useRef(focusedElement);
  const path = useMemo(() => [], []);
  const [itemElements, setItemElements] = useState([]);
  const [state, setState] = useState({});
  const stateRef = useRef(state);
  useEffect(() => {
    focusedElementRef.current = focusedElement;
  }, [focusedElement]);
  useEffect(() => {
    stateRef.current = state;
  }, [state]);
  const registerItem = useCallback((element, path2, expanded, selected) => {
    setState(s => ({
      ...s,
      [path2]: {
        element,
        expanded
      }
    }));
    if (selected) {
      setFocusedElement(element);
    }
    return () => {
      setState(s => {
        const newState = {
          ...s
        };
        delete newState[path2];
        return newState;
      });
    };
  }, []);
  const setExpanded = useCallback((path2, expanded) => {
    setState(s => {
      const itemState = s[path2];
      if (!itemState) return s;
      return {
        ...s,
        [path2]: {
          ...itemState,
          expanded
        }
      };
    });
  }, []);
  const contextValue = useMemo(() => ({
    version: 0,
    focusedElement: focusedElement || itemElements[0] || null,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }), [focusedElement, itemElements, path, registerItem, setExpanded, space, state]);
  const handleKeyDown = useCallback(event => {
    var _a;
    if (!focusedElementRef.current) return;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (nextEl) {
        _focusItemElement(nextEl);
        setFocusedElement(nextEl);
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (prevEl) {
        _focusItemElement(prevEl);
        setFocusedElement(prevEl);
      }
      return;
    }
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!itemKey) return;
      const itemState = stateRef.current[itemKey];
      if (!itemState) return;
      if (itemState.expanded) {
        setState(s => {
          const itemState2 = s[itemKey];
          if (!itemState2) return s;
          return {
            ...s,
            [itemKey]: {
              ...itemState2,
              expanded: false
            }
          };
        });
      } else {
        const itemPath = itemKey.split("/");
        itemPath.pop();
        const parentKey = itemPath.join("/");
        const parentState = parentKey && stateRef.current[parentKey];
        if (parentState) {
          parentState.element.focus();
          setFocusedElement(parentState.element);
        }
      }
      return;
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!focusedKey) return;
      if (!((_a = stateRef.current[focusedKey]) == null ? void 0 : _a.expanded)) {
        setState(s => {
          const itemState = s[focusedKey];
          if (!itemState) return s;
          return {
            ...s,
            [focusedKey]: {
              ...itemState,
              expanded: true
            }
          };
        });
      }
      return;
    }
  }, [itemElements]);
  const handleFocus = useCallback(event => {
    setFocusedElement(event.target);
    onFocus == null ? void 0 : onFocus(event);
  }, [onFocus]);
  useEffect(() => {
    if (!forwardedRef.current) return;
    const _itemElements = Array.from(forwardedRef.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, [children, forwardedRef]);
  return /* @__PURE__ */jsx(TreeContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */jsx(Stack, {
      as: "ul",
      "data-ui": "Tree",
      ...restProps,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      ref: forwardedRef,
      role: "tree",
      space,
      children
    })
  });
}));
Tree.displayName = "Tree";
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1, _b, _c;
function treeItemRootStyle() {
  return css(_a$1 || (_a$1 = __template$1(["\n    &[role='none'] > [role='treeitem'] {\n      outline: none;\n      cursor: default;\n      border-radius: 3px;\n\n      background-color: var(--card-bg-color);\n      color: var(--treeitem-fg-color);\n\n      &:focus {\n        position: relative;\n      }\n    }\n\n    &[role='treeitem'] {\n      outline: none;\n\n      & > div {\n        cursor: default;\n        border-radius: 3px;\n\n        background-color: var(--card-bg-color);\n        color: var(--treeitem-fg-color);\n      }\n\n      &:focus > div {\n        position: relative;\n      }\n    }\n  "])));
}
function treeItemRootColorStyle(props) {
  const $tone = "default";
  const {
    color
  } = getTheme_v2(props.theme);
  const tone = color.selectable[$tone];
  return css(_b || (_b = __template$1(["\n    &[role='none'] {\n      & > [role='treeitem'] {\n        ", "\n      }\n\n      &[data-selected] > [role='treeitem'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {\n          ", "\n        }\n\n        & > [role='treeitem']:focus {\n          ", "\n        }\n      }\n    }\n\n    &[role='treeitem'] {\n      & > [data-ui='TreeItem__box'] {\n        ", "\n      }\n\n      &[data-selected] > [data-ui='TreeItem__box'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {\n          ", "\n        }\n\n        &:focus > [data-ui='TreeItem__box'] {\n          ", "\n        }\n      }\n    }\n  "])), _cardColorStyle(color, tone.enabled), _cardColorStyle(color, tone.pressed), _cardColorStyle(color, tone.hovered), _cardColorStyle(color, tone.selected), _cardColorStyle(color, tone.enabled), _cardColorStyle(color, tone.pressed), _cardColorStyle(color, tone.hovered), _cardColorStyle(color, tone.selected));
}
function treeItemBoxStyle(props) {
  const {
    $level
  } = props;
  const {
    space
  } = getTheme_v2(props.theme);
  return css(_c || (_c = __template$1(["\n    padding-left: ", ";\n\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])), rem(space[2] * $level));
}
function useTree() {
  const tree = useContext(TreeContext);
  if (!tree) {
    throw new Error("Tree: missing context value");
  }
  return tree;
}
const TreeGroup = memo(function TreeGroup2(props) {
  const {
    children,
    expanded = false,
    ...restProps
  } = props;
  const tree = useTree();
  return /* @__PURE__ */jsx(Stack, {
    as: "ul",
    "data-ui": "TreeGroup",
    ...restProps,
    hidden: !expanded,
    marginTop: tree.space,
    role: "group",
    space: tree.space,
    children
  });
});
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
const Root = memo(styled.li(treeItemRootStyle, treeItemRootColorStyle));
const TreeItemBox = styled(Box).attrs({
  forwardedAs: "a"
})(treeItemBoxStyle);
const ToggleArrowText = styled(Text)(_a || (_a = __template(["\n  & > svg {\n    transition: transform 100ms;\n  }\n"])));
const TreeItem = memo(function TreeItem2(props) {
  const {
    children,
    expanded: expandedProp = false,
    fontSize = 1,
    href,
    icon,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 2,
    selected = false,
    space = 2,
    text,
    weight,
    ...restProps
  } = props;
  const rootRef = useRef(null);
  const treeitemRef = useRef(null);
  const tree = useTree();
  const {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree;
  const _id = useId();
  const id = idProp || _id;
  const itemPath = useMemo(() => path.concat([id || ""]), [id, path]);
  const itemKey = itemPath.join("/");
  const itemState = tree.state[itemKey];
  const focused = tree.focusedElement === rootRef.current;
  const expanded = (itemState == null ? void 0 : itemState.expanded) === void 0 ? expandedProp : (itemState == null ? void 0 : itemState.expanded) || false;
  const tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1;
  const contextValue = useMemo(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]);
  const handleClick = useCallback(event => {
    if (onClick) onClick(event);
    const target = event.target;
    if (target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]'))) {
      event.stopPropagation();
      setExpanded(itemKey, !expanded);
      setFocusedElement(rootRef.current);
    }
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]);
  const handleKeyDown = useCallback(event => {
    if (focused && event.key === "Enter") {
      const el = treeitemRef.current || rootRef.current;
      el == null ? void 0 : el.click();
    }
  }, [focused]);
  useEffect(() => {
    if (!rootRef.current) return;
    return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = /* @__PURE__ */jsxs(Flex, {
    padding,
    children: [/* @__PURE__ */jsxs(Box, {
      marginRight: space,
      style: {
        visibility: icon || children ? "visible" : "hidden",
        pointerEvents: "none"
      },
      children: [icon && /* @__PURE__ */jsx(Text, {
        muted,
        size: fontSize,
        weight,
        children: createElement(icon)
      }), !icon && /* @__PURE__ */jsx(ToggleArrowText, {
        muted,
        size: fontSize,
        weight,
        children: /* @__PURE__ */jsx(ToggleArrowRightIcon, {
          style: {
            transform: expanded ? "rotate(90deg)" : void 0
          }
        })
      })]
    }), /* @__PURE__ */jsx(Box, {
      flex: 1,
      children: /* @__PURE__ */jsx(Text, {
        muted,
        size: fontSize,
        textOverflow: "ellipsis",
        weight,
        children: text
      })
    })]
  });
  if (href) {
    return /* @__PURE__ */jsxs(Root, {
      "data-selected": selected ? "" : void 0,
      "data-tree-id": id,
      "data-tree-key": itemKey,
      "data-ui": "TreeItem",
      ...restProps,
      onClick: handleClick,
      ref: rootRef,
      role: "none",
      children: [/* @__PURE__ */jsx(TreeItemBox, {
        $level: tree.level,
        "aria-expanded": expanded,
        as: linkAs,
        "data-ui": "TreeItem__box",
        href,
        ref: treeitemRef,
        role: "treeitem",
        tabIndex,
        children: content
      }), /* @__PURE__ */jsx(TreeContext.Provider, {
        value: contextValue,
        children: children && /* @__PURE__ */jsx(TreeGroup, {
          hidden: !expanded,
          children
        })
      })]
    });
  }
  return /* @__PURE__ */jsxs(Root, {
    "data-selected": selected ? "" : void 0,
    "data-ui": "TreeItem",
    "data-tree-id": id,
    "data-tree-key": itemKey,
    ...restProps,
    "aria-expanded": expanded,
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    ref: rootRef,
    role: "treeitem",
    tabIndex,
    children: [/* @__PURE__ */jsx(TreeItemBox, {
      $level: tree.level,
      as: "div",
      "data-ui": "TreeItem__box",
      children: content
    }), /* @__PURE__ */jsx(TreeContext.Provider, {
      value: contextValue,
      children: children && /* @__PURE__ */jsx(TreeGroup, {
        expanded,
        children
      })
    })]
  });
});
export { Arrow, Autocomplete, Avatar, AvatarCounter, AvatarStack, Badge, BoundaryElementProvider, Box, Breadcrumbs, Button, Card, Checkbox, Code, CodeSkeleton, ConditionalWrapper, Container, Dialog, DialogContext, DialogProvider, ElementQuery, ErrorBoundary, Flex, Grid, Heading, HeadingSkeleton, Hotkeys, Inline, KBD, Label, LabelSkeleton, Layer, LayerProvider, Menu, MenuButton, MenuDivider, MenuGroup, MenuItem, Popover, Portal, PortalProvider, Radio, Select, Skeleton, Spinner, SrOnly, Stack, Switch, Tab, TabList, TabPanel, Text, TextArea, TextInput, TextSkeleton, ThemeColorProvider, ThemeProvider, Toast, ToastProvider, Tooltip, TooltipDelayGroupContext, TooltipDelayGroupProvider, Tree, TreeItem, VirtualList, _ResizeObserver, _elementSizeObserver, _fillCSSObject, _getArrayProp, _getResponsiveSpace, _hasFocus, _isEnterToClickElement, _isScrollable, _raf, _raf2, _responsive, attemptFocus, containsOrEqualsElement, createColorTheme, focusFirstDescendant, focusLastDescendant, hexToRgb, hslToRgb, isFocusable, isHTMLAnchorElement, isHTMLButtonElement, isHTMLElement, isHTMLInputElement, isHTMLSelectElement, isHTMLTextAreaElement, multiply, parseColor, rem, responsiveCodeFontStyle, responsiveHeadingFont, responsiveLabelFont, responsiveTextAlignStyle, responsiveTextFont, rgbToHex, rgbToHsl, rgba, screen, studioTheme, useArrayProp, useBoundaryElement, useClickOutside, useCustomValidity, useDialog, useElementRect, useElementSize, useForwardedRef, useGlobalKeyDown, useLayer, useMediaIndex, usePortal, usePrefersDark, usePrefersReducedMotion, useRootTheme, useTheme, useTheme_v2, useToast, useTooltipDelayGroup, useTree };
//# sourceMappingURL=index.esm.js.map
