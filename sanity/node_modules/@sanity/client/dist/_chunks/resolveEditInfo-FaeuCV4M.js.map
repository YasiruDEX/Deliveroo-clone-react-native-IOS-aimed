{"version":3,"file":"resolveEditInfo-FaeuCV4M.js","sources":["../../src/csm/studioPath.ts","../../src/csm/getPublishedId.ts","../../src/csm/jsonPath.ts","../../src/csm/resolveMapping.ts","../../src/csm/isArray.ts","../../src/csm/isRecord.ts","../../src/csm/walkMap.ts","../../src/csm/createEditUrl.ts","../../src/csm/resolveEditInfo.ts"],"sourcesContent":["/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n","export const DRAFTS_PREFIX = 'drafts.'\n\n/** @internal */\nexport function getPublishedId(id: string): string {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length)\n  }\n\n  return id\n}\n","import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n","import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n","/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n","/** @internal */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n","import {isArray} from './isArray'\nimport {isRecord} from './isRecord'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n","import {getPublishedId} from './getPublishedId'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  // eslint-disable-next-line no-warning-comments\n  // @TODO allow passing draft prefixed IDs, to better open the right perspective mode\n  const id = getPublishedId(_id)\n  const stringifiedPath = Array.isArray(path)\n    ? studioPath.toString(jsonPathToStudioPath(path))\n    : path\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  const routerParams = [\n    'mode=presentation',\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`,\n  ]\n  if (tool) {\n    routerParams.push(`tool=${tool}`)\n  }\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n","import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type} = sourceDoc\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n"],"names":["rePropName","reKeySegment","reIndexTuple","isIndexSegment","segment","test","isKeySegment","trim","isIndexTuple","Array","isArray","length","from","to","get","obj","path","defaultVal","select","fromString","Error","acc","i","find","item","_key","toString","reduce","target","segmentType","concat","separator","stringify","segments","match","map","parsePathSegment","parseIndexSegment","parseKeySegment","parseIndexTupleSegment","Number","replace","split","seg","DRAFTS_PREFIX","getPublishedId","id","startsWith","slice","ESCAPE","UNESCAPE","jsonPath","escapedKey","_index","join","parseJsonPath","parsed","parseRe","exec","key","m","push","parseInt","jsonPathToStudioPath","JSON","studioPathToJsonPath","parsedPath","studioPath.fromString","isContentSourceMapParsedPathKeyedSegment","jsonPathToMappingPath","resolveMapping","resultPath","csm","mappings","resultMappingPath","mapping","matchedPath","pathSuffix","Object","entries","filter","_ref","sort","_ref2","_ref3","key1","key2","substring","value","isRecord","walkMap","mappingFn","arguments","undefined","v","idx","fromEntries","_ref4","k","createEditUrl","options","baseUrl","workspace","_workspace","tool","_tool","_id","type","endsWith","stringifiedPath","studioPath.toString","searchParams","URLSearchParams","set","routerParams","resolveEditInfo","resultSourceMap","source","sourceDoc","documents","document","sourcePath","paths","resolveStudioBaseRoute","studioUrl","_type"],"mappings":"AAYA,MAAMA,UACJ,GAAA,kGAAA;AAEK,MAAMC,YAAe,GAAA,0BAAA;AAC5B,MAAMC,YAAe,GAAA,WAAA;AAGd,SAASC,eAAeC,OAAyC,EAAA;EAC/D,OAAA,OAAOA,YAAY,QAAa,IAAA,OAAOA,YAAY,QAAY,IAAA,WAAA,CAAYC,KAAKD,OAAO,CAAA;AAChG;AAGO,SAASE,aAAaF,OAA+C,EAAA;EACtE,IAAA,OAAOA,YAAY,QAAU,EAAA;IAC/B,OAAOH,YAAa,CAAAI,IAAA,CAAKD,OAAQ,CAAAG,IAAA,CAAM,CAAA,CAAA;EACzC;EAEO,OAAA,OAAOH,OAAY,KAAA,QAAA,IAAY,MAAU,IAAAA,OAAA;AAClD;AAGO,SAASI,aAAaJ,OAA6C,EAAA;EACxE,IAAI,OAAOA,OAAY,KAAA,QAAA,IAAYF,YAAa,CAAAG,IAAA,CAAKD,OAAO,CAAG,EAAA;IACtD,OAAA,IAAA;EACT;EAEA,IAAI,CAACK,KAAM,CAAAC,OAAA,CAAQN,OAAO,CAAK,IAAAA,OAAA,CAAQO,WAAW,CAAG,EAAA;IAC5C,OAAA,KAAA;EACT;EAEM,MAAA,CAACC,IAAM,EAAAC,EAAE,CAAI,GAAAT,OAAA;EACX,OAAA,CAAA,OAAOQ,SAAS,QAAY,IAAAA,IAAA,KAAS,QAAQ,OAAOC,EAAA,KAAO,YAAYA,EAAO,KAAA,EAAA,CAAA;AACxF;AAGgB,SAAAC,GAAAA,CACdC,GACA,EAAAC,IAAA,EACAC,UAC4B,EAAA;EAC5B,MAAMC,SAAS,OAAOF,IAAA,KAAS,QAAW,GAAAG,UAAA,CAAWH,IAAI,CAAI,GAAAA,IAAA;EAC7D,IAAI,CAACP,KAAA,CAAMC,OAAQ,CAAAQ,MAAM,CAAG,EAAA;IACpB,MAAA,IAAIE,MAAM,mCAAmC,CAAA;EACrD;EAEA,IAAIC,GAA2B,GAAAN,GAAA;EAC/B,KAAA,IAASO,CAAI,GAAA,CAAA,EAAGA,CAAI,GAAAJ,MAAA,CAAOP,QAAQW,CAAK,EAAA,EAAA;IAChC,MAAAlB,OAAA,GAAUc,OAAOI,CAAC,CAAA;IACpB,IAAAnB,cAAA,CAAeC,OAAO,CAAG,EAAA;MAC3B,IAAI,CAACK,KAAA,CAAMC,OAAQ,CAAAW,GAAG,CAAG,EAAA;QAChB,OAAAJ,UAAA;MACT;MAEAI,GAAA,GAAMA,IAAIjB,OAAO,CAAA;IACnB;IAEI,IAAAE,YAAA,CAAaF,OAAO,CAAG,EAAA;MACzB,IAAI,CAACK,KAAA,CAAMC,OAAQ,CAAAW,GAAG,CAAG,EAAA;QAChB,OAAAJ,UAAA;MACT;MAEAI,GAAA,GAAMA,IAAIE,IAAK,CAACC,QAASA,IAAK,CAAAC,IAAA,KAASrB,QAAQqB,IAAI,CAAA;IACrD;IAEI,IAAA,OAAOrB,YAAY,QAAU,EAAA;MAC/BiB,GAAA,GACE,OAAOA,GAAQ,KAAA,QAAA,IAAYA,QAAQ,IAC7B,GAAAA,GAAA,CAAgCjB,OAAO,CACzC,GAAA,KAAA,CAAA;IACR;IAEI,IAAA,OAAOiB,QAAQ,WAAa,EAAA;MACvB,OAAAJ,UAAA;IACT;EACF;EAEO,OAAAI,GAAA;AACT;AAGO,SAASK,SAASV,IAAoB,EAAA;EAC3C,IAAI,CAACP,KAAA,CAAMC,OAAQ,CAAAM,IAAI,CAAG,EAAA;IAClB,MAAA,IAAII,MAAM,sBAAsB,CAAA;EACxC;EAEA,OAAOJ,IAAK,CAAAW,MAAA,CAAe,CAACC,MAAA,EAAQxB,SAASkB,CAAM,KAAA;IACjD,MAAMO,cAAc,OAAOzB,OAAA;IAC3B,IAAIyB,gBAAgB,QAAU,EAAA;MACrB,OAAA,EAAA,CAAGC,MAAM,CAAAF,MAAA,EAAA,GAAA,CAAA,CAAIE,MAAO,CAAA1B,OAAA,EAAA,GAAA,CAAA;IAC7B;IAEA,IAAIyB,gBAAgB,QAAU,EAAA;MACtB,MAAAE,SAAA,GAAYT,CAAM,KAAA,CAAA,GAAI,EAAK,GAAA,GAAA;MAC1B,OAAA,EAAA,CAAGQ,eAASA,MAAY,CAAAC,SAAA,CAAA,CAAAD,MAAA,CAAA1B,OAAA,CAAA;IACjC;IAEA,IAAIE,YAAa,CAAAF,OAAO,CAAK,IAAAA,OAAA,CAAQqB,IAAM,EAAA;MACzC,OAAO,EAAG,CAAAK,MAAA,CAAAF,MAAA,EAAM,UAAW,CAAA,CAAAE,MAAA,CAAA1B,OAAA,CAAQqB,IAAI,EAAA,IAAA,CAAA;IACzC;IAEI,IAAAhB,KAAA,CAAMC,OAAQ,CAAAN,OAAO,CAAG,EAAA;MACpB,MAAA,CAACQ,IAAM,EAAAC,EAAE,CAAI,GAAAT,OAAA;MACnB,OAAO,EAAG,CAAA0B,MAAA,CAAAF,MAAA,EAAM,GAAI,CAAA,CAAAE,MAAA,CAAAlB,IAAA,EAAI,KAAIkB,MAAE,CAAAjB,EAAA,EAAA,GAAA,CAAA;IAChC;IAEA,MAAM,IAAIO,KAAM,CAAA,4BAAA,CAA8BU,YAAKE,SAAU,CAAA5B,OAAO,GAAC,GAAI,CAAA,CAAA;KACxE,EAAE,CAAA;AACP;AAGO,SAASe,WAAWH,IAAoB,EAAA;EACzC,IAAA,OAAOA,SAAS,QAAU,EAAA;IACtB,MAAA,IAAII,MAAM,sBAAsB,CAAA;EACxC;EAEM,MAAAa,QAAA,GAAWjB,IAAK,CAAAkB,KAAA,CAAMlC,UAAU,CAAA;EACtC,IAAI,CAACiC,QAAU,EAAA;IACP,MAAA,IAAIb,MAAM,qBAAqB,CAAA;EACvC;EAEO,OAAAa,QAAA,CAASE,IAAIC,gBAAgB,CAAA;AACtC;AAEA,SAASA,iBAAiBhC,OAA8B,EAAA;EAClD,IAAAD,cAAA,CAAeC,OAAO,CAAG,EAAA;IAC3B,OAAOiC,kBAAkBjC,OAAO,CAAA;EAClC;EAEI,IAAAE,YAAA,CAAaF,OAAO,CAAG,EAAA;IACzB,OAAOkC,gBAAgBlC,OAAO,CAAA;EAChC;EAEI,IAAAI,YAAA,CAAaJ,OAAO,CAAG,EAAA;IACzB,OAAOmC,uBAAuBnC,OAAO,CAAA;EACvC;EAEO,OAAAA,OAAA;AACT;AAEA,SAASiC,kBAAkBjC,OAA8B,EAAA;EACvD,OAAOoC,MAAO,CAAApC,OAAA,CAAQqC,OAAQ,CAAA,QAAA,EAAU,EAAE,CAAC,CAAA;AAC7C;AAEA,SAASH,gBAAgBlC,OAA+B,EAAA;EAChD,MAAA6B,QAAA,GAAW7B,OAAQ,CAAA8B,KAAA,CAAMjC,YAAY,CAAA;EAC3C,OAAO;IAACwB,IAAA,EAAMQ,QAAU,CAAA,CAAC;EAAC,CAAA;AAC5B;AAEA,SAASM,uBAAuBnC,OAA6B,EAAA;EAC3D,MAAM,CAACQ,IAAM,EAAAC,EAAE,CAAI,GAAAT,OAAA,CAAQsC,MAAM,GAAG,CAAA,CAAEP,GAAI,CAACQ,OAASA,GAAQ,KAAA,EAAA,GAAKA,GAAM,GAAAH,MAAA,CAAOG,GAAG,CAAE,CAAA;EAC5E,OAAA,CAAC/B,MAAMC,EAAE,CAAA;AAClB;;;;;;;;;;;ACnKO,MAAM+B,aAAgB,GAAA,SAAA;AAGtB,SAASC,eAAeC,EAAoB,EAAA;EAC7C,IAAAA,EAAA,CAAGC,UAAW,CAAAH,aAAa,CAAG,EAAA;IACzB,OAAAE,EAAA,CAAGE,KAAM,CAAAJ,aAAA,CAAcjC,MAAM,CAAA;EACtC;EAEO,OAAAmC,EAAA;AACT;ACDA,MAAMG,MAAiC,GAAA;EACrC,IAAM,EAAA,KAAA;EACN,IAAM,EAAA,KAAA;EACN,IAAM,EAAA,KAAA;EACN,GAAM,EAAA,KAAA;EACN,GAAK,EAAA,KAAA;EACL,IAAM,EAAA;AACR,CAAA;AAEA,MAAMC,QAAmC,GAAA;EACvC,KAAO,EAAA,IAAA;EACP,KAAO,EAAA,IAAA;EACP,KAAO,EAAA,IAAA;EACP,KAAO,EAAA,GAAA;EACP,KAAO,EAAA,GAAA;EACP,MAAQ,EAAA;AACV,CAAA;AAKO,SAASC,SAASnC,IAAiE,EAAA;EACxF,OAAO,GAAI,CAAAc,MAAA,CAAAd,IAAA,CACRmB,GAAI,CAAC/B,OAAY,IAAA;IACZ,IAAA,OAAOA,YAAY,QAAU,EAAA;MAC/B,MAAMgD,UAAa,GAAAhD,OAAA,CAAQqC,OAAQ,CAAA,gBAAA,EAAmBP,KAAU,IAAA;QAC9D,OAAOe,OAAOf,KAAK,CAAA;MAAA,CACpB,CAAA;MACD,OAAO,KAAKJ,MAAU,CAAAsB,UAAA,EAAA,IAAA,CAAA;IACxB;IAEI,IAAA,OAAOhD,YAAY,QAAU,EAAA;MAC/B,OAAO,IAAI0B,MAAO,CAAA1B,OAAA,EAAA,GAAA,CAAA;IACpB;IAEI,IAAAA,OAAA,CAAQqB,SAAS,EAAI,EAAA;MACvB,MAAM2B,aAAahD,OAAQ,CAAAqB,IAAA,CAAKgB,OAAQ,CAAA,QAAA,EAAWP,KAAU,IAAA;QAC3D,OAAOe,OAAOf,KAAK,CAAA;MAAA,CACpB,CAAA;MACD,OAAO,eAAeJ,MAAU,CAAAsB,UAAA,EAAA,KAAA,CAAA;IAClC;IAEO,OAAA,GAAA,CAAItB,eAAQuB,MAAM,EAAA,GAAA,CAAA;EAAA,CAC1B,CACA,CAAAC,IAAA,CAAK,EAAE,CAAA,CAAA;AACZ;AAKO,SAASC,cAAcvC,IAAiE,EAAA;EAC7F,MAAMwC,SAAqC,EAAC;EAE5C,MAAMC,OAAU,GAAA,mDAAA;EACZ,IAAAvB,KAAA;EAEJ,OAAA,CAAQA,KAAQ,GAAAuB,OAAA,CAAQC,IAAK,CAAA1C,IAAI,OAAO,IAAM,EAAA;IACxC,IAAAkB,KAAA,CAAM,CAAC,CAAA,KAAM,KAAW,CAAA,EAAA;MAC1B,MAAMyB,MAAMzB,KAAM,CAAA,CAAC,EAAEO,OAAQ,CAAA,mBAAA,EAAsBmB,CAAM,IAAA;QACvD,OAAOV,SAASU,CAAC,CAAA;MAAA,CAClB,CAAA;MAEDJ,MAAA,CAAOK,KAAKF,GAAG,CAAA;MACf;IACF;IAEI,IAAAzB,KAAA,CAAM,CAAC,CAAA,KAAM,KAAW,CAAA,EAAA;MAC1BsB,MAAA,CAAOK,KAAKC,QAAS,CAAA5B,KAAA,CAAM,CAAC,CAAA,EAAG,EAAE,CAAC,CAAA;MAClC;IACF;IAEI,IAAAA,KAAA,CAAM,CAAC,CAAA,KAAM,KAAW,CAAA,EAAA;MAC1B,MAAMT,OAAOS,KAAM,CAAA,CAAC,EAAEO,OAAQ,CAAA,UAAA,EAAamB,CAAM,IAAA;QAC/C,OAAOV,SAASU,CAAC,CAAA;MAAA,CAClB,CAAA;MAEDJ,MAAA,CAAOK,IAAK,CAAA;QACVpC,IAAA;QACA4B,MAAQ,EAAA,CAAA;MAAA,CACT,CAAA;MACD;IACF;EACF;EAEO,OAAAG,MAAA;AACT;AAKO,SAASO,qBAAqB/C,IAAwC,EAAA;EACpE,OAAAA,IAAA,CAAKmB,GAAI,CAAC/B,OAAY,IAAA;IACvB,IAAA,OAAOA,YAAY,QAAU,EAAA;MACxB,OAAAA,OAAA;IACT;IAEI,IAAA,OAAOA,YAAY,QAAU,EAAA;MACxB,OAAAA,OAAA;IACT;IAEI,IAAAA,OAAA,CAAQqB,SAAS,EAAI,EAAA;MAChB,OAAA;QAACA,IAAM,EAAArB,OAAA,CAAQqB;OAAI;IAC5B;IAEI,IAAArB,OAAA,CAAQiD,WAAW,CAAI,CAAA,EAAA;MACzB,OAAOjD,OAAQ,CAAAiD,MAAA;IACjB;IAEA,MAAM,IAAIjC,KAAM,CAAA,kBAAA,CAAmBU,MAAK,CAAAkC,IAAA,CAAAhC,SAAA,CAAU5B,OAAO,CAAG,CAAA,CAAA;EAAA,CAC7D,CAAA;AACH;AAKO,SAAS6D,qBAAqBjD,IAAiD,EAAA;EACpF,MAAMkD,aAAa,OAAOlD,IAAA,KAAS,WAAWmD,UAAW,CAAWnD,IAAI,CAAI,GAAAA,IAAA;EAErE,OAAAkD,UAAA,CAAW/B,GAAI,CAAC/B,OAAY,IAAA;IAC7B,IAAA,OAAOA,YAAY,QAAU,EAAA;MACxB,OAAAA,OAAA;IACT;IAEI,IAAA,OAAOA,YAAY,QAAU,EAAA;MACxB,OAAAA,OAAA;IACT;IAEI,IAAAK,KAAA,CAAMC,OAAQ,CAAAN,OAAO,CAAG,EAAA;MAC1B,MAAM,IAAIgB,KAAM,CAAA,uCAAA,CAAwCU,MAAK,CAAAkC,IAAA,CAAAhC,SAAA,CAAU5B,OAAO,CAAG,CAAA,CAAA;IACnF;IAEI,IAAAgE,wCAAA,CAAyChE,OAAO,CAAG,EAAA;MAC9C,OAAAA,OAAA;IACT;IAEA,IAAIA,QAAQqB,IAAM,EAAA;MAChB,OAAO;QAACA,IAAA,EAAMrB,OAAQ,CAAAqB,IAAA;QAAM4B,QAAQ,CAAE;OAAA;IACxC;IAEA,MAAM,IAAIjC,KAAM,CAAA,kBAAA,CAAmBU,MAAK,CAAAkC,IAAA,CAAAhC,SAAA,CAAU5B,OAAO,CAAG,CAAA,CAAA;EAAA,CAC7D,CAAA;AACH;AAEA,SAASgE,yCACPhE,OACmD,EAAA;EACnD,OAAO,OAAOA,OAAA,KAAY,QAAY,IAAA,MAAA,IAAUA,WAAW,QAAY,IAAAA,OAAA;AACzE;AAKO,SAASiE,sBAAsBrD,IAAuD,EAAA;EACpF,OAAAA,IAAA,CAAKmB,GAAI,CAAC/B,OAAY,IAAA;IACvB,IAAA,OAAOA,YAAY,QAAU,EAAA;MACxB,OAAAA,OAAA;IACT;IAEI,IAAA,OAAOA,YAAY,QAAU,EAAA;MACxB,OAAAA,OAAA;IACT;IAEI,IAAAA,OAAA,CAAQiD,WAAW,CAAI,CAAA,EAAA;MACzB,OAAOjD,OAAQ,CAAAiD,MAAA;IACjB;IAEA,MAAM,IAAIjC,KAAM,CAAA,kBAAA,CAAmBU,MAAK,CAAAkC,IAAA,CAAAhC,SAAA,CAAU5B,OAAO,CAAG,CAAA,CAAA;EAAA,CAC7D,CAAA;AACH;AC1KgB,SAAAkE,cAAAA,CACdC,YACAC,GAOY,EAAA;EACR,IAAA,EAACA,2BAAKC,QAAU,CAAA,EAAA;IACX,OAAA,KAAA,CAAA;EACT;EACA,MAAMC,iBAAoB,GAAAvB,QAAA,CAASkB,qBAAsB,CAAAE,UAAU,CAAC,CAAA;EAEpE,IAAIC,GAAI,CAAAC,QAAA,CAASC,iBAAiB,CAAA,KAAM,KAAW,CAAA,EAAA;IAC1C,OAAA;MACLC,OAAA,EAASH,GAAI,CAAAC,QAAA,CAASC,iBAAiB,CAAA;MACvCE,WAAa,EAAAF,iBAAA;MACbG,UAAY,EAAA;IAAA,CACd;EACF;EAEM,MAAAJ,QAAA,GAAWK,MAAO,CAAAC,OAAA,CAAQP,GAAI,CAAAC,QAAQ,CACzC,CAAAO,MAAA,CAAOC,IAAA;IAAA,IAAC,CAACtB,GAAG,CAAA,GAAAsB,IAAA;IAAA,OAAMP,iBAAkB,CAAA3B,UAAA,CAAWY,GAAG,CAAC;EAAA,EACnD,CAAAuB,IAAA,CAAK,CAAAC,KAAA,EAAAC,KAAA;IAAA,IAAC,CAACC,IAAI,CAAA,GAAAF,KAAA;IAAA,IAAG,CAACG,IAAI,CAAM,GAAAF,KAAA;IAAA,OAAAE,IAAA,CAAK3E,MAAS,GAAA0E,IAAA,CAAK1E,MAAM;EAAA,EAAA;EAEjD,IAAA8D,QAAA,CAAS9D,UAAU,CAAG,EAAA;IACjB,OAAA,KAAA,CAAA;EACT;EAEA,MAAM,CAACiE,WAAA,EAAaD,OAAO,CAAA,GAAIF,SAAS,CAAC,CAAA;EACzC,MAAMI,UAAa,GAAAH,iBAAA,CAAkBa,SAAU,CAAAX,WAAA,CAAYjE,MAAM,CAAA;EAC1D,OAAA;IAACgE,OAAS;IAAAC,WAAA;IAAaC;GAAU;AAC1C;ACvCO,SAASnE,QAAQ8E,KAAyC,EAAA;EAC/D,OAAOA,KAAU,KAAA,IAAA,IAAQ/E,KAAM,CAAAC,OAAA,CAAQ8E,KAAK,CAAA;AAC9C;ACFO,SAASC,SAASD,KAAkD,EAAA;EAClE,OAAA,OAAOA,KAAU,KAAA,QAAA,IAAYA,KAAU,KAAA,IAAA;AAChD;ACKO,SAASE,OACdA,CAAAF,KAAA,EACAG,SACA,EACS;EAAA,IADT3E,IAAA,GAAA4E,SAAA,CAAAjF,MAAA,QAAAiF,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAmC,EAC1B;EACL,IAAAlF,OAAA,CAAQ8E,KAAK,CAAG,EAAA;IAClB,OAAOA,KAAM,CAAArD,GAAA,CAAI,CAAC2D,CAAA,EAAGC,GAAQ,KAAA;MACvB,IAAAN,QAAA,CAASK,CAAC,CAAG,EAAA;QACT,MAAArE,IAAA,GAAOqE,EAAE,MAAM,CAAA;QACjB,IAAA,OAAOrE,SAAS,QAAU,EAAA;UACrB,OAAAiE,OAAA,CAAQI,CAAG,EAAAH,SAAA,EAAW3E,IAAK,CAAAc,MAAA,CAAO;YAACL,IAAM;YAAA4B,MAAA,EAAQ0C;UAAI,CAAA,CAAC,CAAA;QAC/D;MACF;MAEA,OAAOL,QAAQI,CAAG,EAAAH,SAAA,EAAW3E,IAAK,CAAAc,MAAA,CAAOiE,GAAG,CAAC,CAAA;IAAA,CAC9C,CAAA;EACH;EAEI,IAAAN,QAAA,CAASD,KAAK,CAAG,EAAA;IACnB,OAAOV,MAAO,CAAAkB,WAAA,CACZlB,MAAA,CAAOC,QAAQS,KAAK,CAAA,CAAErD,IAAI8D,KAAA;MAAA,IAAC,CAACC,GAAGJ,CAAC,CAAA,GAAAG,KAAA;MAAA,OAAM,CAACC,CAAG,EAAAR,OAAA,CAAQI,GAAGH,SAAW,EAAA3E,IAAA,CAAKc,OAAOoE,CAAC,CAAC,CAAC,CAAC;IAAA,EAAA,CAClF;EACF;EAEO,OAAAP,SAAA,CAAUH,OAAOxE,IAAI,CAAA;AAC9B;AC3BO,SAASmF,cAAcC,OAAmE,EAAA;EACzF,MAAA;IACJC,OAAA;IACAC,WAAWC,UAAa,GAAA,SAAA;IACxBC,MAAMC,KAAQ,GAAA,SAAA;IACd3D,EAAI,EAAA4D,GAAA;IACJC,IAAA;IACA3F;EACE,CAAA,GAAAoF,OAAA;EAEJ,IAAI,CAACC,OAAS,EAAA;IACN,MAAA,IAAIjF,MAAM,qBAAqB,CAAA;EACvC;EACA,IAAI,CAACJ,IAAM,EAAA;IACH,MAAA,IAAII,MAAM,kBAAkB,CAAA;EACpC;EACA,IAAI,CAACsF,GAAK,EAAA;IACF,MAAA,IAAItF,MAAM,gBAAgB,CAAA;EAClC;EACA,IAAIiF,OAAY,KAAA,GAAA,IAAOA,OAAQ,CAAAO,QAAA,CAAS,GAAG,CAAG,EAAA;IACtC,MAAA,IAAIxF,MAAM,mCAAmC,CAAA;EACrD;EAEM,MAAAkF,SAAA,GAAYC,UAAe,KAAA,SAAA,GAAY,KAAY,CAAA,GAAAA,UAAA;EACnD,MAAAC,IAAA,GAAOC,KAAU,KAAA,SAAA,GAAY,KAAY,CAAA,GAAAA,KAAA;EAGzC,MAAA3D,EAAA,GAAKD,eAAe6D,GAAG,CAAA;EACvB,MAAAG,eAAA,GAAkBpG,KAAM,CAAAC,OAAA,CAAQM,IAAI,CAAA,GACtC8F,QAAoB,CAAA/C,oBAAA,CAAqB/C,IAAI,CAAC,CAC9C,GAAAA,IAAA;EAIE,MAAA+F,YAAA,GAAe,IAAIC,eAAgB,CAAA;IACvCX,OAAA;IACAvD,EAAA;IACA6D,IAAA;IACA3F,IAAM,EAAA6F;EAAA,CACP,CAAA;EACD,IAAIP,SAAW,EAAA;IACAS,YAAA,CAAAE,GAAA,CAAI,aAAaX,SAAS,CAAA;EACzC;EACA,IAAIE,IAAM,EAAA;IACKO,YAAA,CAAAE,GAAA,CAAI,QAAQT,IAAI,CAAA;EAC/B;EAEA,MAAMvE,QAAW,GAAA,CAACoE,OAAY,KAAA,GAAA,GAAM,KAAKA,OAAO,CAAA;EAChD,IAAIC,SAAW,EAAA;IACbrE,QAAA,CAAS4B,KAAKyC,SAAS,CAAA;EACzB;EACA,MAAMY,YAAe,GAAA,CACnB,mBAAA,EACA,KAAM,CAAApF,MAAA,CAAAgB,EAAA,CAAA,EACN,OAAQ,CAAAhB,MAAA,CAAA6E,IAAA,CAAA,EACR,OAAA,CAAQ7E,0BAAmB+E,eAAe,CAAA,CAAA,CAC5C;EACA,IAAIL,IAAM,EAAA;IACKU,YAAA,CAAArD,IAAA,CAAK,QAAQ/B,MAAM,CAAA0E,IAAA,CAAA,CAAA;EAClC;EACSvE,QAAA,CAAA4B,IAAA,CAAK,UAAU,MAAQ,EAAA,EAAA,CAAG/B,oBAAawB,IAAK,CAAA,GAAG,CAAC,EAAA,GAAA,CAAA,CAAIxB,MAAc,CAAAiF,YAAA,CAAA,CAAA;EACpE,OAAA9E,QAAA,CAASqB,KAAK,GAAG,CAAA;AAC1B;ACzDO,SAAS6D,gBAAgBf,OAAmE,EAAA;EACjG,MAAM;IAACgB,eAAA,EAAiB5C,GAAK;IAAAD;EAAA,CAAc,GAAA6B,OAAA;EACrC,MAAA;IAACzB;IAASE;EAAU,CAAA,GAAIP,eAAeC,UAAY,EAAAC,GAAG,KAAK,EAAC;EAElE,IAAI,CAACG,OAAS,EAAA;IAEL,OAAA,KAAA,CAAA;EACT;EAEI,IAAAA,OAAA,CAAQ0C,MAAO,CAAAV,IAAA,KAAS,SAAW,EAAA;IAC9B,OAAA,KAAA,CAAA;EACT;EAEI,IAAAhC,OAAA,CAAQ0C,MAAO,CAAAV,IAAA,KAAS,SAAW,EAAA;IAC9B,OAAA,KAAA,CAAA;EACT;EAEA,MAAMW,SAAY,GAAA9C,GAAA,CAAI+C,SAAU,CAAA5C,OAAA,CAAQ0C,OAAOG,QAAQ,CAAA;EACvD,MAAMC,UAAa,GAAAjD,GAAA,CAAIkD,KAAM,CAAA/C,OAAA,CAAQ0C,OAAOrG,IAAI,CAAA;EAEhD,IAAIsG,aAAaG,UAAY,EAAA;IAC3B,MAAM;MAACpB,OAAA;MAASC,SAAW;MAAAE;IAAQ,CAAA,GAAAmB,sBAAA,CACjC,OAAOvB,QAAQwB,SAAc,KAAA,UAAA,GAAaxB,QAAQwB,SAAU,CAAAN,SAAS,IAAIlB,OAAQ,CAAAwB,SAAA,CACnF;IACA,IAAI,CAACvB,OAAA,EAAgB,OAAA,KAAA,CAAA;IACf,MAAA;MAACK,GAAK;MAAAmB;IAAS,CAAA,GAAAP,SAAA;IACd,OAAA;MACLjB,OAAA;MACAC,SAAA;MACAE,IAAA;MACA1D,EAAI,EAAA4D,GAAA;MACJC,IAAM,EAAAkB,KAAA;MACN7G,IAAA,EAAMuC,aAAc,CAAAkE,UAAA,GAAa5C,UAAU;IAAA,CAC7C;EACF;EAEO,OAAA,KAAA,CAAA;AACT;AAGO,SAAS8C,uBAAuBC,SAAuC,EAAA;EAC5E,IAAIvB,OAAyB,GAAA,OAAOuB,SAAc,KAAA,QAAA,GAAWA,YAAYA,SAAU,CAAAvB,OAAA;EACnF,IAAIA,YAAY,GAAK,EAAA;IACTA,OAAA,GAAAA,OAAA,CAAQ5D,OAAQ,CAAA,KAAA,EAAO,EAAE,CAAA;EACrC;EACI,IAAA,OAAOmF,cAAc,QAAU,EAAA;IACjC,OAAO;MAACvB;IAAO,CAAA;EACjB;EACO,OAAA;IAAC,GAAGuB,SAAA;IAAWvB;GAAO;AAC/B;"}