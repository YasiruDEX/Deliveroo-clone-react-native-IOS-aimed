const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
const reKeySegment = /_key\s*==\s*['"](.*)['"]/;
const reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
  return typeof segment === "number" || typeof segment === "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
  if (typeof segment === "string") {
    return reKeySegment.test(segment.trim());
  }
  return typeof segment === "object" && "_key" in segment;
}
function isIndexTuple(segment) {
  if (typeof segment === "string" && reIndexTuple.test(segment)) {
    return true;
  }
  if (!Array.isArray(segment) || segment.length !== 2) {
    return false;
  }
  const [from, to] = segment;
  return (typeof from === "number" || from === "") && (typeof to === "number" || to === "");
}
function get(obj, path, defaultVal) {
  const select = typeof path === "string" ? fromString(path) : path;
  if (!Array.isArray(select)) {
    throw new Error("Path must be an array or a string");
  }
  let acc = obj;
  for (let i = 0; i < select.length; i++) {
    const segment = select[i];
    if (isIndexSegment(segment)) {
      if (!Array.isArray(acc)) {
        return defaultVal;
      }
      acc = acc[segment];
    }
    if (isKeySegment(segment)) {
      if (!Array.isArray(acc)) {
        return defaultVal;
      }
      acc = acc.find(item => item._key === segment._key);
    }
    if (typeof segment === "string") {
      acc = typeof acc === "object" && acc !== null ? acc[segment] : void 0;
    }
    if (typeof acc === "undefined") {
      return defaultVal;
    }
  }
  return acc;
}
function toString(path) {
  if (!Array.isArray(path)) {
    throw new Error("Path is not an array");
  }
  return path.reduce((target, segment, i) => {
    const segmentType = typeof segment;
    if (segmentType === "number") {
      return "".concat(target, "[").concat(segment, "]");
    }
    if (segmentType === "string") {
      const separator = i === 0 ? "" : ".";
      return "".concat(target).concat(separator).concat(segment);
    }
    if (isKeySegment(segment) && segment._key) {
      return "".concat(target, '[_key=="').concat(segment._key, '"]');
    }
    if (Array.isArray(segment)) {
      const [from, to] = segment;
      return "".concat(target, "[").concat(from, ":").concat(to, "]");
    }
    throw new Error("Unsupported path segment `".concat(JSON.stringify(segment), "`"));
  }, "");
}
function fromString(path) {
  if (typeof path !== "string") {
    throw new Error("Path is not a string");
  }
  const segments = path.match(rePropName);
  if (!segments) {
    throw new Error("Invalid path string");
  }
  return segments.map(parsePathSegment);
}
function parsePathSegment(segment) {
  if (isIndexSegment(segment)) {
    return parseIndexSegment(segment);
  }
  if (isKeySegment(segment)) {
    return parseKeySegment(segment);
  }
  if (isIndexTuple(segment)) {
    return parseIndexTupleSegment(segment);
  }
  return segment;
}
function parseIndexSegment(segment) {
  return Number(segment.replace(/[^\d]/g, ""));
}
function parseKeySegment(segment) {
  const segments = segment.match(reKeySegment);
  return {
    _key: segments[1]
  };
}
function parseIndexTupleSegment(segment) {
  const [from, to] = segment.split(":").map(seg => seg === "" ? seg : Number(seg));
  return [from, to];
}
var studioPath = /*#__PURE__*/Object.freeze({
  __proto__: null,
  fromString: fromString,
  get: get,
  isIndexSegment: isIndexSegment,
  isIndexTuple: isIndexTuple,
  isKeySegment: isKeySegment,
  reKeySegment: reKeySegment,
  toString: toString
});
const DRAFTS_PREFIX = "drafts.";
function getPublishedId(id) {
  if (id.startsWith(DRAFTS_PREFIX)) {
    return id.slice(DRAFTS_PREFIX.length);
  }
  return id;
}
const ESCAPE = {
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "'": "\\'",
  "\\": "\\\\"
};
const UNESCAPE = {
  "\\f": "\f",
  "\\n": "\n",
  "\\r": "\r",
  "\\t": "	",
  "\\'": "'",
  "\\\\": "\\"
};
function jsonPath(path) {
  return "$".concat(path.map(segment => {
    if (typeof segment === "string") {
      const escapedKey = segment.replace(/[\f\n\r\t'\\]/g, match => {
        return ESCAPE[match];
      });
      return "['".concat(escapedKey, "']");
    }
    if (typeof segment === "number") {
      return "[".concat(segment, "]");
    }
    if (segment._key !== "") {
      const escapedKey = segment._key.replace(/['\\]/g, match => {
        return ESCAPE[match];
      });
      return "[?(@._key=='".concat(escapedKey, "')]");
    }
    return "[".concat(segment._index, "]");
  }).join(""));
}
function parseJsonPath(path) {
  const parsed = [];
  const parseRe = /\['(.*?)'\]|\[(\d+)\]|\[\?\(@\._key=='(.*?)'\)\]/g;
  let match;
  while ((match = parseRe.exec(path)) !== null) {
    if (match[1] !== void 0) {
      const key = match[1].replace(/\\(\\|f|n|r|t|')/g, m => {
        return UNESCAPE[m];
      });
      parsed.push(key);
      continue;
    }
    if (match[2] !== void 0) {
      parsed.push(parseInt(match[2], 10));
      continue;
    }
    if (match[3] !== void 0) {
      const _key = match[3].replace(/\\(\\')/g, m => {
        return UNESCAPE[m];
      });
      parsed.push({
        _key,
        _index: -1
      });
      continue;
    }
  }
  return parsed;
}
function jsonPathToStudioPath(path) {
  return path.map(segment => {
    if (typeof segment === "string") {
      return segment;
    }
    if (typeof segment === "number") {
      return segment;
    }
    if (segment._key !== "") {
      return {
        _key: segment._key
      };
    }
    if (segment._index !== -1) {
      return segment._index;
    }
    throw new Error("invalid segment:".concat(JSON.stringify(segment)));
  });
}
function studioPathToJsonPath(path) {
  const parsedPath = typeof path === "string" ? fromString(path) : path;
  return parsedPath.map(segment => {
    if (typeof segment === "string") {
      return segment;
    }
    if (typeof segment === "number") {
      return segment;
    }
    if (Array.isArray(segment)) {
      throw new Error("IndexTuple segments aren't supported:".concat(JSON.stringify(segment)));
    }
    if (isContentSourceMapParsedPathKeyedSegment(segment)) {
      return segment;
    }
    if (segment._key) {
      return {
        _key: segment._key,
        _index: -1
      };
    }
    throw new Error("invalid segment:".concat(JSON.stringify(segment)));
  });
}
function isContentSourceMapParsedPathKeyedSegment(segment) {
  return typeof segment === "object" && "_key" in segment && "_index" in segment;
}
function jsonPathToMappingPath(path) {
  return path.map(segment => {
    if (typeof segment === "string") {
      return segment;
    }
    if (typeof segment === "number") {
      return segment;
    }
    if (segment._index !== -1) {
      return segment._index;
    }
    throw new Error("invalid segment:".concat(JSON.stringify(segment)));
  });
}
function resolveMapping(resultPath, csm) {
  if (!(csm == null ? void 0 : csm.mappings)) {
    return void 0;
  }
  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));
  if (csm.mappings[resultMappingPath] !== void 0) {
    return {
      mapping: csm.mappings[resultMappingPath],
      matchedPath: resultMappingPath,
      pathSuffix: ""
    };
  }
  const mappings = Object.entries(csm.mappings).filter(_ref => {
    let [key] = _ref;
    return resultMappingPath.startsWith(key);
  }).sort((_ref2, _ref3) => {
    let [key1] = _ref2;
    let [key2] = _ref3;
    return key2.length - key1.length;
  });
  if (mappings.length == 0) {
    return void 0;
  }
  const [matchedPath, mapping] = mappings[0];
  const pathSuffix = resultMappingPath.substring(matchedPath.length);
  return {
    mapping,
    matchedPath,
    pathSuffix
  };
}
function isArray(value) {
  return value !== null && Array.isArray(value);
}
function isRecord(value) {
  return typeof value === "object" && value !== null;
}
function walkMap(value, mappingFn) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (isArray(value)) {
    return value.map((v, idx) => {
      if (isRecord(v)) {
        const _key = v["_key"];
        if (typeof _key === "string") {
          return walkMap(v, mappingFn, path.concat({
            _key,
            _index: idx
          }));
        }
      }
      return walkMap(v, mappingFn, path.concat(idx));
    });
  }
  if (isRecord(value)) {
    return Object.fromEntries(Object.entries(value).map(_ref4 => {
      let [k, v] = _ref4;
      return [k, walkMap(v, mappingFn, path.concat(k))];
    }));
  }
  return mappingFn(value, path);
}
function createEditUrl(options) {
  const {
    baseUrl,
    workspace: _workspace = "default",
    tool: _tool = "default",
    id: _id,
    type,
    path
  } = options;
  if (!baseUrl) {
    throw new Error("baseUrl is required");
  }
  if (!path) {
    throw new Error("path is required");
  }
  if (!_id) {
    throw new Error("id is required");
  }
  if (baseUrl !== "/" && baseUrl.endsWith("/")) {
    throw new Error("baseUrl must not end with a slash");
  }
  const workspace = _workspace === "default" ? void 0 : _workspace;
  const tool = _tool === "default" ? void 0 : _tool;
  const id = getPublishedId(_id);
  const stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path;
  const searchParams = new URLSearchParams({
    baseUrl,
    id,
    type,
    path: stringifiedPath
  });
  if (workspace) {
    searchParams.set("workspace", workspace);
  }
  if (tool) {
    searchParams.set("tool", tool);
  }
  const segments = [baseUrl === "/" ? "" : baseUrl];
  if (workspace) {
    segments.push(workspace);
  }
  const routerParams = ["mode=presentation", "id=".concat(id), "type=".concat(type), "path=".concat(encodeURIComponent(stringifiedPath))];
  if (tool) {
    routerParams.push("tool=".concat(tool));
  }
  segments.push("intent", "edit", "".concat(routerParams.join(";"), "?").concat(searchParams));
  return segments.join("/");
}
function resolveEditInfo(options) {
  const {
    resultSourceMap: csm,
    resultPath
  } = options;
  const {
    mapping,
    pathSuffix
  } = resolveMapping(resultPath, csm) || {};
  if (!mapping) {
    return void 0;
  }
  if (mapping.source.type === "literal") {
    return void 0;
  }
  if (mapping.source.type === "unknown") {
    return void 0;
  }
  const sourceDoc = csm.documents[mapping.source.document];
  const sourcePath = csm.paths[mapping.source.path];
  if (sourceDoc && sourcePath) {
    const {
      baseUrl,
      workspace,
      tool
    } = resolveStudioBaseRoute(typeof options.studioUrl === "function" ? options.studioUrl(sourceDoc) : options.studioUrl);
    if (!baseUrl) return void 0;
    const {
      _id,
      _type
    } = sourceDoc;
    return {
      baseUrl,
      workspace,
      tool,
      id: _id,
      type: _type,
      path: parseJsonPath(sourcePath + pathSuffix)
    };
  }
  return void 0;
}
function resolveStudioBaseRoute(studioUrl) {
  let baseUrl = typeof studioUrl === "string" ? studioUrl : studioUrl.baseUrl;
  if (baseUrl !== "/") {
    baseUrl = baseUrl.replace(/\/$/, "");
  }
  if (typeof studioUrl === "string") {
    return {
      baseUrl
    };
  }
  return {
    ...studioUrl,
    baseUrl
  };
}
export { DRAFTS_PREFIX, createEditUrl, get, getPublishedId, jsonPath, jsonPathToStudioPath, parseJsonPath, reKeySegment, resolveEditInfo, resolveMapping, resolveStudioBaseRoute, studioPath, studioPathToJsonPath, toString, walkMap };
//# sourceMappingURL=resolveEditInfo-FaeuCV4M.js.map
