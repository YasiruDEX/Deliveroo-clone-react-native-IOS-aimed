import { ObservableSanityClient, defaultConfig, SanityClient, defineCreateClientExports, middleware } from './_chunks/nodeMiddleware-P6A9E9ae.js';
export { BasePatch, BaseTransaction, ClientError, ObservablePatch, ObservableTransaction, Patch, ServerError, Transaction } from './_chunks/nodeMiddleware-P6A9E9ae.js';
import { map } from 'rxjs/operators';
import { vercelStegaCombine, vercelStegaSplit } from '@vercel/stega';
import { walkMap, resolveMapping, parseJsonPath, resolveStudioBaseRoute, createEditUrl, reKeySegment, toString, jsonPathToStudioPath } from './_chunks/resolveEditInfo-FaeuCV4M.js';
export { adapter as unstable__adapter, environment as unstable__environment } from 'get-it';
const defaultStegaConfig = {
  enabled: false,
  filter: props => props.filterDefault(props)
};
function splitConfig(config) {
  const {
    stega = {},
    ...clientConfig
  } = config;
  return {
    clientConfig,
    stegaConfig: typeof stega === "boolean" ? {
      enabled: stega
    } : stega
  };
}
const initStegaConfig = (config, prevConfig) => {
  const specifiedConfig = Object.assign({}, prevConfig, config);
  const newConfig = Object.assign({}, defaultStegaConfig, specifiedConfig);
  if ("encodeSourceMap" in newConfig) {
    throw new Error("It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client/stega'. Did you mean 'enabled'?");
  }
  if ("encodeSourceMapAtPath" in newConfig) {
    throw new Error("It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client/stega'. Did you mean 'filter'?");
  }
  if (typeof newConfig.enabled !== "boolean") {
    throw new Error("config.enabled must be a boolean, received ".concat(newConfig.enabled));
  }
  if (newConfig.enabled && newConfig.studioUrl === void 0) {
    throw new Error("config.studioUrl must be defined when config.enabled is true");
  }
  if (newConfig.enabled && typeof newConfig.studioUrl !== "string" && typeof newConfig.studioUrl !== "function") {
    throw new Error("config.studioUrl must be a string or a function, received ".concat(newConfig.studioUrl));
  }
  return newConfig;
};
function splitStegaConfigFromFetchOptions(options, initializedStegaConfig) {
  const {
    stega = {},
    ...fetchOptions
  } = options;
  const stegaConfig = initStegaConfig(typeof stega === "boolean" ? {
    enabled: stega
  } : stega, initializedStegaConfig);
  return {
    fetchOptions,
    stegaConfig
  };
}
function encodeIntoResult(result, csm, encoder) {
  return walkMap(result, (value, path) => {
    if (typeof value !== "string") {
      return value;
    }
    const resolveMappingResult = resolveMapping(path, csm);
    if (!resolveMappingResult) {
      return value;
    }
    const {
      mapping,
      matchedPath
    } = resolveMappingResult;
    if (mapping.type !== "value") {
      return value;
    }
    if (mapping.source.type !== "documentValue") {
      return value;
    }
    const sourceDocument = csm.documents[mapping.source.document];
    const sourcePath = csm.paths[mapping.source.path];
    const matchPathSegments = parseJsonPath(matchedPath);
    const sourcePathSegments = parseJsonPath(sourcePath);
    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length));
    return encoder({
      sourcePath: fullSourceSegments,
      sourceDocument,
      resultPath: path,
      value
    });
  });
}
const filterDefault = _ref => {
  let {
    sourcePath,
    value
  } = _ref;
  if (isValidDate(value) || isValidURL(value)) {
    return false;
  }
  const endPath = sourcePath.at(-1);
  if (sourcePath.at(-2) === "slug" && endPath === "current") {
    return false;
  }
  if (typeof endPath === "string" && endPath.startsWith("_")) {
    return false;
  }
  if (typeof endPath === "number" && sourcePath.at(-2) === "marks") {
    return false;
  }
  if (endPath === "href" && typeof sourcePath.at(-2) === "number" && sourcePath.at(-3) === "markDefs") {
    return false;
  }
  if (endPath === "style" || endPath === "listItem") {
    return false;
  }
  if (sourcePath.some(path => path === "meta" || path === "metadata" || path === "openGraph" || path === "seo")) {
    return false;
  }
  if (typeof endPath === "string" && denylist.has(endPath)) {
    return false;
  }
  return true;
};
const denylist = /* @__PURE__ */new Set(["color", "colour", "currency", "email", "format", "gid", "hex", "href", "hsl", "hsla", "icon", "id", "index", "key", "language", "layout", "link", "linkAction", "locale", "lqip", "page", "path", "ref", "rgb", "rgba", "route", "secret", "slug", "status", "tag", "template", "theme", "type", "unit", "url", "username", "variant", "website"]);
function isValidDate(dateString) {
  return Number.isNaN(Number(dateString)) ? Boolean(Date.parse(dateString)) : false;
}
function isValidURL(url) {
  try {
    new URL(url, url.startsWith("/") ? "https://acme.com" : void 0);
  } catch {
    return false;
  }
  return true;
}
const TRUNCATE_LENGTH = 20;
function stegaEncodeSourceMap(result, resultSourceMap, config) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const {
    filter,
    logger,
    enabled
  } = config;
  if (!enabled) {
    const msg = "config.enabled must be true, don't call this function otherwise";
    (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "[@sanity/client/stega]: ".concat(msg), {
      result,
      resultSourceMap,
      config
    });
    throw new TypeError(msg);
  }
  if (!resultSourceMap) {
    (_b = logger == null ? void 0 : logger.error) == null ? void 0 : _b.call(logger, "[@sanity/client/stega]: Missing Content Source Map from response body", {
      result,
      resultSourceMap,
      config
    });
    return result;
  }
  if (!config.studioUrl) {
    const msg = "config.studioUrl must be defined";
    (_c = logger == null ? void 0 : logger.error) == null ? void 0 : _c.call(logger, "[@sanity/client/stega]: ".concat(msg), {
      result,
      resultSourceMap,
      config
    });
    throw new TypeError(msg);
  }
  const report = {
    encoded: [],
    skipped: []
  };
  const resultWithStega = encodeIntoResult(result, resultSourceMap, _ref2 => {
    let {
      sourcePath,
      sourceDocument,
      resultPath,
      value
    } = _ref2;
    if ((typeof filter === "function" ? filter({
      sourcePath,
      resultPath,
      filterDefault,
      sourceDocument,
      value
    }) : filterDefault({
      sourcePath,
      resultPath,
      filterDefault,
      sourceDocument,
      value
    })) === false) {
      if (logger) {
        report.skipped.push({
          path: prettyPathForLogging(sourcePath),
          value: "".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? "..." : ""),
          length: value.length
        });
      }
      return value;
    }
    if (logger) {
      report.encoded.push({
        path: prettyPathForLogging(sourcePath),
        value: "".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? "..." : ""),
        length: value.length
      });
    }
    const {
      baseUrl,
      workspace,
      tool
    } = resolveStudioBaseRoute(typeof config.studioUrl === "function" ? config.studioUrl(sourceDocument) : config.studioUrl);
    if (!baseUrl) return value;
    const {
      _id: id,
      _type: type
    } = sourceDocument;
    return vercelStegaCombine(value, {
      origin: "sanity.io",
      href: createEditUrl({
        baseUrl,
        workspace,
        tool,
        id,
        type,
        path: sourcePath
      })
    },
    // We use custom logic to determine if we should skip encoding
    false);
  });
  if (logger) {
    const isSkipping = report.skipped.length;
    const isEncoding = report.encoded.length;
    if (isSkipping || isEncoding) {
      (_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _d("[@sanity/client/stega]: Encoding source map into result");
      (_e = logger.log) == null ? void 0 : _e.call(logger, "[@sanity/client/stega]: Paths encoded: ".concat(report.encoded.length, ", skipped: ").concat(report.skipped.length));
    }
    if (report.encoded.length > 0) {
      (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, "[@sanity/client/stega]: Table of encoded paths");
      (_g = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _g(report.encoded);
    }
    if (report.skipped.length > 0) {
      const skipped = /* @__PURE__ */new Set();
      for (const {
        path
      } of report.skipped) {
        skipped.add(path.replace(reKeySegment, "0").replace(/\[\d+\]/g, "[]"));
      }
      (_h = logger == null ? void 0 : logger.log) == null ? void 0 : _h.call(logger, "[@sanity/client/stega]: List of skipped paths", [...skipped.values()]);
    }
    if (isSkipping || isEncoding) {
      (_i = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _i.call(logger);
    }
  }
  return resultWithStega;
}
function prettyPathForLogging(path) {
  return toString(jsonPathToStudioPath(path));
}
function vercelStegaCleanAll(result) {
  return JSON.parse(JSON.stringify(result, (key, value) => {
    if (typeof value !== "string") return value;
    return vercelStegaSplit(value).cleaned;
  }));
}
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj)) throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj)) throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _httpRequest, _httpRequest2;
const _ObservableSanityStegaClient = class _ObservableSanityStegaClient extends ObservableSanityClient {
  constructor(httpRequest) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;
    const {
      clientConfig,
      stegaConfig
    } = splitConfig(config);
    super(httpRequest, clientConfig);
    /**
     * Private properties
     */
    __privateAdd(this, _httpRequest, void 0);
    __privateSet(this, _httpRequest, httpRequest);
    this.stegaConfig = initStegaConfig(stegaConfig, defaultStegaConfig);
  }
  /**
   * Clone the client - returns a new instance
   */
  clone() {
    return new _ObservableSanityStegaClient(__privateGet(this, _httpRequest), this.config());
  }
  config(newConfig) {
    if (newConfig === void 0) {
      return {
        ...super.config(),
        stega: {
          ...this.stegaConfig
        }
      };
    }
    const {
      clientConfig,
      stegaConfig
    } = splitConfig(newConfig);
    super.config(clientConfig);
    this.stegaConfig = initStegaConfig(stegaConfig, this.stegaConfig || {});
    return this;
  }
  /**
   * Clone the client with a new (partial) configuration.
   *
   * @param newConfig - New client configuration properties, shallowly merged with existing configuration
   */
  withConfig(newConfig) {
    const thisConfig = this.config();
    const {
      stegaConfig
    } = splitConfig(newConfig || {});
    return new _ObservableSanityStegaClient(__privateGet(this, _httpRequest), {
      ...thisConfig,
      ...newConfig,
      stega: {
        ...(thisConfig.stega || {}),
        ...(stegaConfig || {})
      }
    });
  }
  fetch(query, _params) {
    let _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      stegaConfig,
      fetchOptions: options
    } = splitStegaConfigFromFetchOptions(_options, this.stegaConfig);
    const params = _params ? vercelStegaCleanAll(_params) : _params;
    if (!stegaConfig.enabled) {
      return super.fetch(query, params, options);
    }
    const {
      filterResponse: originalFilterResponse = true
    } = options;
    return super.fetch(query, params, Object.assign({}, options, {
      filterResponse: false,
      resultSourceMap: "withKeyArraySelector"
    })).pipe(map(res => {
      const {
        result: _result,
        resultSourceMap
      } = res;
      const result = stegaEncodeSourceMap(_result, resultSourceMap, stegaConfig);
      return originalFilterResponse ? result : {
        ...res,
        result
      };
    }));
  }
};
_httpRequest = new WeakMap();
let ObservableSanityStegaClient = _ObservableSanityStegaClient;
const _SanityStegaClient = class _SanityStegaClient extends SanityClient {
  constructor(httpRequest) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;
    const {
      clientConfig,
      stegaConfig
    } = splitConfig(config);
    super(httpRequest, clientConfig);
    /**
     * Private properties
     */
    __privateAdd(this, _httpRequest2, void 0);
    __privateSet(this, _httpRequest2, httpRequest);
    this.stegaConfig = initStegaConfig(stegaConfig, defaultStegaConfig);
    this.observable = new ObservableSanityStegaClient(httpRequest, config);
  }
  /**
   * Clone the client - returns a new instance
   */
  clone() {
    return new _SanityStegaClient(__privateGet(this, _httpRequest2), this.config());
  }
  config(newConfig) {
    if (newConfig === void 0) {
      return {
        ...super.config(),
        stega: {
          ...this.stegaConfig
        }
      };
    }
    const {
      clientConfig,
      stegaConfig
    } = splitConfig(newConfig);
    super.config(clientConfig);
    this.stegaConfig = initStegaConfig(stegaConfig, {
      ...(this.stegaConfig || {})
    });
    return this;
  }
  /**
   * Clone the client with a new (partial) configuration.
   *
   * @param newConfig - New client configuration properties, shallowly merged with existing configuration
   */
  withConfig(newConfig) {
    const thisConfig = this.config();
    const {
      stegaConfig
    } = splitConfig(newConfig || {});
    return new _SanityStegaClient(__privateGet(this, _httpRequest2), {
      ...thisConfig,
      ...newConfig,
      stega: {
        ...(thisConfig.stega || {}),
        ...(stegaConfig || {})
      }
    });
  }
  fetch(query, _params) {
    let _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      stegaConfig,
      fetchOptions: options
    } = splitStegaConfigFromFetchOptions(_options, this.stegaConfig);
    const params = _params ? vercelStegaCleanAll(_params) : _params;
    if (!stegaConfig.enabled) {
      return super.fetch(query, params, options);
    }
    const {
      filterResponse: originalFilterResponse = true
    } = options;
    return super.fetch(query, params, Object.assign({}, options, {
      filterResponse: false,
      resultSourceMap: "withKeyArraySelector"
    })).then(res => {
      const {
        result: _result,
        resultSourceMap
      } = res;
      const result = stegaEncodeSourceMap(_result, resultSourceMap, stegaConfig);
      return originalFilterResponse ? result : {
        ...res,
        result
      };
    });
  }
};
_httpRequest2 = new WeakMap();
let SanityStegaClient = _SanityStegaClient;
const exp = defineCreateClientExports(middleware, SanityStegaClient);
const requester = exp.requester;
const createClient = exp.createClient;
export { ObservableSanityClient, ObservableSanityStegaClient, SanityClient, SanityStegaClient, createClient, encodeIntoResult, requester, stegaEncodeSourceMap, vercelStegaCleanAll };
//# sourceMappingURL=stega.js.map
