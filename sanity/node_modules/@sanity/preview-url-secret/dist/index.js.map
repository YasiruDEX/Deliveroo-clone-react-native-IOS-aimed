{"version":3,"file":"index.js","sources":["../src/validatePreviewUrl.ts","../src/createClientWithConfig.ts","../src/parsePreviewUrl.ts","../src/validateSecret.ts"],"sourcesContent":["import { isDev } from './constants'\nimport { createClientWithConfig } from './createClientWithConfig'\nimport { parsePreviewUrl } from './parsePreviewUrl'\nimport {\n  ParsedPreviewUrl,\n  PreviewUrlValidateUrlResult,\n  SanityClientLike,\n} from './types'\nimport { validateSecret } from './validateSecret'\n\n/**\n * @alpha\n */\nexport async function validatePreviewUrl(\n  _client: SanityClientLike,\n  previewUrl: string,\n  disableCacheNoStore?: boolean,\n): Promise<PreviewUrlValidateUrlResult> {\n  const client = createClientWithConfig(_client)\n  let parsedPreviewUrl: ParsedPreviewUrl\n  try {\n    parsedPreviewUrl = parsePreviewUrl(previewUrl)\n  } catch (error) {\n    if (isDev) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse preview URL', error, {\n        previewUrl,\n        client,\n      })\n    }\n    return { isValid: false }\n  }\n\n  const isValid = await validateSecret(\n    client,\n    parsedPreviewUrl.secret,\n    disableCacheNoStore,\n  )\n  const redirectTo = isValid ? parsedPreviewUrl.redirectTo : undefined\n\n  return { isValid, redirectTo }\n}\n\nexport type { PreviewUrlValidateUrlResult, SanityClientLike }\n","import { apiVersion } from './constants'\nimport { SanityClientLike } from './types'\n\n/**\n * Validates the passed in client instance, then clones it and reconfigures it to fit the needs and spec of\n * this package.\n * @internal\n */\nexport function createClientWithConfig(\n  client: SanityClientLike,\n): SanityClientLike {\n  if (!client) {\n    throw new TypeError('`client` is required')\n  }\n\n  if (!client.config().token) {\n    throw new TypeError('`client` must have a `token` specified')\n  }\n\n  return client.withConfig({\n    // Userland might be using an API version that's too old to use perspectives\n    apiVersion,\n    // We can't use the CDN, the secret is typically validated rigth after it's created\n    useCdn: false,\n    // The documents that hold secrets are never drafts\n    perspective: 'published',\n    // Don't waste time returning a source map, we don't need it\n    resultSourceMap: false,\n    // @ts-expect-error - If stega is enabled, make sure it's disabled\n    stega: false,\n  })\n}\n","import {\n  urlSearchParamPreviewPathname,\n  urlSearchParamPreviewSecret,\n} from './constants'\nimport { ParsedPreviewUrl } from './types'\n\n/**\n * @internal\n */\nexport function parsePreviewUrl(unsafeUrl: string): ParsedPreviewUrl {\n  const url = new URL(unsafeUrl, 'http://localhost')\n  const secret = url.searchParams.get(urlSearchParamPreviewSecret)\n  if (!secret) {\n    throw new Error('Missing secret')\n  }\n  let redirectTo = undefined\n  const unsafeRedirectTo = url.searchParams.get(urlSearchParamPreviewPathname)\n  if (unsafeRedirectTo) {\n    const { pathname, search } = new URL(unsafeRedirectTo, 'http://localhost')\n    redirectTo = `${pathname}${search}`\n  }\n  return { secret, redirectTo }\n}\n","import { fetchSecretQuery, tag } from './constants'\nimport type {\n  FetchSecretQueryParams,\n  FetchSecretQueryResponse,\n  SanityClientLike,\n} from './types'\n\n/** @internal */\nexport async function validateSecret(\n  client: SanityClientLike,\n  secret: string,\n  disableCacheNoStore?: boolean,\n): Promise<boolean> {\n  // If we're in the Edge Runtime it's usually too quick and we need to delay fetching the secret a little bit\n  // @ts-expect-error -- this global exists if we're in the Edge Runtime\n  if (typeof EdgeRuntime !== 'undefined') {\n    await new Promise((resolve) => setTimeout(resolve, 300))\n  }\n  if (!secret || !secret.trim()) {\n    return false\n  }\n  const result = await client.fetch<FetchSecretQueryResponse>(\n    fetchSecretQuery,\n    { secret } satisfies FetchSecretQueryParams,\n    {\n      tag,\n      // @ts-expect-error -- the `cache` option is valid, but not in the types when NextJS typings aren't installed\n      ...(!disableCacheNoStore ? { cache: 'no-store' } : undefined),\n    },\n  )\n  if (!result?._id || !result?._updatedAt || !result?.secret) {\n    return false\n  }\n  return secret === result.secret\n}\n"],"names":["async","validatePreviewUrl","_client","previewUrl","disableCacheNoStore","client","TypeError","config","token","withConfig","apiVersion","useCdn","perspective","resultSourceMap","stega","createClientWithConfig","parsedPreviewUrl","unsafeUrl","url","URL","secret","searchParams","get","urlSearchParamPreviewSecret","Error","redirectTo","unsafeRedirectTo","urlSearchParamPreviewPathname","pathname","search","parsePreviewUrl","error","isDev","console","isValid","EdgeRuntime","Promise","resolve","setTimeout","trim","result","fetch","fetchSecretQuery","tag","cache","_id","_updatedAt","validateSecret"],"mappings":"uFAasBA,eAAAC,EACpBC,EACAC,EACAC,GAEM,MAAAC,ECVD,SACLA,GAEA,IAAKA,EACG,MAAA,IAAIC,UAAU,wBAGtB,IAAKD,EAAOE,SAASC,MACb,MAAA,IAAIF,UAAU,0CAGtB,OAAOD,EAAOI,WAAW,CAEvBC,aAEAC,QAAQ,EAERC,YAAa,YAEbC,iBAAiB,EAEjBC,OAAO,GAEX,CDbiBC,CAAuBb,GAClC,IAAAc,EACA,IACFA,EEZG,SAAyBC,GAC9B,MAAMC,EAAM,IAAIC,IAAIF,EAAW,oBACzBG,EAASF,EAAIG,aAAaC,IAAIC,GACpC,IAAKH,EACG,MAAA,IAAII,MAAM,kBAElB,IAAIC,EACJ,MAAMC,EAAmBR,EAAIG,aAAaC,IAAIK,GAC9C,GAAID,EAAkB,CACpB,MAAME,SAAEA,EAAUC,OAAAA,GAAW,IAAIV,IAAIO,EAAkB,oBAC1CD,EAAA,GAAGG,IAAWC,GAC7B,CACO,MAAA,CAAET,SAAQK,aACnB,CFDuBK,CAAgB3B,SAC5B4B,GAQA,OAPHC,GAEMC,QAAAF,MAAM,8BAA+BA,EAAO,CAClD5B,aACAE,WAGG,CAAE6B,SAAS,EACpB,CAEA,MAAMA,QGzBclC,eACpBK,EACAe,EACAhB,GAOA,GAH2B,oBAAhB+B,mBACH,IAAIC,SAASC,GAAYC,WAAWD,EAAS,QAEhDjB,IAAWA,EAAOmB,OACd,OAAA,EAEH,MAAAC,QAAenC,EAAOoC,MAC1BC,EACA,CAAEtB,UACF,CACEuB,SAEKvC,OAA8C,EAAxB,CAAEwC,MAAO,cAGpC,SAACJ,GAAQK,KAAQL,GAAQM,YAAeN,GAAQpB,SAG7CA,IAAWoB,EAAOpB,MAC3B,CHDwB2B,CACpB1C,EACAW,EAAiBI,OACjBhB,GAIK,MAAA,CAAE8B,UAAST,WAFCS,EAAUlB,EAAiBS,gBAAa,EAG7D,QAAAE,mCAAAJ,iCAAAtB"}