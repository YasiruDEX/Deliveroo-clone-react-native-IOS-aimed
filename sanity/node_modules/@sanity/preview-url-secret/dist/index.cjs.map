{"version":3,"file":"index.cjs","sources":["../src/validatePreviewUrl.ts","../src/createClientWithConfig.ts","../src/parsePreviewUrl.ts","../src/validateSecret.ts"],"sourcesContent":["import { isDev } from './constants'\nimport { createClientWithConfig } from './createClientWithConfig'\nimport { parsePreviewUrl } from './parsePreviewUrl'\nimport {\n  ParsedPreviewUrl,\n  PreviewUrlValidateUrlResult,\n  SanityClientLike,\n} from './types'\nimport { validateSecret } from './validateSecret'\n\n/**\n * @alpha\n */\nexport async function validatePreviewUrl(\n  _client: SanityClientLike,\n  previewUrl: string,\n  disableCacheNoStore?: boolean,\n): Promise<PreviewUrlValidateUrlResult> {\n  const client = createClientWithConfig(_client)\n  let parsedPreviewUrl: ParsedPreviewUrl\n  try {\n    parsedPreviewUrl = parsePreviewUrl(previewUrl)\n  } catch (error) {\n    if (isDev) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse preview URL', error, {\n        previewUrl,\n        client,\n      })\n    }\n    return { isValid: false }\n  }\n\n  const isValid = await validateSecret(\n    client,\n    parsedPreviewUrl.secret,\n    disableCacheNoStore,\n  )\n  const redirectTo = isValid ? parsedPreviewUrl.redirectTo : undefined\n\n  return { isValid, redirectTo }\n}\n\nexport type { PreviewUrlValidateUrlResult, SanityClientLike }\n","import { apiVersion } from './constants'\nimport { SanityClientLike } from './types'\n\n/**\n * Validates the passed in client instance, then clones it and reconfigures it to fit the needs and spec of\n * this package.\n * @internal\n */\nexport function createClientWithConfig(\n  client: SanityClientLike,\n): SanityClientLike {\n  if (!client) {\n    throw new TypeError('`client` is required')\n  }\n\n  if (!client.config().token) {\n    throw new TypeError('`client` must have a `token` specified')\n  }\n\n  return client.withConfig({\n    // Userland might be using an API version that's too old to use perspectives\n    apiVersion,\n    // We can't use the CDN, the secret is typically validated rigth after it's created\n    useCdn: false,\n    // The documents that hold secrets are never drafts\n    perspective: 'published',\n    // Don't waste time returning a source map, we don't need it\n    resultSourceMap: false,\n    // @ts-expect-error - If stega is enabled, make sure it's disabled\n    stega: false,\n  })\n}\n","import {\n  urlSearchParamPreviewPathname,\n  urlSearchParamPreviewSecret,\n} from './constants'\nimport { ParsedPreviewUrl } from './types'\n\n/**\n * @internal\n */\nexport function parsePreviewUrl(unsafeUrl: string): ParsedPreviewUrl {\n  const url = new URL(unsafeUrl, 'http://localhost')\n  const secret = url.searchParams.get(urlSearchParamPreviewSecret)\n  if (!secret) {\n    throw new Error('Missing secret')\n  }\n  let redirectTo = undefined\n  const unsafeRedirectTo = url.searchParams.get(urlSearchParamPreviewPathname)\n  if (unsafeRedirectTo) {\n    const { pathname, search } = new URL(unsafeRedirectTo, 'http://localhost')\n    redirectTo = `${pathname}${search}`\n  }\n  return { secret, redirectTo }\n}\n","import { fetchSecretQuery, tag } from './constants'\nimport type {\n  FetchSecretQueryParams,\n  FetchSecretQueryResponse,\n  SanityClientLike,\n} from './types'\n\n/** @internal */\nexport async function validateSecret(\n  client: SanityClientLike,\n  secret: string,\n  disableCacheNoStore?: boolean,\n): Promise<boolean> {\n  // If we're in the Edge Runtime it's usually too quick and we need to delay fetching the secret a little bit\n  // @ts-expect-error -- this global exists if we're in the Edge Runtime\n  if (typeof EdgeRuntime !== 'undefined') {\n    await new Promise((resolve) => setTimeout(resolve, 300))\n  }\n  if (!secret || !secret.trim()) {\n    return false\n  }\n  const result = await client.fetch<FetchSecretQueryResponse>(\n    fetchSecretQuery,\n    { secret } satisfies FetchSecretQueryParams,\n    {\n      tag,\n      // @ts-expect-error -- the `cache` option is valid, but not in the types when NextJS typings aren't installed\n      ...(!disableCacheNoStore ? { cache: 'no-store' } : undefined),\n    },\n  )\n  if (!result?._id || !result?._updatedAt || !result?.secret) {\n    return false\n  }\n  return secret === result.secret\n}\n"],"names":["exports","urlSearchParamPreviewPathname","constants","b","urlSearchParamPreviewSecret","u","validatePreviewUrl","async","_client","previewUrl","disableCacheNoStore","client","TypeError","config","token","withConfig","apiVersion","a","useCdn","perspective","resultSourceMap","stega","createClientWithConfig","parsedPreviewUrl","unsafeUrl","url","URL","secret","searchParams","get","Error","redirectTo","unsafeRedirectTo","pathname","search","parsePreviewUrl","error","isDev","console","isValid","EdgeRuntime","Promise","resolve","setTimeout","trim","result","fetch","fetchSecretQuery","f","tag","t","cache","_id","_updatedAt","validateSecret"],"mappings":"sHAyCAA,QAAAC,8BAAAC,EAAAC,EAAAH,QAAAI,4BAAAF,EAAAG,EAAAL,QAAAM,mBA5BsBC,eACpBC,EACAC,EACAC,GAEM,MAAAC,ECVD,SACLA,GAEA,IAAKA,EACG,MAAA,IAAIC,UAAU,wBAGtB,IAAKD,EAAOE,SAASC,MACb,MAAA,IAAIF,UAAU,0CAGtB,OAAOD,EAAOI,WAAW,CAAAC,WAEvBA,EAAAC,EAEAC,QAAQ,EAERC,YAAa,YAEbC,iBAAiB,EAEjBC,OAAO,GAEX,CDbiBC,CAAuBd,GAClC,IAAAe,EACA,IACFA,EEZG,SAAyBC,GAC9B,MAAMC,EAAM,IAAIC,IAAIF,EAAW,oBACzBG,EAASF,EAAIG,aAAaC,IAAIzB,EAA2BC,GAC/D,IAAKsB,EACG,MAAA,IAAIG,MAAM,kBAElB,IAAIC,EACJ,MAAMC,EAAmBP,EAAIG,aAAaC,IAAI5B,EAA6BE,GAC3E,GAAI6B,EAAkB,CACpB,MAAMC,SAAEA,EAAUC,OAAAA,GAAW,IAAIR,IAAIM,EAAkB,oBAC1CD,EAAA,GAAGE,IAAWC,GAC7B,CACO,MAAA,CAAEP,SAAQI,aACnB,CFDuBI,CAAgB1B,SAC5B2B,GAQA,OAPHC,KAEMC,QAAAF,MAAM,8BAA+BA,EAAO,CAClD3B,aACAE,WAGG,CAAE4B,SAAS,EACpB,CAEA,MAAMA,QGzBchC,eACpBI,EACAgB,EACAjB,GAOA,GAH2B,oBAAhB8B,mBACH,IAAIC,SAASC,GAAYC,WAAWD,EAAS,QAEhDf,IAAWA,EAAOiB,OACd,OAAA,EAEH,MAAAC,QAAelC,EAAOmC,MAC1BC,EAAAC,EACA,CAAErB,UACF,CAAAsB,IACEA,EAAAC,KAEKxC,OAA8C,EAAxB,CAAEyC,MAAO,cAGpC,SAACN,GAAQO,KAAQP,GAAQQ,YAAeR,GAAQlB,SAG7CA,IAAWkB,EAAOlB,MAC3B,CHDwB2B,CACpB3C,EACAY,EAAiBI,OACjBjB,GAIK,MAAA,CAAE6B,UAASR,WAFCQ,EAAUhB,EAAiBQ,gBAAa,EAG7D"}