import {
  require_hashlru,
  require_json_inspector
} from "./chunk-3YWASYUR.js";
import {
  BetaBadge,
  Button as Button2,
  ChangeConnectorRoot,
  ChangeFieldWrapper,
  ChangeList,
  CommandList,
  ContextMenuButton,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  Dialog as Dialog2,
  DiffTooltip,
  DocumentChangeContext,
  DocumentPreviewPresence,
  DocumentStatus,
  DocumentStatusIndicator,
  EMPTY,
  EMPTY_ARRAY$9,
  EMPTY_OBJECT,
  FieldActionsProvider,
  FieldActionsResolver,
  FormBuilder,
  GetHookCollectionState,
  InsufficientPermissionsMessage,
  IntentLink,
  LegacyLayerProvider,
  LoadingBlock,
  MenuButton as MenuButton2,
  MenuGroup,
  MenuItem as MenuItem2,
  NoChanges,
  Popover as Popover2,
  PortableText,
  PortableTextEditable,
  PortableTextEditor,
  PresenceOverlay,
  PreviewCard$1,
  ReferenceInputOptionsProvider,
  SanityDefaultPreview,
  Schema,
  ScrollContainer,
  SourceProvider,
  StateLink,
  StatusButton,
  Subject,
  TOOLTIP_DELAY_PROPS,
  Tab as Tab2,
  TextWithTone,
  Tooltip,
  TooltipOfDisabled,
  Translate,
  UserAvatar,
  VirtualizerScrollInstanceProvider,
  asyncScheduler,
  catchError,
  collate,
  concat,
  createHookFromObservableFactory,
  createPatchChannel,
  createSearchQuery,
  debounce,
  debounceTime,
  decodeJsonParams,
  defaultKeyGenerator,
  defer,
  defineArrayMember,
  defineDocumentInspector,
  defineField,
  defineLocaleResourceBundle,
  definePlugin,
  delay,
  distinctUntilChanged,
  e,
  encodeJsonParams,
  evaluateQuery,
  exhaustMapWithTrailing,
  forkJoin,
  format,
  from,
  fromEvent,
  fromMutationPatches,
  fromString,
  generateHelpUrl,
  get,
  getConfigContextFromSource,
  getDraftId,
  getExpandOperations,
  getPreviewStateObservable,
  getPreviewValueWithFallback,
  getPublishedId,
  getSchemaTypeTitle,
  getSearchTypesWithMaxDepth,
  getSearchableTypes,
  getValueAtPath,
  isActionEnabled,
  isArray,
  isArraySchemaType,
  isDev,
  isIndexSegment,
  isKeySegment,
  isObjectSchemaType,
  isPortableTextSpan,
  isPortableTextTextBlock,
  isRecord$4,
  isReferenceSchemaType,
  isSanityDocument,
  isString,
  isValidationError,
  isValidationErrorMarker,
  isValidationWarning,
  map,
  mapTo,
  merge,
  mergeMap,
  of,
  parse,
  partition,
  require_assignWith,
  require_baseGetTag,
  require_capitalize,
  require_castArray,
  require_client,
  require_compact,
  require_createCompounder,
  require_dataloader,
  require_debounce,
  require_deburr,
  require_difference,
  require_escapeRegExp,
  require_exif_component,
  require_find,
  require_findIndex,
  require_flatten,
  require_get,
  require_groupBy,
  require_identity,
  require_image_url_umd,
  require_intersection,
  require_isEqual,
  require_isObjectLike,
  require_isPlainObject,
  require_isString,
  require_keyBy,
  require_lib,
  require_memoize,
  require_negate,
  require_omit,
  require_orderBy,
  require_partition,
  require_pick,
  require_raf,
  require_react_fast_compare,
  require_reduce,
  require_shallow_equals,
  require_sortBy,
  require_speakingurl,
  require_startCase,
  require_throttle,
  require_toLower,
  require_union,
  require_uniq,
  require_uniqBy,
  require_uniqueId,
  require_values,
  require_with_selector,
  require_words,
  require_xor,
  resizeObserver,
  resolveConditionalProperty,
  resolveKeyedPath,
  route,
  scan,
  setAtPath,
  share,
  shareReplay,
  startWith,
  switchMap,
  take,
  tap,
  throttleTime,
  throwError,
  timer,
  toMutationPatches,
  toString,
  useAsObservable,
  useClient,
  useConfigContextFromSource,
  useConnectionState,
  useCurrentUser,
  useDateTimeFormat,
  useDidUpdate,
  useDocumentOperation,
  useDocumentOperationEvent,
  useDocumentPairPermissions,
  useDocumentPresence,
  useDocumentPreview,
  useDocumentPreviewStore,
  useDocumentStore,
  useDocumentType,
  useDocumentValuePermissions,
  useEditState,
  useFeatureEnabled,
  useFieldActions,
  useFormState,
  useGetI18nText,
  useI18nText,
  useInitialValue,
  useIntentLink,
  useListFormat,
  useMemoObservable,
  useMiddlewareComponents,
  useObservableCallback,
  usePortableTextEditor,
  usePortableTextEditorSelection,
  usePresenceStore,
  useProjectStore,
  useRelativeTime,
  useRouter,
  useRouterState,
  useSchema,
  useSearchMaxFieldDepth,
  useSettingsStore,
  useSource,
  useSyncState,
  useTemplatePermissions,
  useTemplates,
  useTimeAgo,
  useTimelineSelector,
  useTimelineStore,
  useTranslation,
  useTranslation2,
  useUnique,
  useUser,
  useUserStore,
  useValidationStatus,
  useWorkspace,
  useZIndex,
  v4_default,
  visitDiff
} from "./chunk-PB3Q75CL.js";
import {
  AnimatePresence,
  Avatar,
  AvatarStack,
  Badge,
  BoundaryElementProvider,
  Box,
  Breadcrumbs,
  Button,
  Card,
  Checkbox,
  Code,
  Container,
  Dialog,
  DialogProvider,
  ErrorBoundary,
  Flex,
  Grid,
  Heading,
  Hotkeys,
  Inline,
  Layer,
  LayerProvider,
  Menu,
  MenuButton,
  MenuDivider,
  MenuItem,
  Popover,
  PortalProvider,
  Select,
  Spinner,
  Stack,
  Tab,
  TabList,
  TabPanel,
  Text,
  TextArea,
  TextInput,
  TextSkeleton,
  ThemeColorProvider,
  ToastProvider,
  TooltipDelayGroupProvider,
  Tree,
  TreeItem,
  _raf2,
  focusFirstDescendant,
  focusLastDescendant,
  hues,
  motion,
  rem,
  require_react_is,
  rgba2 as rgba,
  useBoundaryElement,
  useClickOutside,
  useElementRect,
  useForwardedRef,
  useGlobalKeyDown,
  useLayer,
  useMediaIndex,
  usePortal,
  useToast
} from "./chunk-VAYDIXRE.js";
import {
  at,
  dt,
  ht,
  ut
} from "./chunk-RMMTU5SM.js";
import {
  AddCircleIcon,
  AddIcon,
  ArrowLeftIcon,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  CloseIcon,
  CommentIcon,
  ControlsIcon,
  CopyIcon,
  DocumentIcon,
  DocumentsIcon,
  DoubleChevronRightIcon,
  EarthAmericasIcon,
  EditIcon,
  ErrorOutlineIcon,
  FolderIcon,
  InfoOutlineIcon,
  JsonIcon,
  LaunchIcon,
  LinkIcon,
  MasterDetailIcon,
  MenuIcon,
  MoonIcon,
  PublishIcon,
  ReadOnlyIcon,
  ResetIcon,
  RestoreIcon,
  SearchIcon,
  SelectIcon,
  SortIcon,
  SpinnerIcon,
  SplitVerticalIcon,
  StackCompactIcon,
  StackIcon,
  SunIcon,
  SyncIcon,
  TrashIcon,
  UndoIcon,
  UnknownIcon,
  UnpublishIcon,
  WarningOutlineIcon
} from "./chunk-EVMCOCG7.js";
import {
  require_jsx_runtime
} from "./chunk-W7O3NKM5.js";
import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber2;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports, module) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase2;
  }
});

// node_modules/lodash/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/lodash/kebabCase.js"(exports, module) {
    var createCompounder = require_createCompounder();
    var kebabCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    module.exports = kebabCase2;
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format2(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format3, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err2) {
        debug && console.error("unable to copy using execCommand: ", err2);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err3) {
          debug && console.error("unable to copy using clipboardData: ", err3);
          debug && console.error("falling back to prompt");
          message = format2("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/react-copy-to-clipboard/lib/Component.js
var require_Component = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/Component.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CopyToClipboard = void 0;
    var _react = _interopRequireDefault(require_react());
    var _copyToClipboard = _interopRequireDefault(require_copy_to_clipboard());
    var _excluded = ["text", "onCopy", "options", "children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var CopyToClipboard2 = function(_React$PureComponent) {
      _inherits(CopyToClipboard3, _React$PureComponent);
      var _super = _createSuper(CopyToClipboard3);
      function CopyToClipboard3() {
        var _this;
        _classCallCheck(this, CopyToClipboard3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
          var _this$props = _this.props, text = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
          var elem = _react["default"].Children.only(children);
          var result = (0, _copyToClipboard["default"])(text, options);
          if (onCopy) {
            onCopy(text, result);
          }
          if (elem && elem.props && typeof elem.props.onClick === "function") {
            elem.props.onClick(event);
          }
        });
        return _this;
      }
      _createClass(CopyToClipboard3, [{
        key: "render",
        value: function render() {
          var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options = _this$props2.options, children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
          var elem = _react["default"].Children.only(children);
          return _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
            onClick: this.onClick
          }));
        }
      }]);
      return CopyToClipboard3;
    }(_react["default"].PureComponent);
    exports.CopyToClipboard = CopyToClipboard2;
    _defineProperty(CopyToClipboard2, "defaultProps", {
      onCopy: void 0,
      options: void 0
    });
  }
});

// node_modules/react-copy-to-clipboard/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/index.js"(exports, module) {
    "use strict";
    var _require = require_Component();
    var CopyToClipboard2 = _require.CopyToClipboard;
    CopyToClipboard2.CopyToClipboard = CopyToClipboard2;
    module.exports = CopyToClipboard2;
  }
});

// node_modules/sanity/lib/_chunks/structure-BXyPLY49.js
var import_react2 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react_copy_to_clipboard = __toESM(require_lib2());
var import_isNumber = __toESM(require_isNumber());
var import_isString2 = __toESM(require_isString());
var import_omit2 = __toESM(require_omit());
var import_uniqBy2 = __toESM(require_uniqBy());
var import_negate = __toESM(require_negate());
var import_isEqual2 = __toESM(require_isEqual());
var import_deburr = __toESM(require_deburr());
var import_isEqual3 = __toESM(require_isEqual());
var import_client3 = __toESM(require_client());
var import_debounce2 = __toESM(require_debounce());
var import_orderBy2 = __toESM(require_orderBy());
var import_sortBy2 = __toESM(require_sortBy());
var import_findIndex = __toESM(require_findIndex());
var import_startCase2 = __toESM(require_startCase());
var import_camelCase = __toESM(require_camelCase());
var import_speakingurl2 = __toESM(require_speakingurl());
var import_uniq2 = __toESM(require_uniq());
var import_kebabCase = __toESM(require_kebabCase());
var import_find2 = __toESM(require_find());
var import_uniqueId = __toESM(require_uniqueId());
var import_react_is2 = __toESM(require_react_is());
var import_is_hotkey = __toESM(require_lib());
var import_react_json_inspector = __toESM(require_json_inspector());
var import_hashlru = __toESM(require_hashlru());
var import_shallow_equals2 = __toESM(require_shallow_equals());

// node_modules/sanity/lib/_internalBrowser.esm.js
var import_sortBy = __toESM(require_sortBy());
var import_compact = __toESM(require_compact());
var import_intersection = __toESM(require_intersection());
var import_keyBy = __toESM(require_keyBy());
var import_partition = __toESM(require_partition());
var import_toLower = __toESM(require_toLower());
var import_union = __toESM(require_union());
var import_uniq = __toESM(require_uniq());
var import_words = __toESM(require_words());
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_isString = __toESM(require_isString());
var import_startCase = __toESM(require_startCase());
var import_react_is = __toESM(require_react_is());
var import_flatten = __toESM(require_flatten());
var import_uniqBy = __toESM(require_uniqBy());
var import_image_url = __toESM(require_image_url_umd());
var import_isEqual = __toESM(require_isEqual());
var import_throttle = __toESM(require_throttle());
var import_debounce = __toESM(require_debounce());
var import_react_fast_compare = __toESM(require_react_fast_compare());
var import_omit = __toESM(require_omit());
var import_orderBy = __toESM(require_orderBy());
var import_xor = __toESM(require_xor());
var import_shallow_equals = __toESM(require_shallow_equals());
var import_get = __toESM(require_get());
var import_isPlainObject = __toESM(require_isPlainObject());
var import_exif_component = __toESM(require_exif_component());
var import_find = __toESM(require_find());
var import_speakingurl = __toESM(require_speakingurl());
var import_castArray = __toESM(require_castArray());
var import_pick = __toESM(require_pick());
var import_assignWith = __toESM(require_assignWith());
var import_difference = __toESM(require_difference());
var import_memoize = __toESM(require_memoize());
var import_identity = __toESM(require_identity());
var import_values = __toESM(require_values());
var import_groupBy = __toESM(require_groupBy());
var import_json_reduce = __toESM(require_reduce());
var import_with_selector = __toESM(require_with_selector());
var import_dataloader = __toESM(require_dataloader());
var import_raf = __toESM(require_raf());
var import_capitalize = __toESM(require_capitalize());
var import_escapeRegExp = __toESM(require_escapeRegExp());
var import_client2 = __toESM(require_client());

// node_modules/sanity/lib/_chunks/structure-BXyPLY49.js
function Delay(_ref12) {
  let { children, ms = 0 } = _ref12;
  const [ready, setReady] = (0, import_react2.useState)(ms <= 0);
  (0, import_react2.useEffect)(() => {
    if (ms <= 0) {
      return void 0;
    }
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]);
  if (!ready || !children) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  }
  return typeof children === "function" ? children() : children;
}
var structureLocaleNamespace = "structure";
var structureUsEnglishLocaleBundle = defineLocaleResourceBundle({ locale: "en-US", namespace: structureLocaleNamespace, resources: () => import("./resources-MYuclG80-TVY46RIG.js") });
function DocTitle(props) {
  const { document: documentValue } = props;
  const schema2 = useSchema();
  const schemaType = schema2.get(documentValue._type);
  const { t } = useTranslation2(structureLocaleNamespace);
  const { error, value } = useDocumentPreview({ schemaType, value: documentValue });
  if (!schemaType) {
    return (0, import_jsx_runtime2.jsx)("code", { children: t("doc-title.unknown-schema-type.text", { schemaType: documentValue._type }) });
  }
  if (error) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t("doc-title.error.text", { errorMessage: error.message }) });
  }
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime2.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("doc-title.fallback.text") }) });
}
var RenderActionCollectionState = (props) => {
  const { actions, children, actionProps, onActionComplete } = props;
  return (0, import_jsx_runtime2.jsx)(GetHookCollectionState, { onReset: onActionComplete, hooks: actions, args: actionProps, children });
};
var RenderBadgeCollectionState = (props) => {
  const { badges, children, badgeProps, ...rest } = props;
  return (0, import_jsx_runtime2.jsx)(GetHookCollectionState, { ...rest, hooks: badges, args: badgeProps, children });
};
function isClientError(e2) {
  if (typeof e2 !== "object")
    return false;
  if (!e2)
    return false;
  return "statusCode" in e2 && "response" in e2;
}
var POLL_INTERVAL = 5e3;
var visiblePoll$;
var getVisiblePoll$ = () => {
  if (!visiblePoll$) {
    visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
      // add empty emission to have this fire on creation
      startWith(null),
      map(() => document.visibilityState === "visible"),
      distinctUntilChanged(),
      switchMap((visible) => visible ? (
        // using timer instead of interval since timer will emit on creation
        timer(0, POLL_INTERVAL)
      ) : EMPTY),
      shareReplay({ refCount: true, bufferSize: 1 })
    );
  }
  return visiblePoll$;
};
function getDocumentExistence(documentId, _ref13) {
  let { versionedClient } = _ref13;
  const draftId = getDraftId(documentId);
  const publishedId = getPublishedId(documentId);
  const requestOptions = { uri: versionedClient.getDataUrl("doc", "".concat(draftId, ",").concat(publishedId)), json: true, query: { excludeContent: "true" }, tag: "use-referring-documents.document-existence" };
  return versionedClient.observable.request(requestOptions).pipe(map((_ref14) => {
    let { omitted } = _ref14;
    const nonExistant = omitted.filter((doc) => doc.reason === "existence");
    if (nonExistant.length === 2) {
      return void 0;
    }
    if (nonExistant.length === 0) {
      return publishedId;
    }
    return nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
  }));
}
function fetchCrossDatasetReferences(documentId, context) {
  const { versionedClient } = context;
  return getVisiblePoll$().pipe(switchMap(() => getDocumentExistence(documentId, context)), switchMap((checkDocumentId) => {
    if (!checkDocumentId) {
      return of({ totalCount: 0, references: [] });
    }
    const currentDataset = versionedClient.config().dataset;
    return versionedClient.observable.request({ url: "/data/references/".concat(currentDataset, "/documents/").concat(checkDocumentId, "/to?excludeInternalReferences=true&excludePaths=true"), tag: "use-referring-documents.external" }).pipe(catchError((e2) => {
      if (isClientError(e2) && e2.statusCode === 404) {
        return of({ totalCount: 0, references: [] });
      }
      throw e2;
    }));
  }));
}
var useInternalReferences = createHookFromObservableFactory((_ref15) => {
  let [documentId, documentStore] = _ref15;
  const referencesClause = "*[references($documentId)][0...100]{_id,_type}";
  const totalClause = "count(*[references($documentId)])";
  const fetchQuery = '{"references":'.concat(referencesClause, ',"totalCount":').concat(totalClause, "}");
  const listenQuery = "*[references($documentId)]";
  return documentStore.listenQuery({ fetch: fetchQuery, listen: listenQuery }, { documentId }, { tag: "use-referring-documents", transitions: ["appear", "disappear"], throttleTime: 5e3 });
});
var useCrossDatasetReferences = createHookFromObservableFactory((_ref16) => {
  let [documentId, versionedClient] = _ref16;
  return getVisiblePoll$().pipe(switchMap(() => fetchCrossDatasetReferences(documentId, { versionedClient })));
});
function useReferringDocuments(documentId) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const documentStore = useDocumentStore();
  const publishedId = getPublishedId(documentId);
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences((0, import_react2.useMemo)(() => [publishedId, documentStore], [documentStore, publishedId]));
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences((0, import_react2.useMemo)(() => [publishedId, versionedClient], [publishedId, versionedClient]));
  const projectIds = (0, import_react2.useMemo)(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => crossDatasetReference.projectId).filter(Boolean))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const datasetNames = (0, import_react2.useMemo)(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter((datasetName) => Boolean(datasetName) && datasetName !== ""))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const hasUnknownDatasetNames = (0, import_react2.useMemo)(() => {
    return Boolean(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.some((crossDatasetReference) => typeof crossDatasetReference.datasetName !== "string"));
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return { totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0), projectIds, datasetNames, hasUnknownDatasetNames, internalReferences, crossDatasetReferences, isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading };
}
function PaneItemPreview(props) {
  const { icon, layout, presence, schemaType, value } = props;
  const title = isRecord$4(value.title) && (0, import_react2.isValidElement)(value.title) || (0, import_isString2.default)(value.title) || (0, import_isNumber.default)(value.title) ? value.title : null;
  const { draft, published, isLoading } = useMemoObservable(() => getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title), [props.documentPreviewStore, schemaType, value._id, title]);
  const status = isLoading ? null : (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { delay: TOOLTIP_DELAY_PROPS, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, children: [presence && presence.length > 0 && (0, import_jsx_runtime2.jsx)(DocumentPreviewPresence, { presence }), (0, import_jsx_runtime2.jsx)(DocumentStatusIndicator, { draft, published })] }) });
  const tooltip = (0, import_jsx_runtime2.jsx)(DocumentStatus, { draft, published });
  return (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { ...getPreviewValueWithFallback({ value, draft, published }), isPlaceholder: isLoading, icon, layout, status, tooltip });
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
var PaneRouterContext = (0, import_react2.createContext)({ index: 0, groupIndex: 0, siblingIndex: 0, payload: void 0, params: {}, hasGroupSiblings: false, groupLength: 0, routerPanesState: [], BackLink: () => missingContext(), ChildLink: () => missingContext(), ReferenceChildLink: () => missingContext(), handleEditReference: () => missingContext(), ParameterizedLink: () => missingContext(), replaceCurrent: () => missingContext(), closeCurrentAndAfter: () => missingContext(), closeCurrent: () => missingContext(), duplicateCurrent: () => missingContext(), setView: () => missingContext(), setParams: () => missingContext(), setPayload: () => missingContext(), navigateIntent: () => missingContext(), createPathWithParams: () => missingContext() });
var BackLink = (0, import_react2.forwardRef)(function BackLink2(props, ref) {
  const { routerPanesState, groupIndex } = (0, import_react2.useContext)(PaneRouterContext);
  const panes = (0, import_react2.useMemo)(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]);
  const state2 = (0, import_react2.useMemo)(() => ({ panes }), [panes]);
  return (0, import_jsx_runtime2.jsx)(StateLink, { ...props, ref, state: state2 });
});
var PaneLayoutContext = (0, import_react2.createContext)(null);
function usePaneLayout() {
  const pane = (0, import_react2.useContext)(PaneLayoutContext);
  if (!pane) {
    throw new Error("PaneLayout: missing context value");
  }
  return pane;
}
var ChildLink = (0, import_react2.forwardRef)(function ChildLink2(props, ref) {
  const { childId, childPayload, childParameters, ...rest } = props;
  const { routerPanesState, groupIndex } = (0, import_react2.useContext)(PaneRouterContext);
  return (0, import_jsx_runtime2.jsx)(StateLink, { ...rest, ref, state: { panes: [...routerPanesState.slice(0, groupIndex + 1), [{ id: childId, params: childParameters, payload: childPayload }]] } });
});
var ReferenceChildLink = (0, import_react2.forwardRef)(function ReferenceChildLink2(_ref17, ref) {
  let { documentId, documentType, parentRefPath, children, template, ...rest } = _ref17;
  return (0, import_jsx_runtime2.jsx)(ChildLink, { ...rest, ref, childId: documentId, childPayload: template == null ? void 0 : template.params, childParameters: { type: documentType, parentRefPath: toString(parentRefPath), ...template && { template: template == null ? void 0 : template.id } }, children });
});
var ParameterizedLink = (0, import_react2.forwardRef)(function ParameterizedLink2(props, ref) {
  const { routerPanesState: currentPanes, groupIndex, siblingIndex } = (0, import_react2.useContext)(PaneRouterContext);
  const { params, payload, ...rest } = props;
  const nextParams = useUnique(params);
  const nextPayload = useUnique(payload);
  const nextState = (0, import_react2.useMemo)(() => {
    const currentGroup = currentPanes[groupIndex];
    const currentSibling = currentGroup[siblingIndex];
    const nextSibling = { ...currentSibling, params: nextParams != null ? nextParams : currentSibling.params, payload: nextPayload != null ? nextPayload : currentSibling.payload };
    const nextGroup = [...currentGroup.slice(0, siblingIndex), nextSibling, ...currentGroup.slice(siblingIndex + 1)];
    const nextPanes = [...currentPanes.slice(0, groupIndex), nextGroup, ...currentPanes.slice(groupIndex + 1)];
    return { panes: nextPanes };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return (0, import_jsx_runtime2.jsx)(StateLink, { ref, ...rest, state: nextState });
});
function usePaneRouter() {
  return (0, import_react2.useContext)(PaneRouterContext);
}
var EMPTY_ARRAY$a = [];
function ReferencePreviewLink(props) {
  const { onClick, type, value } = props;
  const publishedId = getPublishedId(value == null ? void 0 : value._id);
  const documentPresence = useDocumentPresence(publishedId);
  const documentPreviewStore = useDocumentPreviewStore();
  const { ReferenceChildLink: ReferenceChildLink3 } = usePaneRouter();
  const Link2 = (0, import_react2.useCallback)(function LinkComponent(linkProps) {
    return (0, import_jsx_runtime2.jsx)(ReferenceChildLink3, { documentId: value == null ? void 0 : value._id, documentType: type == null ? void 0 : type.name, parentRefPath: EMPTY_ARRAY$a, ...linkProps });
  }, [ReferenceChildLink3, type == null ? void 0 : type.name, value == null ? void 0 : value._id]);
  return (0, import_jsx_runtime2.jsx)(PreviewCard$1, { __unstable_focusRing: true, as: Link2, "data-as": "a", onClick, radius: 2, children: (0, import_jsx_runtime2.jsx)(PaneItemPreview, { documentPreviewStore, icon: type == null ? void 0 : type.icon, layout: "compact", presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY$a, schemaType: type, value }) });
}
var __freeze$D = Object.freeze;
var __defProp$D = Object.defineProperty;
var __template$D = (cooked, raw) => __freeze$D(__defProp$D(cooked, "raw", { value: __freeze$D(raw || cooked.slice()) }));
var _a$D;
var _b$h;
var _c$7;
var _d$4;
var _e$3;
var ChevronWrapper = ut(Box)(_a$D || (_a$D = __template$D(["\n  margin-left: auto;\n"])));
var CrossDatasetReferencesDetails = ut.details(_b$h || (_b$h = __template$D(["\n  flex: none;\n\n  &[open] ", " {\n    transform: rotate(180deg);\n  }\n"])), ChevronWrapper);
var CrossDatasetReferencesSummary = ut.summary(_c$7 || (_c$7 = __template$D(["\n  list-style: none;\n\n  &::-webkit-details-marker {\n    display: none;\n  }\n"])));
var Table = ut.table(_d$4 || (_d$4 = __template$D(["\n  width: 100%;\n  text-align: left;\n  padding: 0 ", ";\n  border-collapse: collapse;\n\n  th {\n    padding: ", ";\n  }\n\n  td {\n    padding: 0 ", ";\n  }\n\n  tr > *:last-child {\n    text-align: right;\n  }\n"])), (_ref18) => {
  let { theme } = _ref18;
  return rem(theme.sanity.space[2]);
}, (_ref19) => {
  let { theme } = _ref19;
  return rem(theme.sanity.space[1]);
}, (_ref20) => {
  let { theme } = _ref20;
  return rem(theme.sanity.space[1]);
});
var DocumentIdFlex = ut(Flex)(_e$3 || (_e$3 = __template$D(["\n  min-height: 33px;\n"])));
var OtherReferenceCount = (props) => {
  const { t } = useTranslation2(structureLocaleNamespace);
  const difference = props.totalCount - props.references.length;
  if (!difference)
    return null;
  return (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: t("confirm-delete-dialog.other-reference-count.title", { count: difference }) }), (0, import_jsx_runtime2.jsx)(Tooltip, { portal: true, placement: "top", content: t("confirm-delete-dialog.other-reference-count.tooltip"), children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: (0, import_jsx_runtime2.jsx)(InfoOutlineIcon, {}) }) })] }) });
};
function ConfirmDeleteDialogBody(_ref21) {
  let { crossDatasetReferences, internalReferences, documentTitle, totalCount, action, datasetNames, hasUnknownDatasetNames, onReferenceLinkClick } = _ref21;
  const schema2 = useSchema();
  const toast = useToast();
  const { t } = useTranslation2(structureLocaleNamespace);
  const renderPreviewItem = (0, import_react2.useCallback)((item) => {
    const type = schema2.get(item._type);
    if (type) {
      return (0, import_jsx_runtime2.jsx)(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick });
    }
    return (
      // Padding added to match the ReferencePreviewLink styling
      (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { icon: UnknownIcon, title: t("confirm-delete-dialog.preview-item.preview-unavailable.title"), subtitle: t("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", { documentId: item._id }), layout: "default" }) })
    );
  }, [schema2, t, onReferenceLinkClick]);
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0) {
    return (0, import_jsx_runtime2.jsx)(Text, { as: "p", size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "confirm-delete-dialog.confirmation.text", context: action, components: { DocumentTitle: () => (0, import_jsx_runtime2.jsx)("strong", { children: documentTitle }) } }) });
  }
  const normalizedDatasetNames = [...datasetNames, ...hasUnknownDatasetNames ? ["unavailable"] : []];
  const datasetSubtitle = t("confirm-delete-dialog.cdr-summary.subtitle", { count: normalizedDatasetNames.length, datasets: normalizedDatasetNames.join(", "), context: hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : "" });
  return (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", gap: 4, children: [(0, import_jsx_runtime2.jsx)(Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: (0, import_jsx_runtime2.jsxs)(Flex, { children: [(0, import_jsx_runtime2.jsx)(Text, { "aria-hidden": "true", size: 1, children: (0, import_jsx_runtime2.jsx)(WarningOutlineIcon, {}) }), (0, import_jsx_runtime2.jsx)(Box, { flex: 1, marginLeft: 3, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referring-document-count.text", components: { DocumentTitle: () => documentTitle }, t, values: { count: totalCount } }) }) })] }) }), (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text", t, context: action, components: { DocumentTitle: () => documentTitle } }) }) }), (0, import_jsx_runtime2.jsx)(Card, { radius: 2, shadow: 1, flex: "auto", padding: 2, children: (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", children: [internalReferences.totalCount > 0 && (0, import_jsx_runtime2.jsxs)(Stack, { as: "ul", marginBottom: 2, space: 2, "data-testid": "internal-references", children: [internalReferences == null ? void 0 : internalReferences.references.map((item) => (0, import_jsx_runtime2.jsx)(Box, { as: "li", children: renderPreviewItem(item) }, item._id)), internalReferences.totalCount > internalReferences.references.length && (0, import_jsx_runtime2.jsx)(Box, { as: "li", padding: 3, children: (0, import_jsx_runtime2.jsx)(OtherReferenceCount, { ...internalReferences }) })] }), crossDatasetReferences.totalCount > 0 && (0, import_jsx_runtime2.jsxs)(CrossDatasetReferencesDetails, { "data-testid": "cross-dataset-references", style: {
    // only add the border if needed
    borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
  }, children: [(0, import_jsx_runtime2.jsx)(CrossDatasetReferencesSummary, { children: (0, import_jsx_runtime2.jsx)(Card, { as: "a", marginTop: internalReferences.totalCount > 0 ? 2 : 0, radius: 2, shadow: 1, paddingY: 1, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(DocumentsIcon, {}) }), (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime2.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: t("confirm-delete-dialog.cdr-summary.title", { count: normalizedDatasetNames.length, documentCount: t("confirm-delete-dialog.cdr-summary.document-count", { count: crossDatasetReferences.totalCount }) }) }), (0, import_jsx_runtime2.jsx)(Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: true, children: datasetSubtitle })] }), (0, import_jsx_runtime2.jsx)(ChevronWrapper, { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime2.jsx)(ChevronDownIcon, {}) }) })] }) }) }), (0, import_jsx_runtime2.jsxs)(Box, { overflow: "auto", paddingTop: 2, children: [(0, import_jsx_runtime2.jsxs)(Table, { children: [(0, import_jsx_runtime2.jsx)("thead", { children: (0, import_jsx_runtime2.jsxs)("tr", { children: [(0, import_jsx_runtime2.jsx)("th", { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: { minWidth: "5rem" }, weight: "medium", children: t("confirm-delete-dialog.cdr-table.project-id.label") }) }), (0, import_jsx_runtime2.jsx)("th", { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.dataset.label") }) }), (0, import_jsx_runtime2.jsx)("th", { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.document-id.label") }) })] }) }), (0, import_jsx_runtime2.jsx)("tbody", { children: crossDatasetReferences.references.filter((reference) => {
    return "projectId" in reference;
  }).map((_ref22, index) => {
    let { projectId, datasetName, documentId } = _ref22;
    return (
      // eslint-disable-next-line react/no-array-index-key
      (0, import_jsx_runtime2.jsxs)("tr", { children: [(0, import_jsx_runtime2.jsx)("td", { children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: projectId }) }), (0, import_jsx_runtime2.jsx)("td", { children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: datasetName || "unavailable" }) }), (0, import_jsx_runtime2.jsx)("td", { children: (0, import_jsx_runtime2.jsxs)(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [(0, import_jsx_runtime2.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: documentId || "unavailable" }), documentId && (0, import_jsx_runtime2.jsx)(import_react_copy_to_clipboard.default, { text: documentId, onCopy: () => {
        toast.push({ title: t("confirm-delete-dialog.cdr-table.id-copied-toast.title"), status: "success" });
      }, children: (0, import_jsx_runtime2.jsx)(Button2, { mode: "bleed", icon: CopyIcon, tooltipProps: { content: t("confirm-delete-dialog.cdr-table.copy-id-button.tooltip") } }) })] }) })] }, "".concat(documentId, "-").concat(index))
    );
  }) })] }), (0, import_jsx_runtime2.jsx)(OtherReferenceCount, { ...crossDatasetReferences })] })] })] }) }), (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text", t, context: action, components: { DocumentTitle: () => documentTitle } }) }) })] });
}
var __freeze$C = Object.freeze;
var __defProp$C = Object.defineProperty;
var __template$C = (cooked, raw) => __freeze$C(__defProp$C(cooked, "raw", { value: __freeze$C(raw || cooked.slice()) }));
var _a$C;
var _b$g;
var DialogBody = ut(Box)(_a$C || (_a$C = __template$C(["\n  box-sizing: border-box;\n"])));
var LoadingContainer = ut(Flex).attrs({ align: "center", direction: "column", justify: "center" })(_b$g || (_b$g = __template$C(["\n  height: 110px;\n"])));
function ConfirmDeleteDialog(_ref23) {
  let { id, type, action = "delete", onCancel, onConfirm } = _ref23;
  const { t } = useTranslation2(structureLocaleNamespace);
  const dialogId = "deletion-confirmation-".concat((0, import_react2.useId)());
  const { internalReferences, crossDatasetReferences, isLoading, totalCount, projectIds, datasetNames, hasUnknownDatasetNames } = useReferringDocuments(id);
  const documentTitle = (0, import_jsx_runtime2.jsx)(DocTitle, { document: (0, import_react2.useMemo)(() => ({ _id: id, _type: type }), [id, type]) });
  const showConfirmButton = !isLoading;
  return (0, import_jsx_runtime2.jsx)(Dialog2, { width: 1, id: dialogId, header: t("confirm-delete-dialog.header.text", { context: action }), footer: { cancelButton: { onClick: onCancel, text: t("confirm-delete-dialog.cancel-button.text") }, confirmButton: showConfirmButton ? { text: totalCount > 0 ? t("confirm-delete-dialog.confirm-anyway-button.text", { context: action }) : t("confirm-delete-dialog.confirm-button.text", { context: action }), onClick: onConfirm } : void 0 }, onClose: onCancel, onClickOutside: onCancel, children: (0, import_jsx_runtime2.jsx)(DialogBody, { children: crossDatasetReferences && internalReferences && !isLoading ? (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialogBody, { crossDatasetReferences, internalReferences, documentTitle, isLoading, totalCount, action, projectIds, datasetNames, hasUnknownDatasetNames, onReferenceLinkClick: onCancel }) : (0, import_jsx_runtime2.jsx)(LoadingContainer, { "data-testid": "loading-container", children: (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true, title: t("confirm-delete-dialog.loading.text") }) }) }) });
}
function ConfirmDeleteDialogContainer(props) {
  const { t } = useTranslation2(structureLocaleNamespace);
  const id = (0, import_react2.useId)();
  const [error, setError] = (0, import_react2.useState)(null);
  const handleRetry = (0, import_react2.useCallback)(() => setError(null), []);
  return error ? (0, import_jsx_runtime2.jsx)(Dialog2, { id: "dialog-error-".concat(id), "data-testid": "confirm-delete-error-dialog", header: t("confirm-delete-dialog.error.title.text"), footer: { confirmButton: { text: t("confirm-delete-dialog.error.retry-button.text"), onClick: handleRetry, tone: "default" } }, onClose: props.onCancel, children: (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t("confirm-delete-dialog.error.message.text") }) }) }) : (0, import_jsx_runtime2.jsx)(ErrorBoundary, { onCatch: setError, children: (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialog, { ...props }) });
}
var MENU_GROUP_POPOVER_PROPS = { constrainSize: true, placement: "left-start", portal: true };
function PaneMenuButtonItem(props) {
  const { disabled, isAfterGroup, node } = props;
  const getI18nText = useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider") {
    return (0, import_jsx_runtime2.jsx)(MenuDivider, {});
  }
  const { title } = getI18nText(node);
  if (node.type === "group") {
    if (node.children.length === 0) {
      return null;
    }
    if (node.expanded) {
      return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [isAfterGroup && (0, import_jsx_runtime2.jsx)(MenuDivider, {}), node.children.map((child, childIndex) => {
        var _a2;
        return (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { disabled: disabled || Boolean(node.disabled), isAfterGroup: ((_a2 = node.children[childIndex - 1]) == null ? void 0 : _a2.type) === "group", node: child }, child.key);
      })] });
    }
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [isAfterGroup && (0, import_jsx_runtime2.jsx)(MenuDivider, {}), (0, import_jsx_runtime2.jsx)(MenuGroup, { disabled, icon: node.icon, popover: MENU_GROUP_POPOVER_PROPS, text: title, children: node.children.map((child, childIndex) => {
      var _a2;
      return (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { disabled: disabled || Boolean(node.disabled), isAfterGroup: ((_a2 = node.children[childIndex - 1]) == null ? void 0 : _a2.type) === "group", node: child }, child.key);
    }) })] });
  }
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [isAfterGroup && (0, import_jsx_runtime2.jsx)(MenuDivider, {}), (0, import_jsx_runtime2.jsx)(PaneContextMenuItemResolver, { disabled, node })] });
}
function PaneContextMenuItemResolver(props) {
  const { node } = props;
  if (node.intent) {
    return (0, import_jsx_runtime2.jsx)(PaneContextIntentMenuItem, { ...props, intent: node.intent });
  }
  return (0, import_jsx_runtime2.jsx)(PaneContextMenuItem, { ...props });
}
function PaneContextMenuItem(props) {
  var _a2;
  const { disabled, node } = props;
  const tooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: node.disabled.reason });
  const { title } = useI18nText(node);
  return (0, import_jsx_runtime2.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: (0, import_jsx_runtime2.jsx)(MenuItem2, { disabled: disabled || Boolean(node.disabled), hotkeys: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"), icon: node.icon, iconRight: node.iconRight || node.selected && CheckmarkIcon, onClick: node.onAction, pressed: node.selected, text: title, tone: node.tone }) });
}
function PaneContextIntentMenuItem(props) {
  var _a2;
  const { disabled, intent, node } = props;
  const tooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: node.disabled.reason });
  const intentLink = useIntentLink({ intent: intent.type, params: intent.params });
  const handleClick = (0, import_react2.useCallback)((event) => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  const { title } = useI18nText(node);
  return (0, import_jsx_runtime2.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: (0, import_jsx_runtime2.jsx)(MenuItem2, { as: "a", disabled: disabled || Boolean(node.disabled), hotkeys: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"), href: intentLink.href, icon: node.icon, iconRight: node.selected ? CheckmarkIcon : void 0, onClick: handleClick, pressed: node.selected, text: title, tone: node.tone }) });
}
var CONTEXT_MENU_POPOVER_PROPS = { constrainSize: true, placement: "bottom", portal: true };
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => {
    return node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone);
  });
}
function PaneContextMenuButton(props) {
  const { nodes } = props;
  const id = (0, import_react2.useId)();
  const hasCritical = nodesHasTone(nodes, "critical");
  const hasCaution = nodesHasTone(nodes, "caution");
  return (0, import_jsx_runtime2.jsx)(MenuButton2, { button: (0, import_jsx_runtime2.jsx)(ContextMenuButton, { tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0 }), id, menu: (0, import_jsx_runtime2.jsx)(Menu, { children: nodes.map((node, nodeIndex) => {
    var _a2;
    const isAfterGroup = ((_a2 = nodes[nodeIndex - 1]) == null ? void 0 : _a2.type) === "group";
    return (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
  }) }), popover: CONTEXT_MENU_POPOVER_PROPS });
}
var PANE_DEBUG = false;
var PANE_COLLAPSED_WIDTH = 51;
var PANE_DEFAULT_MIN_WIDTH = PANE_COLLAPSED_WIDTH * 4;
var PaneContext = (0, import_react2.createContext)(null);
var __freeze$B = Object.freeze;
var __defProp$B = Object.defineProperty;
var __template$B = (cooked, raw) => __freeze$B(__defProp$B(cooked, "raw", { value: __freeze$B(raw || cooked.slice()) }));
var _a$B;
var Root$e = ut(Layer)(_a$B || (_a$B = __template$B(["\n  position: relative;\n  width: 1px;\n  min-width: 1px;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    width: 1px;\n    background-color: var(--card-border-color);\n  }\n\n  &:not([data-disabled]) {\n    cursor: ew-resize;\n    width: 9px;\n    min-width: 9px;\n    margin: 0 -4px;\n\n    &:before {\n      left: 4px;\n    }\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 9px;\n      bottom: 0;\n      background-color: var(--card-border-color);\n      opacity: 0;\n      transition: opacity 150ms;\n    }\n\n    &[data-dragging]:after,\n    &:hover:after {\n      opacity: 0.2;\n    }\n  }\n"])));
function PaneDivider(_ref24) {
  let { disabled, element } = _ref24;
  const { resize } = usePaneLayout();
  const [dragging, setDragging] = (0, import_react2.useState)(false);
  const handleMouseDown = (0, import_react2.useCallback)((event) => {
    if (!element)
      return;
    setDragging(true);
    event.preventDefault();
    const startX = event.pageX;
    resize("start", element, 0);
    const handleMouseMove = (e2) => {
      e2.preventDefault();
      const deltaX = e2.pageX - startX;
      resize("move", element, deltaX);
    };
    const handleMouseUp = (e2) => {
      e2.preventDefault();
      setDragging(false);
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      resize("end", element, 0);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [element, resize]);
  return (0, import_jsx_runtime2.jsx)(Root$e, { "data-disabled": disabled ? "" : void 0, "data-dragging": dragging ? "" : void 0, onMouseDown: handleMouseDown });
}
var __freeze$A = Object.freeze;
var __defProp$A = Object.defineProperty;
var __template$A = (cooked, raw) => __freeze$A(__defProp$A(cooked, "raw", { value: __freeze$A(raw || cooked.slice()) }));
var _a$A;
var Root$d = ut(Card)(_a$A || (_a$A = __template$A(["\n  outline: none;\n\n  // NOTE: This will render a border to the right side of each pane\n  // without taking up physical space.\n  box-shadow: 1px 0 0 var(--card-border-color);\n"])));
var Pane = (0, import_react2.forwardRef)(function Pane2(props, ref) {
  var _a2, _b2, _c2;
  const { children, currentMinWidth: currentMinWidthProp, currentMaxWidth: currentMaxWidthProp, flex: flexProp = 1, id, minWidth: minWidthProp, maxWidth: maxWidthProp, selected = false, ...restProps } = props;
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const { collapse, collapsed: layoutCollapsed, expand, expandedElement, mount, panes } = usePaneLayout();
  const pane = panes.find((p) => p.element === rootElement);
  const paneIndex = pane && panes.indexOf(pane);
  const nextPane = typeof paneIndex === "number" ? panes[paneIndex + 1] : void 0;
  const isLast = paneIndex === panes.length - 1;
  const collapsed = layoutCollapsed ? false : (pane == null ? void 0 : pane.collapsed) || false;
  const nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || false;
  const forwardedRef = useForwardedRef(ref);
  const flex = (_a2 = pane == null ? void 0 : pane.flex) != null ? _a2 : flexProp;
  const currentMinWidth = (_b2 = pane == null ? void 0 : pane.currentMinWidth) != null ? _b2 : currentMinWidthProp;
  const currentMaxWidth = (_c2 = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c2 : currentMaxWidthProp;
  const setRef = (0, import_react2.useCallback)((refValue) => {
    setRootElement(refValue);
    forwardedRef.current = refValue;
  }, [forwardedRef]);
  (0, import_react2.useEffect)(() => {
    if (!rootElement)
      return void 0;
    return mount(rootElement, { currentMinWidth: currentMinWidthProp, currentMaxWidth: currentMaxWidthProp, flex: flexProp, id, minWidth: minWidthProp, maxWidth: maxWidthProp });
  }, [currentMinWidthProp, currentMaxWidthProp, flexProp, id, minWidthProp, maxWidthProp, mount, rootElement]);
  const handleCollapse = (0, import_react2.useCallback)(() => {
    if (!rootElement)
      return;
    collapse(rootElement);
  }, [collapse, rootElement]);
  const handleExpand = (0, import_react2.useCallback)(() => {
    if (!rootElement)
      return;
    expand(rootElement);
  }, [expand, rootElement]);
  const contextValue = (0, import_react2.useMemo)(() => ({ collapse: handleCollapse, collapsed: layoutCollapsed ? false : collapsed, expand: handleExpand, index: paneIndex, isLast, rootElement }), [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]);
  const minWidth = (0, import_react2.useMemo)(() => {
    if (layoutCollapsed) {
      return void 0;
    }
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (currentMinWidth === 0) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    if (isLast) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    return currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]);
  const maxWidth = (0, import_react2.useMemo)(() => {
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (layoutCollapsed && isLast) {
      return void 0;
    }
    if (isLast) {
      if (maxWidthProp) {
        return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
      }
      return void 0;
    }
    return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]);
  const hidden = layoutCollapsed && !isLast;
  const divider = (0, import_react2.useMemo)(() => !isLast && !layoutCollapsed && (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneResizer", children: (0, import_jsx_runtime2.jsx)(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }), [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]);
  const style = (0, import_react2.useMemo)(() => ({ flex, minWidth, maxWidth: maxWidth === Infinity ? void 0 : maxWidth }), [flex, minWidth, maxWidth]);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "pane", children: (0, import_jsx_runtime2.jsx)(PaneContext.Provider, { value: contextValue, children: (0, import_jsx_runtime2.jsxs)(Root$d, { "data-testid": "pane", "data-ui": "Pane", tone: "inherit", hidden, id, overflow: layoutCollapsed ? void 0 : "hidden", ...restProps, "data-pane-collapsed": collapsed ? "" : void 0, "data-pane-index": paneIndex, "data-pane-selected": selected ? "" : void 0, ref: setRef, style, children: [PANE_DEBUG, (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: rootElement, children: !hidden && (0, import_jsx_runtime2.jsx)(Flex, { direction: "column", height: "fill", children }) })] }) }) }), divider] });
});
function usePane() {
  const pane = (0, import_react2.useContext)(PaneContext);
  if (!pane) {
    throw new Error("Pane: missing context value");
  }
  return pane;
}
var __freeze$z = Object.freeze;
var __defProp$z = Object.defineProperty;
var __template$z = (cooked, raw) => __freeze$z(__defProp$z(cooked, "raw", { value: __freeze$z(raw || cooked.slice()) }));
var _a$z;
var Root$c = ut(Card)(_a$z || (_a$z = __template$z(["\n  position: relative;\n  outline: none;\n"])));
Root$c.displayName = "PaneContent__root";
var PaneContent = (0, import_react2.forwardRef)(function PaneContent2(props, ref) {
  const { as, children, overflow, padding, ...restProps } = props;
  const { collapsed } = usePane();
  const { collapsed: layoutCollapsed } = usePaneLayout();
  return (0, import_jsx_runtime2.jsx)(Root$c, { "data-testid": "pane-content", forwardedAs: as, ...restProps, flex: 1, hidden: collapsed, overflow: layoutCollapsed ? void 0 : overflow, padding, ref, tone: "inherit", children });
});
var __freeze$y = Object.freeze;
var __defProp$y = Object.defineProperty;
var __template$y = (cooked, raw) => __freeze$y(__defProp$y(cooked, "raw", { value: __freeze$y(raw || cooked.slice()) }));
var _a$y;
var _b$f;
var Root$b = ut(Layer)(_a$y || (_a$y = __template$y(["\n  position: sticky;\n  bottom: 0;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: -1px;\n    border-bottom: 1px solid var(--card-border-color);\n  }\n"])));
var RootCard$1 = ut(Card)(_b$f || (_b$f = __template$y(["\n  padding-bottom: env(safe-area-inset-bottom);\n"])));
var PaneFooter = (0, import_react2.forwardRef)(function PaneFooter2(props, ref) {
  const { children, padding } = props;
  const { collapsed } = usePane();
  return (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime2.jsx)(Root$b, { "data-testid": "pane-footer", hidden: collapsed, ref, children: (0, import_jsx_runtime2.jsx)(RootCard$1, { tone: "inherit", children: (0, import_jsx_runtime2.jsx)(Box, { padding, children }) }) }) });
});
var __freeze$x = Object.freeze;
var __defProp$x = Object.defineProperty;
var __template$x = (cooked, raw) => __freeze$x(__defProp$x(cooked, "raw", { value: __freeze$x(raw || cooked.slice()) }));
var _a$x;
var _b$e;
var _c$6;
var _d$3;
var _e$2;
var _f$2;
var Root$a = ut(Layer)((_ref25) => {
  let { $border } = _ref25;
  return at(_a$x || (_a$x = __template$x(["\n    line-height: 0;\n    position: sticky;\n    top: 0;\n\n    &:not([data-collapsed]):after {\n      content: '';\n      display: block;\n      position: absolute;\n      left: 0;\n      right: 0;\n      bottom: -1px;\n      border-bottom: 1px solid ", ";\n      opacity: 1;\n    }\n  "])), $border ? "var(--card-border-color)" : "transparent");
});
var Layout = ut(Flex)(_b$e || (_b$e = __template$x(["\n  transform-origin: calc(51px / 2);\n\n  [data-collapsed] > div > & {\n    transform: rotate(90deg);\n  }\n"])));
var TitleCard = ut(Card)((_ref26) => {
  let { theme } = _ref26;
  const { fg, bg } = theme.sanity.color.card.enabled;
  return at(_c$6 || (_c$6 = __template$x(["\n    background-color: ", ";\n\n    [data-ui='Text'] {\n      color: ", ";\n    }\n  "])), bg, fg);
});
var TitleTextSkeleton = ut(TextSkeleton)(_d$3 || (_d$3 = __template$x(["\n  width: 66%;\n  max-width: 175px;\n"])));
var TitleText = ut(Text)(_e$2 || (_e$2 = __template$x(["\n  cursor: default;\n  outline: none;\n"])));
var TabsBox = ut(Box)((_ref27) => {
  let { theme } = _ref27;
  const { color, space } = theme.sanity;
  return at(_f$2 || (_f$2 = __template$x(["\n    overflow: hidden;\n    overflow: clip;\n    position: relative;\n\n    & > div {\n      white-space: nowrap;\n      overflow: auto;\n      /* Hide scrollbars */\n      scrollbar-width: none;\n      &::-webkit-scrollbar {\n        width: 0;\n        height: 0;\n      }\n    }\n\n    /* right padding */\n    & > div:after {\n      content: '';\n      display: inline-block;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      width: ", "px;\n      height: 1px;\n    }\n\n    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      background: linear-gradient(to right, ", ", var(--card-bg-color));\n      width: ", "px;\n      pointer-events: none;\n    }\n  "])), space[3], rgba(color.base.bg, 0), space[3]);
});
var PaneHeader = (0, import_react2.forwardRef)(function PaneHeader2(props, ref) {
  const { actions, backButton, border, contentAfter, loading, subActions, tabs, tabIndex, title } = props;
  const { collapse, collapsed, expand, rootElement: paneElement } = usePane();
  const paneRect = useElementRect(paneElement || null);
  const layoutStyle = (0, import_react2.useMemo)(() => ({ width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0 }), [collapsed, paneRect]);
  const handleTitleClick = (0, import_react2.useCallback)(() => {
    if (collapsed)
      return;
    collapse();
  }, [collapse, collapsed]);
  const handleLayoutClick = (0, import_react2.useCallback)(() => {
    if (!collapsed)
      return;
    expand();
  }, [collapsed, expand]);
  const showTabsOrSubActions = Boolean(!collapsed && (tabs || subActions));
  return (0, import_jsx_runtime2.jsx)(LayerProvider, { zOffset: 100, children: (0, import_jsx_runtime2.jsx)(Root$a, { $border: border, "data-collapsed": collapsed ? "" : void 0, "data-testid": "pane-header", ref, children: (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: (0, import_jsx_runtime2.jsxs)(Card, { "data-collapsed": collapsed ? "" : void 0, tone: "inherit", children: [(0, import_jsx_runtime2.jsxs)(Layout, { gap: 1, onClick: handleLayoutClick, padding: 3, paddingBottom: collapsed ? 3 : 2, sizing: "border", style: layoutStyle, children: [backButton && (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: backButton }), (0, import_jsx_runtime2.jsxs)(TitleCard, { __unstable_focusRing: true, flex: 1, forwardedAs: "button", onClick: handleTitleClick, paddingLeft: backButton ? 1 : 2, padding: 2, tabIndex, children: [loading && (0, import_jsx_runtime2.jsx)(TitleTextSkeleton, { animated: true, radius: 1, size: 1 }), !loading && (0, import_jsx_runtime2.jsx)(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title })] }), actions && (0, import_jsx_runtime2.jsx)(Flex, { align: "center", hidden: collapsed, children: (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) })] }), showTabsOrSubActions && (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", hidden: collapsed, overflow: "auto", paddingBottom: 3, paddingX: 3, children: [(0, import_jsx_runtime2.jsx)(TabsBox, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }), subActions && subActions] }), !collapsed && contentAfter && contentAfter] }) }) }) });
});
function getDisabledReason$1(node) {
  var _a2;
  const disabledReason = typeof node.disabled === "object" ? node.disabled.reason : void 0;
  const ariaLabel = typeof node.disabled === "object" && typeof ((_a2 = node.disabled) == null ? void 0 : _a2.reason) === "string" ? node.disabled.reason : "This is disabled";
  return { disabledReason, ariaLabel, isDisabled: Boolean(node.disabled) };
}
function PaneHeaderActionButton(props) {
  const { node } = props;
  if (node.type === "item") {
    return (0, import_jsx_runtime2.jsx)(PaneHeaderMenuItemActionButton, { node });
  }
  if (node.type === "group") {
    return (0, import_jsx_runtime2.jsx)(PaneHeaderMenuGroupActionButton, { node });
  }
  console.warn('unknown menu node (expected `type: "item" | "group"`):', node);
  return null;
}
function PaneHeaderMenuItemActionButton(props) {
  const { node } = props;
  const { title } = useI18nText(node);
  if (node.intent) {
    return (0, import_jsx_runtime2.jsx)(PaneHeaderActionIntentButton, { ...props, intent: node.intent });
  }
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return (0, import_jsx_runtime2.jsx)(StatusButton, { disabled: Boolean(node.disabled), icon: node.icon, onClick: node.onAction, selected: node.selected, tone: node.tone, "aria-label": ariaLabel, tooltipProps: { hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, content: isDisabled ? disabledReason : title } });
}
function PaneHeaderActionIntentButton(props) {
  const { intent, node } = props;
  const intentLink = useIntentLink({ intent: intent.type, params: intent.params });
  const handleClick = (0, import_react2.useCallback)((event) => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return (0, import_jsx_runtime2.jsx)(StatusButton, { as: "a", disabled: isDisabled, href: intentLink.href, icon: node.icon, onClick: handleClick, selected: node.selected, tone: node.tone, "aria-label": ariaLabel, tooltipProps: { hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, content: isDisabled ? disabledReason : node.title, placement: "bottom", portal: true } });
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a2;
  const { node } = props;
  const { title } = useI18nText(node);
  return (0, import_jsx_runtime2.jsx)(MenuButton2, { button: (0, import_jsx_runtime2.jsx)(Button2, { disabled: !!node.disabled, icon: (_a2 = node.icon) != null ? _a2 : UnknownIcon, label: title, mode: "bleed", tooltipProps: { content: node.title, portal: true } }), id: (0, import_react2.useId)(), menu: (0, import_jsx_runtime2.jsx)(Menu, { children: node.children.map((child, idx) => {
    var _a22;
    return (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { disabled: Boolean(node.disabled), isAfterGroup: ((_a22 = node.children[idx - 1]) == null ? void 0 : _a22.type) === "group", node: child }, child.key);
  }) }) });
}
var __freeze$w = Object.freeze;
var __defProp$w = Object.defineProperty;
var __template$w = (cooked, raw) => __freeze$w(__defProp$w(cooked, "raw", { value: __freeze$w(raw || cooked.slice()) }));
var _a$w;
var Root$9 = ut(Card)(_a$w || (_a$w = __template$w(["\n  transition: opacity 200ms;\n  position: relative;\n  z-index: 1;\n  padding-left: env(safe-area-inset-left);\n  padding-right: env(safe-area-inset-right);\n  opacity: 0;\n\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  &:not([data-collapsed]) {\n    overflow: auto;\n  }\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n\n  &[data-resizing] {\n    pointer-events: none;\n  }\n"])));
function _calcPaneResize(cache, left, right, deltaX) {
  var _a2, _b2;
  const sum = { flex: cache.left.flex + cache.right.flex, width: cache.left.width + cache.right.width };
  const leftMinWidth = (_a2 = left.minWidth) != null ? _a2 : PANE_DEFAULT_MIN_WIDTH;
  const rightMinWidth = (_b2 = right.minWidth) != null ? _b2 : PANE_DEFAULT_MIN_WIDTH;
  const leftMaxWidth = Math.min(left.maxWidth || Infinity, sum.width - rightMinWidth);
  const rightMaxWidth = Math.min(right.maxWidth || Infinity, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  if (minDeltaX < rightMinDeltaX) {
    minDeltaX = rightMinDeltaX;
  }
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  if (maxDeltaX > leftMaxDeltaX) {
    maxDeltaX = leftMaxDeltaX;
  }
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX);
  const leftW = cache.left.width + _deltaX;
  const rightW = cache.right.width - _deltaX;
  const leftFlex = leftW / sum.width * sum.flex;
  const rightFlex = rightW / sum.width * sum.flex;
  return { leftFlex, leftW, rightFlex, rightW };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e2 = el;
  while (e2 !== rootElement) {
    const parentElement = e2.parentElement;
    if (!parentElement)
      return path;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e2);
    path.unshift(index);
    if (parentElement === rootElement) {
      return path;
    }
    e2 = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements) {
    map2.set(element, _getDOMPath(rootElement, element));
  }
  const _sortByElementPath = (a, b) => {
    const _a2 = map2.get(a) || EMPTY_PATH;
    const _b2 = map2.get(b) || EMPTY_PATH;
    const len = Math.max(_a2.length, _b2.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a2[i] || -1;
      const bIndex = _b2[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [];
  const elements = [];
  const optionsMap = /* @__PURE__ */ new WeakMap();
  const userCollapsedElementSet = /* @__PURE__ */ new Set();
  const cache = {};
  let rootElement = null;
  let rootWidth = 0;
  let expandedElement = null;
  let resizeDataMap = /* @__PURE__ */ new Map();
  let resizing = false;
  function collapse(element) {
    userCollapsedElementSet.add(element);
    if (expandedElement === element) {
      expandedElement = null;
    }
    _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element);
    expandedElement = element;
    _notifyObservers();
  }
  function mount(element, options) {
    optionsMap.set(element, { ...options, original: options });
    elements.push(element);
    if (rootElement) {
      _sortElements(rootElement, elements);
    }
    expand(element);
    return () => {
      const idx = elements.indexOf(element);
      if (idx > -1) {
        elements.splice(idx, 1);
      }
      optionsMap.delete(element);
      _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a2, _b2, _c2, _d2;
    const leftIndex = elements.indexOf(leftElement);
    const leftOptions = optionsMap.get(leftElement);
    if (!leftOptions)
      return;
    const rightElement = elements[leftIndex + 1];
    const rightOptions = optionsMap.get(rightElement);
    if (!rightOptions)
      return;
    if (type === "start") {
      resizing = true;
      cache.left = { element: leftElement, flex: leftOptions.flex || 1, width: leftElement.offsetWidth };
      cache.right = { element: rightElement, flex: rightOptions.flex || 1, width: rightElement.offsetWidth };
      _notifyObservers();
    }
    if (type === "move" && cache.left && cache.right) {
      resizeDataMap = /* @__PURE__ */ new Map();
      const { leftW, rightW, leftFlex, rightFlex } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX);
      resizeDataMap.set(leftElement, { flex: leftFlex, width: leftW });
      resizeDataMap.set(rightElement, { flex: rightFlex, width: rightW });
      _notifyObservers();
    }
    if (type === "end") {
      resizing = false;
      const leftResizeData = resizeDataMap.get(leftElement);
      const rightResizeData = resizeDataMap.get(rightElement);
      optionsMap.set(leftElement, { ...leftOptions, currentMinWidth: 0, currentMaxWidth: (_a2 = leftOptions.maxWidth) != null ? _a2 : Infinity, flex: (_b2 = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b2 : leftOptions.flex });
      optionsMap.set(rightElement, { ...rightOptions, currentMinWidth: 0, currentMaxWidth: (_c2 = leftOptions.maxWidth) != null ? _c2 : Infinity, flex: (_d2 = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d2 : rightOptions.flex });
      resizeDataMap = /* @__PURE__ */ new Map();
      delete cache.left;
      delete cache.right;
      _notifyObservers();
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth;
    _notifyObservers();
  }
  function subscribe(observer) {
    observers.push(observer);
    return () => {
      const idx = observers.push(observer);
      if (idx > -1) {
        observers.splice(idx, 1);
      }
    };
  }
  return { collapse, expand, mount, resize, setRootElement, setRootWidth, subscribe };
  function _notifyObservers() {
    var _a2, _b2, _c2, _d2;
    if (!rootWidth)
      return;
    const _elements = [];
    for (const element of elements) {
      if (element !== expandedElement) {
        _elements.unshift(element);
      }
    }
    if (expandedElement) {
      _elements.unshift(expandedElement);
    }
    const dataMap = /* @__PURE__ */ new WeakMap();
    const len = _elements.length;
    const lastElement = _elements[0];
    const collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options) {
        continue;
      }
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH;
      const isLast = element === lastElement;
      const userCollapsed = userCollapsedElementSet.has(element);
      const sizeCollapsed = minWidth > remaingWidth;
      const collapsed = isLast ? false : userCollapsed || sizeCollapsed;
      const resizeData = resizeDataMap.get(element);
      dataMap.set(element, { element, collapsed, currentMinWidth: (_a2 = resizeData == null ? void 0 : resizeData.width) != null ? _a2 : options.currentMinWidth, currentMaxWidth: (_b2 = resizeData == null ? void 0 : resizeData.width) != null ? _b2 : options.currentMaxWidth, flex: (_d2 = (_c2 = resizeData == null ? void 0 : resizeData.flex) != null ? _c2 : options.flex) != null ? _d2 : 1 });
      if (collapsed) {
        remaingWidth -= PANE_COLLAPSED_WIDTH;
      } else {
        remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
      }
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      if (data)
        panes.push(data);
    }
    for (const observer of observers) {
      observer({ expandedElement: expandedElement || elements[elements.length - 1] || null, panes, resizing });
    }
  }
}
function PaneLayout(props) {
  const { children, minWidth, onCollapse, onExpand, ...restProps } = props;
  const controller = (0, import_react2.useMemo)(() => createPaneLayoutController(), []);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const rootRect = useElementRect(rootElement);
  const width = (rootRect == null ? void 0 : rootRect.width) || 0;
  const collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth;
  const [state2, setState] = (0, import_react2.useState)({ expandedElement: null, panes: [], resizing: false });
  (0, import_react2.useEffect)(() => controller.setRootElement(rootElement), [controller, rootElement]);
  (0, import_react2.useEffect)(() => controller.setRootWidth(width), [controller, width]);
  (0, import_react2.useEffect)(() => controller.subscribe(setState), [controller]);
  (0, import_react2.useEffect)(() => {
    if (collapsed === void 0)
      return;
    if (collapsed && onCollapse)
      onCollapse();
    if (!collapsed && onExpand)
      onExpand();
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = (0, import_react2.useMemo)(() => ({ collapse: controller.collapse, collapsed, expand: controller.expand, expandedElement: state2.expandedElement, mount: controller.mount, panes: state2.panes, resize: controller.resize, resizing: state2.resizing }), [collapsed, controller, state2.expandedElement, state2.panes, state2.resizing]);
  return (0, import_jsx_runtime2.jsx)(PaneLayoutContext.Provider, { value: paneLayout, children: (0, import_jsx_runtime2.jsx)(Root$9, { "data-ui": "PaneLayout", ...restProps, "data-collapsed": collapsed ? "" : void 0, "data-resizing": state2.resizing ? "" : void 0, "data-mounted": width ? "" : void 0, ref: setRootElement, children }) });
}
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
var isNotMenuNodeButton = (0, import_negate.default)(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a2, _b2;
  const { fieldActions = [], menuItems, menuItemGroups } = params;
  const nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, "".concat(i, "-").concat(a.type)));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups) {
    const group = groups.find((g) => g.key === itemGroup.id);
    if (!group) {
      groups.push({ type: "group", key: itemGroup.id, children: [], expanded: true, renderAsButton: false, title: itemGroup.title, i18n: itemGroup.i18n });
    }
  }
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    if (item.group && !group) {
      group = { type: "group", key: item.group, expanded: true, icon: item.icon, title: item.group, children: [], renderAsButton: false };
      groups.push(group);
    }
    if (group) {
      group.children.push({ type: "item", key: "".concat(keyOffset + i, "-item"), hotkey: item.shortcut, icon: item.icon, onAction: () => params.actionHandler(item), renderAsButton: (_a2 = item.showAsAction) != null ? _a2 : false, selected: item.selected, title: item.title, i18n: item.i18n, tone: item.tone });
    } else {
      ungroupedItems.push({ type: "item", key: "".concat(keyOffset + i, "-item"), hotkey: item.shortcut, icon: item.icon, onAction: () => params.actionHandler(item), renderAsButton: (_b2 = item.showAsAction) != null ? _b2 : false, selected: item.selected, title: item.title, i18n: item.i18n, tone: item.tone });
    }
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a2, _b2, _c2;
  if (a.type === "divider") {
    return { type: "divider", key };
  }
  if (a.type === "group") {
    return { type: "group", key, children: a.children.map((child, childIdx) => mapFieldActionToPaneMenuNode(child, "".concat(key, "-").concat(childIdx, "-").concat(child.type))), disabled: a.disabled, expanded: (_a2 = a.expanded) != null ? _a2 : true, icon: a.icon, title: a.title, i18n: a.i18n, renderAsButton: (_b2 = a.renderAsButton) != null ? _b2 : false };
  }
  return { type: "item", key, intent: a.intent, disabled: a.disabled, icon: a.icon, iconRight: a.iconRight, onAction: a.onAction, renderAsButton: (_c2 = a.renderAsButton) != null ? _c2 : false, selected: a.selected, title: a.title, i18n: a.i18n, tone: a.tone };
}
var IntentButton = (0, import_react2.forwardRef)(function IntentButton2(props, ref) {
  const { intent, ...restProps } = props;
  const Link2 = (0, import_react2.useMemo)(() => (
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (0, import_react2.forwardRef)(function Link22(linkProps, linkRef) {
      return (0, import_jsx_runtime2.jsx)(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef });
    })
  ), [intent]);
  return props.disabled ? (0, import_jsx_runtime2.jsx)(Button2, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : (0, import_jsx_runtime2.jsx)(Button2, { ...restProps, as: Link2, "data-as": "a", ref });
});
function InsufficientPermissionsMessageTooltip(_ref28) {
  let { reveal, context, loading, children } = _ref28;
  const currentUser = useCurrentUser();
  const { t } = useTranslation2(structureLocaleNamespace);
  if (!reveal) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  }
  return (0, import_jsx_runtime2.jsx)(Tooltip, { content: loading ? t("insufficient-permissions-message-tooltip.loading-text") : (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context, currentUser }), portal: true, children: (0, import_jsx_runtime2.jsx)("div", { children }) });
}
var POPOVER_PROPS$3 = { constrainSize: true, placement: "bottom", portal: true };
var getIntent = (schema2, templates, item) => {
  var _a2;
  const typeName = (_a2 = templates.find((t) => t.id === item.templateId)) == null ? void 0 : _a2.schemaType;
  if (!typeName)
    return null;
  const baseParams = { template: item.templateId, type: typeName, id: item.initialDocumentId };
  return { type: "create", params: item.parameters ? [baseParams, item.parameters] : baseParams };
};
function PaneHeaderCreateButton(_ref29) {
  let { templateItems } = _ref29;
  const schema2 = useSchema();
  const templates = useTemplates();
  const { t } = useTranslation2(structureLocaleNamespace);
  const getI18nText = useGetI18nText([...templateItems, ...templates]);
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({ templateItems });
  const nothingGranted = (0, import_react2.useMemo)(() => {
    return !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every((permission) => !permission.granted));
  }, [isTemplatePermissionsLoading, templatePermissions]);
  const permissionsById = (0, import_react2.useMemo)(() => {
    if (!templatePermissions)
      return {};
    return templatePermissions.reduce((acc, permission) => {
      acc[permission.id] = permission;
      return acc;
    }, {});
  }, [templatePermissions]);
  if (nothingGranted) {
    return (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: true, loading: isTemplatePermissionsLoading, children: (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": t("pane-header.disabled-created-button.aria-label"), icon: AddIcon, "data-testid": "action-intent-button", disabled: true, mode: "bleed", tooltipProps: null }) });
  }
  if (templateItems.length === 1) {
    const firstItem = templateItems[0];
    const permissions = permissionsById[firstItem.id];
    const disabled = !(permissions == null ? void 0 : permissions.granted);
    const intent = getIntent(schema2, templates, firstItem);
    if (!intent)
      return null;
    return (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessageTooltip, { reveal: disabled, loading: isTemplatePermissionsLoading, context: "create-document-type", children: (0, import_jsx_runtime2.jsx)(IntentButton, { "aria-label": getI18nText(firstItem).title, icon: firstItem.icon || AddIcon, intent, mode: "bleed", disabled, "data-testid": "action-intent-button", tooltipProps: disabled ? null : { content: t("pane-header.create-new-button.tooltip") } }) });
  }
  return (0, import_jsx_runtime2.jsx)(MenuButton2, { button: (0, import_jsx_runtime2.jsx)(Button2, { icon: AddIcon, mode: "bleed", "data-testid": "multi-action-intent-button", tooltipProps: { content: t("pane-header.create-new-button.tooltip") } }), id: "create-menu", menu: (0, import_jsx_runtime2.jsx)(Menu, { children: templateItems.map((item, itemIndex) => {
    const permissions = permissionsById[item.id];
    const disabled = !(permissions == null ? void 0 : permissions.granted);
    const intent = getIntent(schema2, templates, item);
    const template = templates.find((i) => i.id === item.templateId);
    if (!template || !intent)
      return null;
    const Link2 = (0, import_react2.forwardRef)((linkProps, linkRef) => disabled ? (0, import_jsx_runtime2.jsx)("button", { type: "button", disabled: true, ...linkProps, ref: linkRef }) : (0, import_jsx_runtime2.jsx)(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef }));
    Link2.displayName = "Link";
    const { title } = getI18nText({
      ...item,
      // replace the title with the template title
      title: item.title || getI18nText(template).title
    });
    return (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: disabled, loading: isTemplatePermissionsLoading, children: (0, import_jsx_runtime2.jsx)(MenuItem2, { as: Link2, "data-as": disabled ? "button" : "a", text: title, "aria-label": disabled ? t("pane-header.disabled-created-button.aria-label") : title, disabled, "data-testid": "action-intent-button-".concat(itemIndex) }) }, item.id);
  }) }), popover: POPOVER_PROPS$3 });
}
function isNonNullable(value) {
  return value !== null && value !== void 0;
}
var hashObject = (value) => {
  const sortObject = (v) => {
    if (typeof v !== "object" || !v)
      return v;
    if (Array.isArray(v))
      return v.map(sortObject);
    return Object.entries(v).sort((_ref30, _ref31) => {
      let [keyA] = _ref30;
      let [keyB] = _ref31;
      return keyA.localeCompare(keyB, "en");
    });
  };
  const normalize = (v) => JSON.parse(JSON.stringify(v));
  return JSON.stringify(sortObject(normalize(value)));
};
var PaneHeaderActions = (0, import_react2.memo)(function PaneHeaderActions2(props) {
  const { initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$9, menuItems = EMPTY_ARRAY$9, menuItemGroups = EMPTY_ARRAY$9, actionHandlers = EMPTY_OBJECT } = props;
  const templates = useTemplates();
  const handleAction = (0, import_react2.useCallback)((item) => {
    if (typeof item.action === "string" && !(item.action in actionHandlers)) {
      console.warn("No handler for action:", item.action);
      return false;
    }
    const handler = (
      // eslint-disable-next-line no-nested-ternary
      typeof item.action === "function" ? item.action : typeof item.action === "string" ? actionHandlers[item.action] : null
    );
    if (handler) {
      handler(item.params);
      return true;
    }
    return false;
  }, [actionHandlers]);
  const menuNodes = (0, import_react2.useMemo)(() => resolveMenuNodes({ actionHandler: handleAction, menuItemGroups, menuItems: menuItems.filter((item) => {
    var _a2;
    return ((_a2 = item.intent) == null ? void 0 : _a2.type) !== "create";
  }) }), [handleAction, menuItemGroups, menuItems]);
  const actionNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const initialValueTemplateItemFromMenuItems = (0, import_react2.useMemo)(() => {
    return menuItems.map((item, menuItemIndex) => {
      var _a2;
      if (((_a2 = item.intent) == null ? void 0 : _a2.type) !== "create")
        return null;
      const { params } = item.intent;
      if (!params)
        return null;
      const intentParams = Array.isArray(params) ? params[0] : params;
      const templateParams = Array.isArray(params) ? params[1] : void 0;
      const templateId = intentParams.template || intentParams.type;
      if (!templateId)
        return null;
      const template = templates.find((t) => t.id === templateId);
      if (!template)
        return null;
      const initialDocumentId = intentParams.id;
      return { item, template, templateParams, menuItemIndex, initialDocumentId };
    }).filter(isNonNullable).map((_ref32) => {
      let { initialDocumentId, item, template, menuItemIndex, templateParams } = _ref32;
      const initialValueTemplateItem = { id: "menuItem".concat(menuItemIndex), initialDocumentId, templateId: template.id, type: "initialValueTemplateItem", title: item.title || template.title, i18n: item.i18n || template.i18n, icon: item.icon, description: template.description, parameters: templateParams, schemaType: template.schemaType };
      return initialValueTemplateItem;
    });
  }, [menuItems, templates]);
  const combinedInitialValueTemplates = (0, import_react2.useMemo)(() => {
    return (0, import_uniqBy2.default)([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
  }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, children: [combinedInitialValueTemplates.length > 0 && (0, import_jsx_runtime2.jsx)(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }), actionNodes.map((node) => (0, import_jsx_runtime2.jsx)(PaneHeaderActionButton, { node }, node.key)), contextMenuNodes.length > 0 && (0, import_jsx_runtime2.jsx)(PaneContextMenuButton, { nodes: contextMenuNodes })] });
});
function MissingSchemaType(props) {
  const { t } = useTranslation2(structureLocaleNamespace);
  const { layout, value } = props;
  return (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { title: (0, import_jsx_runtime2.jsx)("em", { children: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "pane-item.missing-schema-type.title", components: { Code: "code" }, values: { documentType: value._type } }) }), subtitle: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "pane-item.missing-schema-type.subtitle", components: { Code: "code" }, values: { documentId: value._id } }), media: () => (0, import_jsx_runtime2.jsx)(WarningOutlineIcon, {}), layout });
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  if (icon === false) {
    return false;
  }
  return icon || schemaType && schemaType.icon || defaultIcon || false;
}
function PaneItem(props) {
  const { icon, id, layout = "default", pressed, schemaType, selected, title, value, margin, marginBottom, marginTop } = props;
  const schema2 = useSchema();
  const documentPreviewStore = useDocumentPreviewStore();
  const { ChildLink: ChildLink3 } = usePaneRouter();
  const documentPresence = useDocumentPresence(id);
  const hasSchemaType = Boolean(schemaType && schemaType.name && schema2.get(schemaType.name));
  const [clicked, setClicked] = (0, import_react2.useState)(false);
  const preview = (0, import_react2.useMemo)(() => {
    if (value && isSanityDocument(value)) {
      if (!schemaType || !hasSchemaType) {
        return (0, import_jsx_runtime2.jsx)(MissingSchemaType, { value });
      }
      return (0, import_jsx_runtime2.jsx)(PaneItemPreview, { documentPreviewStore, icon: getIconWithFallback(icon, schemaType, DocumentIcon), layout, schemaType, value, presence: documentPresence });
    }
    return (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { status: (0, import_jsx_runtime2.jsx)(Box, { style: { opacity: 0.5 }, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime2.jsx)(ChevronRightIcon, {}) }) }), icon: getIconWithFallback(icon, schemaType, FolderIcon), layout: "compact", title });
  }, [documentPreviewStore, hasSchemaType, icon, layout, schemaType, title, value, documentPresence]);
  const Link2 = (0, import_react2.useMemo)(() => function LinkComponent(linkProps) {
    return (0, import_jsx_runtime2.jsx)(ChildLink3, { ...linkProps, childId: id });
  }, [ChildLink3, id]);
  const handleClick = (0, import_react2.useCallback)((e2) => {
    if (e2.metaKey) {
      setClicked(false);
      return;
    }
    setClicked(true);
  }, []);
  (0, import_react2.useEffect)(() => setClicked(false), [selected]);
  return (0, import_jsx_runtime2.jsx)(PreviewCard$1, { __unstable_focusRing: true, as: Link2, "data-as": "a", margin, marginBottom, marginTop, onClick: handleClick, pressed, radius: 2, selected: selected || clicked, sizing: "border", tabIndex: -1, tone: "inherit", children: preview });
}
var DocumentPaneContext = (0, import_react2.createContext)(null);
function useDocumentPane() {
  const documentPane = (0, import_react2.useContext)(DocumentPaneContext);
  if (!documentPane) {
    throw new Error("DocumentPane: missing context value");
  }
  return documentPane;
}
var DISABLED_REASON_TITLE_KEY$1 = { NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete", NOT_READY: "action.delete.disabled.not-ready" };
var DeleteAction = (_ref33) => {
  let { id, type, draft, onComplete } = _ref33;
  const { setIsDeleting: paneSetIsDeleting } = useDocumentPane();
  const { delete: deleteOp } = useDocumentOperation(id, type);
  const [isDeleting, setIsDeleting] = (0, import_react2.useState)(false);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleCancel = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    setIsDeleting(true);
    setConfirmDialogOpen(false);
    paneSetIsDeleting(true);
    deleteOp.execute();
    onComplete();
  }, [deleteOp, onComplete, paneSetIsDeleting]);
  const handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "delete" });
  const currentUser = useCurrentUser();
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "critical", icon: TrashIcon, disabled: true, label: t("action.delete.label"), title: (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "delete-document", currentUser }) };
  }
  return { tone: "critical", icon: TrashIcon, disabled: isDeleting || Boolean(deleteOp.disabled) || isPermissionsLoading, title: deleteOp.disabled && t(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) || "", label: isDeleting ? t("action.delete.running.label") : t("action.delete.label"), shortcut: "Ctrl+Alt+D", onHandle: handle, dialog: isConfirmDialogOpen && { type: "custom", component: (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialogContainer, { action: "delete", id: (draft == null ? void 0 : draft._id) || id, type, onCancel: handleCancel, onConfirm: handleConfirm }) } };
};
DeleteAction.action = "delete";
var DISABLED_REASON_KEY$2 = { NO_CHANGES: "action.discard-changes.disabled.no-changes", NOT_PUBLISHED: "action.discard-changes.disabled.not-published", NOT_READY: "action.discard-changes.disabled.not-ready" };
var DiscardChangesAction = (_ref34) => {
  let { id, type, published, liveEdit, onComplete } = _ref34;
  const { discardChanges } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "discardDraft" });
  const currentUser = useCurrentUser();
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    discardChanges.execute();
    onComplete();
  }, [discardChanges, onComplete]);
  const handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = (0, import_react2.useMemo)(() => isConfirmDialogOpen && { type: "confirm", tone: "critical", onCancel: onComplete, onConfirm: handleConfirm, message: t("action.discard-changes.confirm-dialog.confirm-discard-changes") }, [handleConfirm, isConfirmDialogOpen, onComplete, t]);
  if (!published || liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "critical", icon: ResetIcon, disabled: true, label: t("action.discard-changes.label"), title: (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "discard-changes", currentUser }) };
  }
  return { tone: "critical", icon: ResetIcon, disabled: Boolean(discardChanges.disabled) || isPermissionsLoading, title: discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || "", label: t("action.discard-changes.label"), onHandle: handle, dialog };
};
DiscardChangesAction.action = "discardChanges";
var DISABLED_REASON_KEY$1 = { NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate", NOT_READY: "action.duplicate.disabled.not-ready" };
var DuplicateAction = (_ref35) => {
  let { id, type, onComplete } = _ref35;
  const { duplicate } = useDocumentOperation(id, type);
  const { navigateIntent } = useRouter();
  const [isDuplicating, setDuplicating] = (0, import_react2.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "duplicate" });
  const { t } = useTranslation2(structureLocaleNamespace);
  const currentUser = useCurrentUser();
  const handle = (0, import_react2.useCallback)(() => {
    const dupeId = v4_default();
    setDuplicating(true);
    duplicate.execute(dupeId);
    navigateIntent("edit", { id: dupeId, type });
    onComplete();
  }, [duplicate, navigateIntent, onComplete, type]);
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { icon: CopyIcon, disabled: true, label: t("action.duplicate.label"), title: (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "duplicate-document", currentUser }) };
  }
  return { icon: CopyIcon, disabled: isDuplicating || Boolean(duplicate.disabled) || isPermissionsLoading, label: isDuplicating ? t("action.duplicate.running.label") : t("action.duplicate.label"), title: duplicate.disabled ? t(DISABLED_REASON_KEY$1[duplicate.disabled]) : "", onHandle: handle };
};
DuplicateAction.action = "duplicate";
var HistoryRestoreAction = (_ref36) => {
  let { id, type, revision, onComplete } = _ref36;
  const { restore } = useDocumentOperation(id, type);
  const event = useDocumentOperationEvent(id, type);
  const { navigateIntent } = useRouter();
  const prevEvent = (0, import_react2.useRef)(event);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    restore.execute(revision);
    onComplete();
  }, [restore, revision, onComplete]);
  (0, import_react2.useEffect)(() => {
    if (!event || event === prevEvent.current)
      return;
    if (event.type === "success" && event.op === "restore") {
      navigateIntent("edit", { id, type });
    }
    prevEvent.current = event;
  }, [event, id, navigateIntent, type]);
  const handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = (0, import_react2.useMemo)(() => {
    if (isConfirmDialogOpen) {
      return { type: "confirm", tone: "critical", onCancel: onComplete, onConfirm: handleConfirm, message: t("action.restore.confirm.message") };
    }
    return null;
  }, [handleConfirm, isConfirmDialogOpen, onComplete, t]);
  const isRevisionInitialVersion = revision === "@initial";
  const isRevisionLatestVersion = revision === void 0;
  if (isRevisionLatestVersion) {
    return null;
  }
  return { label: t("action.restore.label"), color: "primary", onHandle: handle, title: t(isRevisionInitialVersion ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip"), icon: RestoreIcon, dialog, disabled: isRevisionInitialVersion };
};
HistoryRestoreAction.action = "restore";
var DISABLED_REASON_TITLE_KEY = { LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled", ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip", NO_CHANGES: "action.publish.no-changes.tooltip", NOT_READY: "action.publish.disabled.not-ready" };
function getDisabledReason(reason, publishedAt, t) {
  if (reason === "ALREADY_PUBLISHED" && publishedAt) {
    return (0, import_jsx_runtime2.jsx)(AlreadyPublished, { publishedAt });
  }
  return t(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished(_ref37) {
  let { publishedAt } = _ref37;
  const { t } = useTranslation2(structureLocaleNamespace);
  const timeSincePublished = useRelativeTime(publishedAt);
  return (0, import_jsx_runtime2.jsx)("span", { children: t("action.publish.already-published.tooltip", { timeSincePublished }) });
}
var PublishAction = (props) => {
  var _a2;
  const { id, type, liveEdit, draft, published } = props;
  const [publishState, setPublishState] = (0, import_react2.useState)(null);
  const { publish } = useDocumentOperation(id, type);
  const validationStatus = useValidationStatus(id, type);
  const syncState = useSyncState(id, type);
  const { changesOpen, onHistoryOpen, documentId, documentType } = useDocumentPane();
  const editState = useEditState(documentId, documentType);
  const { t } = useTranslation2(structureLocaleNamespace);
  const revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev;
  const hasValidationErrors = validationStatus.validation.some(isValidationErrorMarker);
  const [publishScheduled, setPublishScheduled] = (0, import_react2.useState)(false);
  const isSyncing = syncState.isSyncing;
  const isValidating = validationStatus.isValidating;
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "publish" });
  const currentUser = useCurrentUser();
  const title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t) || "" : hasValidationErrors ? t("action.publish.validation-issues.tooltip") : "";
  const hasDraft = Boolean(draft);
  const doPublish = (0, import_react2.useCallback)(() => {
    publish.execute();
    setPublishState("publishing");
  }, [publish]);
  (0, import_react2.useEffect)(() => {
    const validationComplete = validationStatus.isValidating === false && validationStatus.revision !== revision;
    if (!publishScheduled || isSyncing || !validationComplete) {
      return;
    }
    if (!hasValidationErrors) {
      doPublish();
    }
    setPublishScheduled(false);
  }, [isSyncing, doPublish, hasValidationErrors, publishScheduled, validationStatus.revision, revision, isValidating, validationStatus.isValidating]);
  (0, import_react2.useEffect)(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    if (didPublish) {
      if (changesOpen) {
        onHistoryOpen();
      }
    }
    const nextState = didPublish ? "published" : null;
    const delay2 = didPublish ? 200 : 4e3;
    const timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, delay2);
    return () => clearTimeout(timer2);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const handle = (0, import_react2.useCallback)(() => {
    if (syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision) {
      setPublishScheduled(true);
    } else {
      doPublish();
    }
  }, [syncState.isSyncing, validationStatus.isValidating, validationStatus.revision, revision, doPublish]);
  if (liveEdit) {
    return { tone: "default", icon: PublishIcon, label: t("action.publish.live-edit.label"), title: t("action.publish.live-edit.tooltip"), disabled: true };
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "default", icon: PublishIcon, label: "Publish", title: (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "publish-document", currentUser }), disabled: true };
  }
  const disabled = Boolean(publishScheduled || ((_a2 = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a2.enabled) || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "default",
    label: (
      // eslint-disable-next-line no-nested-ternary
      publishState === "published" ? t("action.publish.published.label") : publishScheduled || publishState === "publishing" ? t("action.publish.running.label") : t("action.publish.draft.label")
    ),
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? t("action.publish.waiting") : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
var DISABLED_REASON_KEY = { NOT_PUBLISHED: "action.unpublish.disabled.not-published", NOT_READY: "action.unpublish.disabled.not-ready", LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled" };
var UnpublishAction = (_ref38) => {
  let { id, type, draft, onComplete, liveEdit } = _ref38;
  const { unpublish } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "unpublish" });
  const currentUser = useCurrentUser();
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleCancel = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false);
    unpublish.execute();
    onComplete();
  }, [onComplete, unpublish]);
  const dialog = (0, import_react2.useMemo)(() => {
    if (isConfirmDialogOpen) {
      return { type: "dialog", onClose: onComplete, content: (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialogContainer, { id: (draft == null ? void 0 : draft._id) || id, type, action: "unpublish", onCancel: handleCancel, onConfirm: handleConfirm }) };
    }
    return null;
  }, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  if (liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "critical", icon: UnpublishIcon, label: "Unpublish", title: (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }), disabled: true };
  }
  return { tone: "critical", icon: UnpublishIcon, disabled: Boolean(unpublish.disabled) || isPermissionsLoading, label: t("action.unpublish.label"), title: unpublish.disabled ? t(DISABLED_REASON_KEY[unpublish.disabled]) : "", onHandle: () => setConfirmDialogOpen(true), dialog };
};
UnpublishAction.action = "unpublish";
var LiveEditBadge = (props) => {
  const { liveEdit } = props;
  if (liveEdit) {
    return { label: "Live", color: "danger" };
  }
  return null;
};
var _DEBUG = false;
var EMPTY_PARAMS$2 = {};
var LOADING_PANE = Symbol("LOADING_PANE");
var DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
var state = { activePanes: [] };
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a2;
  const panes = (routerState == null ? void 0 : routerState.panes) || [];
  const activePanes = state.activePanes || [];
  const editDocumentId = params.id || v4_default();
  const isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane !== "object")
      continue;
    if (((_a2 = pane.canHandleIntent) == null ? void 0 : _a2.call(pane, intent, params, { pane, index: i })) || // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type") {
      const paneParams = isTemplate ? { template: params.template } : EMPTY_PARAMS$2;
      return { panes: panes.slice(0, i).concat([[{ id: editDocumentId, params: paneParams, payload }]]) };
    }
  }
  return { intent, params, payload };
}
var EMPTY_PARAMS$1 = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err2) {
    console.warn("Failed to parse JSON parameters");
    return {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
var router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [route.create({ path: "/:params", transform: { params: { toState: legacyEditParamsToState, toPath: legacyEditParamsToPath } } })]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: { panes: { toState, toPath } }
  })
]);
var panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;
var isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str);
var isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str);
var exclusiveParams = ["view", "since", "rev", "inspect", "comment"];
var isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = { ...initial, params: EMPTY_PARAMS$1, payload: void 0 };
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("="));
      const value = chunk.slice(key.length + 1);
      pane.params = { ...pane.params, [decodeURIComponent(key)]: decodeURIComponent(value) };
    } else if (isPayloadLike(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      console.warn("Unknown pane segment: %s - skipping", chunk);
    }
    return pane;
  }, sibling);
}
function encodeChunks(pane, index, group) {
  const { payload, params = {}, id } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === "undefined" ? void 0 : encodeJsonParams(payload);
  const encodedParams = Object.entries(params).filter((entry) => {
    var _a2;
    const [key, value] = entry;
    if (!value)
      return false;
    if (paneIsFirstSibling)
      return true;
    const valueFromFirstSibling = (_a2 = firstSibling.params) == null ? void 0 : _a2[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key))
      return false;
    return true;
  }).map((_ref39) => {
    let [key, value] = _ref39;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  if (str.indexOf(",{") !== -1) {
    return parseOldPanesSegment(str);
  }
  return str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, { id });
    });
    return [firstSibling, ...restOfSiblings.map((sibling) => ({ ...firstSibling, ...sibling, id: sibling.id || firstSibling.id, params: { ...(0, import_omit2.default)(firstSibling.params, exclusiveParams), ...sibling.params }, payload: sibling.payload || firstSibling.payload }))];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({ id, payload });
    buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err2) {
    console.warn("Failed to parse parameters: ".concat(err2.message));
    return void 0;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? decodeJsonParams(data) : void 0;
  } catch (err2) {
    console.warn("Failed to parse parameters: ".concat(err2.message));
    return void 0;
  }
}
var DOCUMENT_PANEL_MIN_WIDTH = 320;
var DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
var DOCUMENT_INSPECTOR_MIN_WIDTH = 320;
var DOCUMENT_INSPECTOR_MAX_WIDTH = 540;
var EMPTY_PARAMS = {};
var INSPECT_ACTION_PREFIX = "inspect:";
var DEFAULT_MENU_ITEM_GROUPS = [{ id: "inspectors" }, { id: "links" }];
var HISTORY_INSPECTOR_NAME = "sanity/structure/history";
var VALIDATION_INSPECTOR_NAME = "sanity/structure/validation";
var COMMENTS_INSPECTOR_NAME = "sanity/structure/comments";
var __freeze$v = Object.freeze;
var __defProp$v = Object.defineProperty;
var __template$v = (cooked, raw) => __freeze$v(__defProp$v(cooked, "raw", { value: __freeze$v(raw || cooked.slice()) }));
var _a$v;
var StyledAvatar = ut(Avatar)(_a$v || (_a$v = __template$v(["\n  svg > ellipse {\n    stroke: transparent;\n  }\n"])));
var SYMBOLS = /[^\p{Alpha}\p{White_Space}]/gu;
var WHITESPACE = new RegExp("\\p{White_Space}+", "u");
function nameToInitials(fullName) {
  const namesArray = fullName.replace(SYMBOLS, "").split(WHITESPACE);
  if (namesArray.length === 1) {
    return "".concat(namesArray[0].charAt(0)).toUpperCase();
  }
  return "".concat(namesArray[0].charAt(0)).concat(namesArray[namesArray.length - 1].charAt(0));
}
function CommentsAvatar(props) {
  const { user: userProp, ...restProps } = props;
  const user = userProp;
  const initials = (0, import_react2.useMemo)(() => nameToInitials((user == null ? void 0 : user.displayName) || ""), [user == null ? void 0 : user.displayName]);
  if (!user)
    return (0, import_jsx_runtime2.jsx)(StyledAvatar, { ...restProps });
  return (0, import_jsx_runtime2.jsx)(StyledAvatar, { initials, src: user == null ? void 0 : user.imageUrl, title: user == null ? void 0 : user.displayName, ...restProps });
}
var AVATAR_HEIGHT = 25;
var INLINE_STYLE$1 = { minWidth: AVATAR_HEIGHT };
function SpacerAvatar() {
  return (0, import_jsx_runtime2.jsx)("div", { style: INLINE_STYLE$1 });
}
var __freeze$u = Object.freeze;
var __defProp$u = Object.defineProperty;
var __template$u = (cooked, raw) => __freeze$u(__defProp$u(cooked, "raw", { value: __freeze$u(raw || cooked.slice()) }));
var _a$u;
var Span$1 = ut.span((_ref40) => {
  let { theme } = _ref40;
  var _a2, _b2, _c2;
  const { regular } = (_a2 = theme.sanity.fonts) == null ? void 0 : _a2.text.weights;
  const { hovered } = (_b2 = theme.sanity.color) == null ? void 0 : _b2.card;
  const { bg } = ((_c2 = theme.sanity.color.selectable) == null ? void 0 : _c2.caution.pressed) || {};
  return at(_a$u || (_a$u = __template$u(["\n    font-weight: ", ";\n    color: var(--card-link-fg-color);\n    border-radius: 2px;\n    background-color: ", ";\n    padding: 1px;\n    box-sizing: border-box;\n\n    &[data-active='true'] {\n      background-color: ", ";\n    }\n  "])), regular, hovered.bg, bg);
});
function MentionInlineBlock(props) {
  const { selected, userId } = props;
  const [user, loading] = useUser(userId);
  const currentUser = useCurrentUser();
  if (!user || loading)
    return (0, import_jsx_runtime2.jsx)(Span$1, { children: "@Loading" });
  return (0, import_jsx_runtime2.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime2.jsx)(Flex, { children: (0, import_jsx_runtime2.jsx)(CommentsAvatar, { user }) }), (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: user.displayName })] }), children: (0, import_jsx_runtime2.jsxs)(Span$1, { "data-selected": selected, "data-active": (currentUser == null ? void 0 : currentUser.id) === userId, children: ["@", user.displayName] }) });
}
var __freeze$t = Object.freeze;
var __defProp$t = Object.defineProperty;
var __template$t = (cooked, raw) => __freeze$t(__defProp$t(cooked, "raw", { value: __freeze$t(raw || cooked.slice()) }));
var _a$t;
var NormalText = ut(Text)(_a$t || (_a$t = __template$t(["\n  word-break: break-word;\n"])));
function NormalBlock(props) {
  const { children } = props;
  return (0, import_jsx_runtime2.jsx)(NormalText, { size: 1, children });
}
var __freeze$s = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$s = (cooked, raw) => __freeze$s(__defProp$s(cooked, "raw", { value: __freeze$s(raw || cooked.slice()) }));
var _a$s;
var PortableTextWrap = ut(Stack)(() => {
  return at(_a$s || (_a$s = __template$s(["\n    & > [data-ui='Text']:not(:first-child) {\n      margin-top: 1em; // todo: improve\n    }\n\n    & > [data-ui='Text']:has(> span:empty) {\n      display: none;\n    }\n  "])));
});
var EMPTY_ARRAY$92 = [];
var components = { block: {
  normal: (_ref41) => {
    let { children } = _ref41;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  // Since we do not offer any formatting options, we can just use the normal block for all of these.
  h1: (_ref42) => {
    let { children } = _ref42;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  h2: (_ref43) => {
    let { children } = _ref43;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  h3: (_ref44) => {
    let { children } = _ref44;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  h4: (_ref45) => {
    let { children } = _ref45;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  h5: (_ref46) => {
    let { children } = _ref46;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  h6: (_ref47) => {
    let { children } = _ref47;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  blockquote: (_ref48) => {
    let { children } = _ref48;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  },
  code: (_ref49) => {
    let { children } = _ref49;
    return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
  }
}, list: { bullet: (_ref50) => {
  let { children } = _ref50;
  return children;
}, number: (_ref51) => {
  let { children } = _ref51;
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
}, checkmarks: (_ref52) => {
  let { children } = _ref52;
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
} }, listItem: { bullet: (_ref53) => {
  let { children } = _ref53;
  return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
}, number: (_ref54) => {
  let { children } = _ref54;
  return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
}, checkmarks: (_ref55) => {
  let { children } = _ref55;
  return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
} }, marks: {
  // Since we do not offer any formatting options, we can just use the normal block for all of these.
  strong: (_ref56) => {
    let { children } = _ref56;
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  },
  em: (_ref57) => {
    let { children } = _ref57;
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  },
  code: (_ref58) => {
    let { children } = _ref58;
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  },
  underline: (_ref59) => {
    let { children } = _ref59;
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  },
  strikeThrough: (_ref60) => {
    let { children } = _ref60;
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  },
  link: (_ref61) => {
    let { children } = _ref61;
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  }
}, types: { mention: (props) => {
  var _a2;
  return (0, import_jsx_runtime2.jsx)(MentionInlineBlock, { userId: (_a2 = props == null ? void 0 : props.value) == null ? void 0 : _a2.userId, selected: false });
} } };
function CommentMessageSerializer(props) {
  const { blocks } = props;
  return (0, import_jsx_runtime2.jsx)(PortableTextWrap, { children: (0, import_jsx_runtime2.jsx)(PortableText, { value: blocks || EMPTY_ARRAY$92, components }) });
}
var mentionObject = defineField({ name: "mention", type: "object", fields: [{ name: "userId", type: "string" }] });
var blockType = defineField({ type: "block", name: "block", of: [mentionObject], marks: { annotations: [] }, styles: [{ title: "Normal", value: "normal" }], lists: [] });
var portableTextType = defineArrayMember({ type: "array", name: "body", of: [blockType] });
var schema = Schema.compile({ name: "comments", types: [portableTextType] });
var editorSchemaType = schema.get("body");
var SendIcon = (0, import_react2.forwardRef)(function Icon(props, ref) {
  return (0, import_jsx_runtime2.jsx)("svg", { "data-sanity-icon": "send", fill: "none", height: "1em", ref, viewBox: "0 0 25 25", width: "1em", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime2.jsx)("path", { clipRule: "evenodd", d: "M21.1602 12.5L7.16016 19.5V14.8765L13.6656 12.4989L7.16016 9.97149L7.16016 5.5L21.1602 12.5Z", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }) });
});
var MentionIcon = (0, import_react2.forwardRef)(function Icon2(props, ref) {
  return (0, import_jsx_runtime2.jsxs)("svg", { "data-sanity-icon": "mention", fill: "none", height: "1em", ref, viewBox: "0 0 25 25", width: "1em", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime2.jsx)("path", { d: "M16.6633 18.9383C15.539 19.6562 14.2034 20.0723 12.7705 20.0723C8.77022 20.0723 5.52734 16.8294 5.52734 12.8291C5.52734 8.82881 8.77022 5.58594 12.7705 5.58594C16.7708 5.58594 20.0137 8.82881 20.0137 12.8291C20.0137 13.6623 19.8249 14.7093 19.6141 15.2077C19.5578 15.3408 19.479 15.4845 19.3936 15.6238C19.0955 16.1106 18.5507 16.3721 17.9807 16.4018V16.4018C16.8271 16.462 15.8588 15.5428 15.8588 14.3877V9.27302", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }), (0, import_jsx_runtime2.jsx)("circle", { cx: "12.5732", cy: "12.8291", r: "3.08691", stroke: "currentColor", strokeWidth: 1.2 })] });
});
var AddCommentIcon = (0, import_react2.forwardRef)(function Icon3(props, ref) {
  return (0, import_jsx_runtime2.jsxs)("svg", { "data-sanity-icon": "add-comment", fill: "none", height: "1em", ref, viewBox: "0 0 25 25", width: "1em", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime2.jsx)("path", { d: "M12.3368 5.97917H6.89453C5.78996 5.97917 4.89453 6.8746 4.89453 7.97917V13.4881C4.89453 14.5926 5.78996 15.4881 6.89453 15.4881H8.69808V19.2916L12.5016 15.4881H16.207C17.3115 15.4881 18.207 14.5926 18.207 13.4881V11.7158", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }), (0, import_jsx_runtime2.jsx)("path", { d: "M18.2081 2.08333V9.87058M14.3145 5.97695H22.1017", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })] });
});
var CommentIcon2 = (0, import_react2.forwardRef)(function Icon4(props, ref) {
  return (0, import_jsx_runtime2.jsx)("svg", { "data-sanity-icon": "comment", width: "1em", height: "1em", ref, viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime2.jsx)("path", { d: "M7.5 15.5H9.5V19.5L13.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V7.5C19.5 6.39543 18.6046 5.5 17.5 5.5H7.5C6.39543 5.5 5.5 6.39543 5.5 7.5V13.5C5.5 14.6046 6.39543 15.5 7.5 15.5Z", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: "1.2" }) });
});
function useCommentHasChanged(message) {
  const prevMessage = (0, import_react2.useRef)(message);
  return (0, import_react2.useMemo)(() => !(0, import_isEqual2.default)(prevMessage.current, message), [message]);
}
function hasCommentMessageValue(value) {
  if (!value)
    return false;
  return value == null ? void 0 : value.some((block) => {
    var _a2;
    return isPortableTextTextBlock(block) && ((_a2 = (block == null ? void 0 : block.children) || []) == null ? void 0 : _a2.some((c) => isPortableTextSpan(c) ? c.text : c.userId));
  });
}
var CommentInputContext = import_react2.default.createContext(null);
function CommentInputProvider(props) {
  const { children, expandOnFocus = false, focused, focusOnMount = false, mentionOptions, onMentionMenuOpenChange, value, readOnly } = props;
  const editor = usePortableTextEditor();
  const [mentionsMenuOpen, setMentionsMenuOpen] = (0, import_react2.useState)(false);
  const [mentionsSearchTerm, setMentionsSearchTerm] = (0, import_react2.useState)("");
  const [selectionAtMentionInsert, setSelectionAtMentionInsert] = (0, import_react2.useState)(null);
  const canSubmit = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const hasChanges = useCommentHasChanged(value);
  const focusEditor = (0, import_react2.useCallback)(() => {
    if (readOnly)
      return;
    PortableTextEditor.focus(editor);
  }, [editor, readOnly]);
  const closeMentions = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(false);
    setMentionsSearchTerm("");
    setSelectionAtMentionInsert(null);
  }, []);
  const openMentions = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(true);
    setMentionsSearchTerm("");
    setMentionsMenuOpen(true);
    setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]);
  const onBeforeInput = (0, import_react2.useCallback)((event) => {
    const selection = PortableTextEditor.getSelection(editor);
    const cursorOffset = selection ? selection.focus.offset : 0;
    const focusChild = PortableTextEditor.focusChild(editor);
    const focusSpan = isPortableTextSpan(focusChild) && focusChild || void 0;
    const isInsertText = event.inputType === "insertText";
    const isDeleteText = event.inputType === "deleteContentBackward";
    const isInsertingAtChar = isInsertText && event.data === "@";
    const lastIndexOfAt = (focusSpan == null ? void 0 : focusSpan.text.substring(0, cursorOffset).lastIndexOf("@")) || 0;
    const isWhitespaceCharBeforeCursorPosition = (focusSpan == null ? void 0 : focusSpan.text.substring(cursorOffset - 1, cursorOffset)) === " ";
    const filterStartsWithSpaceChar = isInsertText && event.data === " " && !mentionsSearchTerm;
    if (isInsertingAtChar && (cursorOffset < 1 || isWhitespaceCharBeforeCursorPosition)) {
      openMentions();
      return;
    }
    if (filterStartsWithSpaceChar || isDeleteText && ((focusSpan == null ? void 0 : focusSpan.text.length) === 1 || lastIndexOfAt === ((focusSpan == null ? void 0 : focusSpan.text.length) || 0) - 1)) {
      closeMentions();
      return;
    }
    if (isPortableTextSpan(focusChild)) {
      let term = focusChild.text.substring(lastIndexOfAt + 1, cursorOffset);
      if (isInsertText) {
        term += event.data;
      }
      if (isDeleteText) {
        term = term.substring(0, term.length - 1);
      }
      setMentionsSearchTerm(term);
    }
  }, [closeMentions, editor, mentionsSearchTerm, openMentions]);
  const insertAtChar = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(true);
    PortableTextEditor.focus(editor);
    PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: "@" });
    setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]);
  useDidUpdate(mentionsMenuOpen, () => onMentionMenuOpenChange == null ? void 0 : onMentionMenuOpenChange(mentionsMenuOpen));
  const insertMention = (0, import_react2.useCallback)((userId) => {
    var _a2;
    const mentionSchemaType = editor.schemaTypes.inlineObjects.find((t) => t.name === "mention");
    const [span, spanPath] = selectionAtMentionInsert && PortableTextEditor.findByPath(editor, selectionAtMentionInsert.focus.path) || [];
    if (span && isPortableTextSpan(span) && spanPath && mentionSchemaType) {
      PortableTextEditor.focus(editor);
      const offset = (_a2 = PortableTextEditor.getSelection(editor)) == null ? void 0 : _a2.focus.offset;
      if (typeof offset !== "undefined") {
        PortableTextEditor.delete(editor, { anchor: { path: spanPath, offset: span.text.lastIndexOf("@") }, focus: { path: spanPath, offset } }, { mode: "selected" });
        PortableTextEditor.insertChild(editor, mentionSchemaType, { userId });
        PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: " " });
      }
    }
  }, [editor, selectionAtMentionInsert]);
  const ctxValue = (0, import_react2.useMemo)(() => ({ canSubmit, closeMentions, editor, expandOnFocus, focused, focusEditor, focusOnMount, hasChanges, insertAtChar, insertMention, mentionOptions, mentionsMenuOpen, mentionsSearchTerm, onBeforeInput, openMentions, readOnly: Boolean(readOnly), value }), [canSubmit, closeMentions, editor, expandOnFocus, focused, focusEditor, focusOnMount, hasChanges, insertAtChar, insertMention, mentionOptions, mentionsMenuOpen, mentionsSearchTerm, onBeforeInput, openMentions, readOnly, value]);
  return (0, import_jsx_runtime2.jsx)(CommentInputContext.Provider, { value: ctxValue, children });
}
function useCommentInput() {
  const ctx = (0, import_react2.useContext)(CommentInputContext);
  if (!ctx) {
    throw new Error("useCommentInputContext must be used within a CommentInputProvider");
  }
  return ctx;
}
var __freeze$r = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$r = (cooked, raw) => __freeze$r(__defProp$r(cooked, "raw", { value: __freeze$r(raw || cooked.slice()) }));
var _a$r;
var InnerFlex = ut(Flex)(_a$r || (_a$r = __template$r([""])));
var SKELETON_INLINE_STYLE$1 = { width: "50%" };
function MentionsMenuItem(props) {
  const { user, onSelect } = props;
  const [loadedUser] = useUser(user.id);
  const avatar = (0, import_jsx_runtime2.jsx)(CommentsAvatar, { user: loadedUser, status: user.canBeMentioned ? void 0 : "inactive" });
  const text = loadedUser ? (0, import_jsx_runtime2.jsx)(Text, { size: 1, textOverflow: "ellipsis", title: loadedUser.displayName, children: loadedUser.displayName }) : (0, import_jsx_runtime2.jsx)(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE$1 });
  const handleSelect = (0, import_react2.useCallback)(() => {
    onSelect(user.id);
  }, [onSelect, user.id]);
  return (0, import_jsx_runtime2.jsx)(Card, { as: "button", disabled: !user.canBeMentioned, onClick: handleSelect, padding: 2, radius: 2, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, children: [(0, import_jsx_runtime2.jsxs)(InnerFlex, { align: "center", gap: 2, flex: 1, children: [avatar, (0, import_jsx_runtime2.jsx)(Box, { children: text })] }), !user.canBeMentioned && (0, import_jsx_runtime2.jsx)(Badge, { fontSize: 1, mode: "outline", children: "Unauthorized" })] }) });
}
var EMPTY_ARRAY$8 = [];
var Root$8 = ut(Stack)({
  maxWidth: "220px"
  // todo: improve
});
var ITEM_HEIGHT = 41;
var LIST_PADDING = 4;
var MAX_ITEMS = 7;
var FlexWrap = ut(Flex)({ maxHeight: ITEM_HEIGHT * MAX_ITEMS + LIST_PADDING * 2 + ITEM_HEIGHT / 2 });
var MentionsMenu = import_react2.default.forwardRef(function MentionsMenu2(props, ref) {
  const { loading, onSelect, options = [], inputElement } = props;
  const [searchTerm, setSearchTerm] = (0, import_react2.useState)("");
  const commandListRef = (0, import_react2.useRef)(null);
  (0, import_react2.useImperativeHandle)(ref, () => {
    return { setSearchTerm(term) {
      setSearchTerm(term);
    } };
  }, []);
  const renderItem2 = (0, import_react2.useCallback)((itemProps) => {
    return (0, import_jsx_runtime2.jsx)(MentionsMenuItem, { user: itemProps, onSelect });
  }, [onSelect]);
  const getItemDisabled = (0, import_react2.useCallback)((index) => {
    var _a2;
    return !((_a2 = options == null ? void 0 : options[index]) == null ? void 0 : _a2.canBeMentioned);
  }, [options]);
  const filteredOptions = (0, import_react2.useMemo)(() => {
    var _a2;
    if (!searchTerm)
      return options || EMPTY_ARRAY$8;
    const deburredSearchTerm = (0, import_deburr.default)(searchTerm).toLocaleLowerCase();
    const deburredOptions = options == null ? void 0 : options.map((option) => ({ ...option, displayName: (0, import_deburr.default)(option.displayName || "").toLocaleLowerCase() }));
    const filtered = (_a2 = deburredOptions == null ? void 0 : deburredOptions.filter((option) => {
      var _a22;
      return (_a22 = option == null ? void 0 : option.displayName) == null ? void 0 : _a22.includes(deburredSearchTerm);
    })) == null ? void 0 : _a2.sort((a, b) => {
      var _a22, _b2;
      const matchA = (_a22 = a.displayName) == null ? void 0 : _a22.startsWith(deburredSearchTerm);
      const matchB = (_b2 = b.displayName) == null ? void 0 : _b2.startsWith(deburredSearchTerm);
      if (matchA && !matchB)
        return -1;
      if (!matchA && matchB)
        return 1;
      return 0;
    });
    return filtered || EMPTY_ARRAY$8;
  }, [options, searchTerm]);
  if (loading) {
    return (0, import_jsx_runtime2.jsx)(Root$8, { children: (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true }) });
  }
  const _inputElement = inputElement ? inputElement : void 0;
  return (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", "data-testid": "comments-mentions-menu", children: [filteredOptions.length === 0 && (0, import_jsx_runtime2.jsx)(Box, { padding: 5, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", size: 1, muted: true, children: "No users found" }) }), filteredOptions.length > 0 && (0, import_jsx_runtime2.jsx)(FlexWrap, { direction: "column", flex: 1, overflow: "hidden", children: (0, import_jsx_runtime2.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: "List of users to mention", fixedHeight: true, getItemDisabled, inputElement: _inputElement, itemHeight: 41, items: filteredOptions, padding: 1, ref: commandListRef, renderItem: renderItem2 }) })] });
});
var renderBlock = (blockProps) => {
  const { children } = blockProps;
  return (0, import_jsx_runtime2.jsx)(NormalBlock, { children });
};
var renderChild = (childProps) => {
  const { children, value, selected } = childProps;
  const isMention = value._type === "mention" && value.userId;
  if (isMention) {
    return (0, import_jsx_runtime2.jsx)(MentionInlineBlock, { selected, userId: value == null ? void 0 : value.userId });
  }
  return children;
};
var EVENT_LISTENER_OPTIONS = { passive: true };
function useCursorElement(opts) {
  const { disabled, rootElement } = opts;
  const [cursorRect, setCursorRect] = (0, import_react2.useState)(null);
  const cursorElement = (0, import_react2.useMemo)(() => {
    if (!cursorRect) {
      return null;
    }
    return { getBoundingClientRect: () => {
      return cursorRect;
    } };
  }, [cursorRect]);
  const handleSelectionChange = (0, import_react2.useCallback)(() => {
    if (disabled) {
      setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || !sel.isCollapsed || sel.rangeCount === 0)
      return;
    const range = sel.getRangeAt(0);
    const isWithinRoot = rootElement == null ? void 0 : rootElement.contains(range.commonAncestorContainer);
    if (!isWithinRoot) {
      setCursorRect(null);
      return;
    }
    const rect = range == null ? void 0 : range.getBoundingClientRect();
    if (rect) {
      setCursorRect(rect);
    }
  }, [disabled, rootElement]);
  (0, import_react2.useEffect)(() => {
    document.addEventListener("selectionchange", handleSelectionChange, EVENT_LISTENER_OPTIONS);
    return () => {
      document.removeEventListener("selectionchange", handleSelectionChange);
    };
  }, [handleSelectionChange]);
  return cursorElement;
}
var __freeze$q = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$q = (cooked, raw) => __freeze$q(__defProp$q(cooked, "raw", { value: __freeze$q(raw || cooked.slice()) }));
var _a$q;
var _b$d;
var POPOVER_FALLBACK_PLACEMENTS$1 = ["bottom", "top"];
var INLINE_STYLE = { outline: "none" };
var EMPTY_ARRAY$7 = [];
var PlaceholderWrapper = ut.span(() => {
  return at(_a$q || (_a$q = __template$q(["\n    overflow: hidden;\n    text-overflow: ellipsis;\n    text-wrap: nowrap;\n    display: block;\n  "])));
});
var StyledPopover$1 = ut(Popover2)((_ref62) => {
  let { theme } = _ref62;
  const { space, radius } = theme.sanity;
  return at(_b$d || (_b$d = __template$q(["\n    &[data-placement='bottom'] {\n      transform: translateY(", "px);\n    }\n\n    &[data-placement='top'] {\n      transform: translateY(-", "px);\n    }\n\n    [data-ui='Popover__wrapper'] {\n      border-radius: ", "px;\n      display: flex;\n      flex-direction: column;\n      overflow: clip;\n      overflow: hidden;\n      position: relative;\n      width: 300px; // todo: improve\n    }\n  "])), space[1], space[1], radius[3]);
});
function Editable(props) {
  const { focusLock, placeholder = "Create a new comment", onFocus, onBlur, onKeyDown, onSubmit } = props;
  const [popoverElement, setPopoverElement] = (0, import_react2.useState)(null);
  const rootElementRef = (0, import_react2.useRef)(null);
  const editableRef = (0, import_react2.useRef)(null);
  const mentionsMenuRef = (0, import_react2.useRef)(null);
  const selection = usePortableTextEditorSelection();
  const { canSubmit, closeMentions, insertMention, mentionOptions, mentionsMenuOpen, mentionsSearchTerm, onBeforeInput, value } = useCommentInput();
  const cursorElement = useCursorElement({ disabled: !mentionsMenuOpen, rootElement: rootElementRef.current });
  const renderPlaceholder = (0, import_react2.useCallback)(() => (0, import_jsx_runtime2.jsx)(PlaceholderWrapper, { children: placeholder }), [placeholder]);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (mentionsMenuOpen) {
      closeMentions();
    }
  }, [closeMentions, mentionsMenuOpen]);
  useClickOutside(handleClickOutside, [popoverElement]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    switch (event.key) {
      case "Enter":
        if (event.shiftKey) {
          break;
        }
        event.preventDefault();
        event.stopPropagation();
        if (mentionsMenuOpen) {
          closeMentions();
          break;
        }
        if (onSubmit && canSubmit) {
          onSubmit();
        }
        break;
      case "Escape":
      case "ArrowLeft":
      case "ArrowRight":
        if (mentionsMenuOpen) {
          event.preventDefault();
          event.stopPropagation();
          closeMentions();
        }
        break;
    }
    if (onKeyDown)
      onKeyDown(event);
  }, [canSubmit, closeMentions, mentionsMenuOpen, onKeyDown, onSubmit]);
  const initialSelectionAtEndOfContent = (0, import_react2.useMemo)(() => {
    if (selection) {
      return void 0;
    }
    const lastBlock = (value || EMPTY_ARRAY$7).slice(-1)[0];
    const lastChild = isPortableTextTextBlock(lastBlock) ? lastBlock.children.slice(-1)[0] : void 0;
    if (!lastChild) {
      return void 0;
    }
    const point = { path: [{ _key: lastBlock._key }, "children", { _key: lastChild._key }], offset: isPortableTextSpan(lastChild) ? lastChild.text.length : 0 };
    return { focus: point, anchor: point };
  }, [value, selection]);
  (0, import_react2.useEffect)(() => {
    var _a2;
    (_a2 = mentionsMenuRef.current) == null ? void 0 : _a2.setSearchTerm(mentionsSearchTerm);
  }, [mentionsSearchTerm]);
  (0, import_react2.useEffect)(() => {
    if (mentionsMenuOpen && selection && !(0, import_isEqual2.default)(selection.anchor, selection.focus)) {
      closeMentions();
    }
  }, [mentionsMenuOpen, closeMentions, selection]);
  const popoverContent = (0, import_jsx_runtime2.jsx)(MentionsMenu, { inputElement: editableRef.current, loading: mentionOptions.loading, onSelect: insertMention, options: mentionOptions.data || EMPTY_ARRAY$7, ref: mentionsMenuRef });
  return (0, import_jsx_runtime2.jsxs)("div", { ref: rootElementRef, children: [(0, import_jsx_runtime2.jsx)(StyledPopover$1, { arrow: false, constrainSize: true, content: popoverContent, disabled: !mentionsMenuOpen, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1, open: mentionsMenuOpen, placement: "bottom", ref: setPopoverElement, referenceElement: cursorElement }), (0, import_jsx_runtime2.jsx)(PortableTextEditable, { "data-testid": "comment-input-editable", "data-ui": "EditableElement", onBeforeInput, onBlur, onFocus, onKeyDown: handleKeyDown, ref: editableRef, renderBlock, renderChild, renderPlaceholder, selection: initialSelectionAtEndOfContent, style: INLINE_STYLE, tabIndex: focusLock ? 0 : void 0 })] });
}
var __freeze$p = Object.freeze;
var __defProp$p = Object.defineProperty;
var __template$p = (cooked, raw) => __freeze$p(__defProp$p(cooked, "raw", { value: __freeze$p(raw || cooked.slice()) }));
var _a$p;
var _b$c;
var EditableWrap = ut(Box)(_a$p || (_a$p = __template$p(["\n  max-height: 20vh;\n  overflow-y: auto;\n"])));
var ButtonDivider = ut(MenuDivider)({ height: 20, width: 1 });
var RootCard = ut(Card)((_ref63) => {
  let { theme } = _ref63;
  const radii = theme.sanity.radius[2];
  return at(_b$c || (_b$c = __template$p(["\n    border-radius: ", "px;\n\n    &:not([data-expand-on-focus='false'], :focus-within) {\n      background: transparent;\n      box-shadow: unset;\n    }\n\n    &[data-focused='true']:focus-within {\n      ", " {\n        min-height: 1em;\n      }\n\n      box-shadow: inset 0 0 0 1px var(--card-focus-ring-color);\n    }\n\n    &:focus-within {\n      ", " {\n        min-height: 1em;\n      }\n    }\n\n    &[data-expand-on-focus='false'] {\n      ", " {\n        min-height: 1em;\n      }\n    }\n\n    &[data-expand-on-focus='true'] {\n      [data-ui='CommentInputActions']:not([hidden]) {\n        display: none;\n      }\n\n      &:focus-within {\n        [data-ui='CommentInputActions'] {\n          display: flex;\n        }\n      }\n    }\n  "])), radii, EditableWrap, EditableWrap, EditableWrap);
});
function CommentInputInner(props) {
  const { currentUser, focusLock, onBlur, onFocus, onKeyDown, onSubmit, placeholder, withAvatar } = props;
  const [user] = useUser(currentUser.id);
  const { canSubmit, expandOnFocus, focused, hasChanges, insertAtChar, openMentions, readOnly } = useCommentInput();
  const avatar = withAvatar ? (0, import_jsx_runtime2.jsx)(CommentsAvatar, { user }) : null;
  const handleMentionButtonClicked = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    insertAtChar();
    openMentions();
  }, [insertAtChar, openMentions]);
  return (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", gap: 2, children: [avatar, (0, import_jsx_runtime2.jsx)(RootCard, { "data-expand-on-focus": expandOnFocus && !canSubmit ? "true" : "false", "data-focused": focused ? "true" : "false", flex: 1, shadow: 1, sizing: "border", tone: readOnly ? "transparent" : "default", children: (0, import_jsx_runtime2.jsxs)(Stack, { children: [(0, import_jsx_runtime2.jsx)(EditableWrap, { paddingX: 1, paddingY: 2, sizing: "border", children: (0, import_jsx_runtime2.jsx)(Editable, { focusLock, onBlur, onFocus, onKeyDown, onSubmit, placeholder }) }), (0, import_jsx_runtime2.jsx)(Flex, { align: "center", "data-ui": "CommentInputActions", gap: 1, justify: "flex-end", padding: 1, children: (0, import_jsx_runtime2.jsxs)(TooltipDelayGroupProvider, { delay: TOOLTIP_DELAY_PROPS, children: [(0, import_jsx_runtime2.jsx)(Button2, { "aria-label": "Mention user", "data-testid": "comment-mention-button", disabled: readOnly, icon: MentionIcon, mode: "bleed", onClick: handleMentionButtonClicked, tooltipProps: { content: "Mention user" } }), (0, import_jsx_runtime2.jsx)(ButtonDivider, {}), (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": "Send comment", disabled: !canSubmit || !hasChanges || readOnly, icon: SendIcon, mode: hasChanges && canSubmit ? "default" : "bleed", onClick: onSubmit, tone: hasChanges && canSubmit ? "primary" : "default", tooltipProps: { content: "Send comment" } })] }) })] }) })] });
}
var Z_OFFSET = 9999999;
function CommentInputDiscardDialog(props) {
  const { onClose, onConfirm } = props;
  const handleCancelClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onClose();
  }, [onClose]);
  const handleConfirmClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onConfirm();
  }, [onConfirm]);
  return (0, import_jsx_runtime2.jsx)(ThemeColorProvider, { tone: "default", children: (0, import_jsx_runtime2.jsx)(DialogProvider, { zOffset: Z_OFFSET, children: (0, import_jsx_runtime2.jsx)(Dialog2, { header: "Discard comment?", id: "discard-comment-dialog", onClose, width: 0, onClickOutside: onClose, footer: { cancelButton: { onClick: handleCancelClick }, confirmButton: { onClick: handleConfirmClick, text: "Discard", tone: "critical" } }, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: "Do you want to discard the comment?" }) }) }) });
}
var EMPTY_ARRAY$6 = [];
var SCROLL_INTO_VIEW_OPTIONS$2 = { behavior: "smooth", block: "center", inline: "center" };
var CommentInput = (0, import_react2.forwardRef)(function CommentInput2(props, ref) {
  const { currentUser, expandOnFocus, focusLock = false, focusOnMount, mentionOptions, onBlur, onChange, onDiscardCancel, onDiscardConfirm, onFocus, onKeyDown, onMentionMenuOpenChange, onSubmit, placeholder, readOnly, value = EMPTY_ARRAY$6, withAvatar = true } = props;
  const [focused, setFocused] = (0, import_react2.useState)(false);
  const editorRef = (0, import_react2.useRef)(null);
  const editorContainerRef = (0, import_react2.useRef)(null);
  const [showDiscardDialog, setShowDiscardDialog] = (0, import_react2.useState)(false);
  const preDivRef = (0, import_react2.useRef)(null);
  const postDivRef = (0, import_react2.useRef)(null);
  const innerRef = (0, import_react2.useRef)(null);
  const [editorInstanceKey, setEditorInstanceKey] = (0, import_react2.useState)(defaultKeyGenerator());
  const requestFocus = (0, import_react2.useCallback)(() => {
    requestAnimationFrame(() => {
      if (!editorRef.current)
        return;
      PortableTextEditor.focus(editorRef.current);
    });
  }, []);
  const resetEditorInstance = (0, import_react2.useCallback)(() => {
    setEditorInstanceKey(defaultKeyGenerator());
  }, []);
  const handleChange = (0, import_react2.useCallback)((change) => {
    if (change.type === "ready") {
      if (focusOnMount) {
        requestFocus();
      }
    }
    if (change.type === "focus") {
      setFocused(true);
    }
    if (change.type === "blur") {
      setFocused(false);
    }
    if (change.type === "patch" && editorRef.current) {
      const editorStateValue = PortableTextEditor.getValue(editorRef.current);
      onChange(editorStateValue || EMPTY_ARRAY$6);
    }
  }, [focusOnMount, onChange, requestFocus]);
  const scrollToEditor = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = editorContainerRef.current) == null ? void 0 : _a2.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS$2);
  }, []);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    onSubmit();
    resetEditorInstance();
    requestFocus();
    scrollToEditor();
  }, [onSubmit, requestFocus, resetEditorInstance, scrollToEditor]);
  const handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    onDiscardConfirm();
    resetEditorInstance();
  }, [onDiscardConfirm, resetEditorInstance]);
  const discardDialogController = (0, import_react2.useMemo)(() => {
    return { open: () => {
      setShowDiscardDialog(true);
    }, close: () => {
      setShowDiscardDialog(false);
      requestFocus();
    } };
  }, [requestFocus]);
  (0, import_react2.useImperativeHandle)(ref, () => {
    return { focus: requestFocus, blur() {
      if (editorRef.current) {
        PortableTextEditor.blur(editorRef.current);
      }
    }, scrollTo: scrollToEditor, reset: resetEditorInstance, discardDialogController };
  }, [discardDialogController, requestFocus, resetEditorInstance, scrollToEditor]);
  const handleFocus = (0, import_react2.useCallback)((event) => {
    if (!focusLock)
      return;
    const target = event.target;
    const innerEl = innerRef.current;
    if (innerEl && target === preDivRef.current) {
      focusLastDescendant(innerEl);
      return;
    }
    if (innerEl && target === postDivRef.current) {
      focusFirstDescendant(innerEl);
    }
  }, [focusLock]);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [showDiscardDialog && (0, import_jsx_runtime2.jsx)(CommentInputDiscardDialog, { onClose: onDiscardCancel, onConfirm: handleDiscardConfirm }), (0, import_jsx_runtime2.jsx)(Stack, { ref: editorContainerRef, "data-testid": "comment-input", onFocus: handleFocus, children: (0, import_jsx_runtime2.jsx)(PortableTextEditor, { onChange: handleChange, readOnly, ref: editorRef, schemaType: editorSchemaType, value: value || EMPTY_ARRAY$6, children: (0, import_jsx_runtime2.jsxs)(CommentInputProvider, { expandOnFocus, focused, focusOnMount, mentionOptions, onMentionMenuOpenChange, readOnly, value, children: [focusLock && (0, import_jsx_runtime2.jsx)("div", { ref: preDivRef, tabIndex: 0 }), (0, import_jsx_runtime2.jsx)(Stack, { ref: innerRef, children: (0, import_jsx_runtime2.jsx)(CommentInputInner, { currentUser, focusLock, onBlur, onFocus, onKeyDown, onSubmit: handleSubmit, placeholder, withAvatar }) }), focusLock && (0, import_jsx_runtime2.jsx)("div", { ref: postDivRef, tabIndex: 0 })] }) }, editorInstanceKey) })] });
});
var FLEX_GAP = 3;
var __freeze$o = Object.freeze;
var __defProp$o = Object.defineProperty;
var __template$o = (cooked, raw) => __freeze$o(__defProp$o(cooked, "raw", { value: __freeze$o(raw || cooked.slice()) }));
var _a$o;
var POPOVER_PROPS$2 = { placement: "bottom-end" };
var FloatingCard = ut(Card)(_a$o || (_a$o = __template$o(["\n  &:empty {\n    display: none;\n  }\n"])));
function CommentsListItemContextMenu(props) {
  const { canDelete, canEdit, isParent, onCopyLink, onDeleteStart, onEditStart, onMenuClose, onMenuOpen, onStatusChange, readOnly, status } = props;
  const showMenuButton = Boolean(onCopyLink || onDeleteStart || onEditStart);
  return (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { delay: TOOLTIP_DELAY_PROPS, children: (0, import_jsx_runtime2.jsx)(Flex, { children: (0, import_jsx_runtime2.jsxs)(FloatingCard, { display: "flex", shadow: 2, padding: 1, radius: 2, sizing: "border", children: [isParent && (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": status === "open" ? "Mark comment as resolved" : "Re-open", disabled: readOnly, icon: status === "open" ? CheckmarkCircleIcon : UndoIcon, mode: "bleed", onClick: onStatusChange, tooltipProps: { content: status === "open" ? "Mark as resolved" : "Re-open" } }), (0, import_jsx_runtime2.jsx)(MenuButton2, { id: "comment-actions-menu", button: (0, import_jsx_runtime2.jsx)(ContextMenuButton, { "aria-label": "Open comment actions menu", disabled: readOnly, hidden: !showMenuButton }), onOpen: onMenuOpen, onClose: onMenuClose, menu: (0, import_jsx_runtime2.jsxs)(Menu, { children: [(0, import_jsx_runtime2.jsx)(MenuItem2, { hidden: !canEdit, icon: EditIcon, onClick: onEditStart, text: "Edit comment" }), (0, import_jsx_runtime2.jsx)(MenuItem2, { hidden: !canDelete, icon: TrashIcon, onClick: onDeleteStart, text: "Delete comment", tone: "critical" }), (0, import_jsx_runtime2.jsx)(MenuDivider, { hidden: !canDelete && !canEdit }), (0, import_jsx_runtime2.jsx)(MenuItem2, { hidden: !onCopyLink, icon: LinkIcon, onClick: onCopyLink, text: "Copy link to comment" })] }), popover: POPOVER_PROPS$2 })] }) }) });
}
var __freeze$n = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$n = (cooked, raw) => __freeze$n(__defProp$n(cooked, "raw", { value: __freeze$n(raw || cooked.slice()) }));
var _a$n;
var _b$b;
var _c$5;
var _d$2;
var _e$1;
var _f$1;
var ContextMenuBox = ut(Box)(_a$n || (_a$n = __template$n([""])));
function StopPropagationWrap(props) {
  const { children, isParent } = props;
  const handleClick = (0, import_react2.useCallback)((event) => {
    event.stopPropagation();
  }, []);
  return (0, import_jsx_runtime2.jsx)(ContextMenuBox, { "data-root-menu": isParent ? "true" : "false", onClick: handleClick, children });
}
var SKELETON_INLINE_STYLE = { width: "50%" };
var TimeText = ut(Text)((_ref64) => {
  let { theme } = _ref64;
  const isDark = theme.sanity.color.dark;
  const fg = hues.gray[isDark ? 200 : 800].hex;
  return at(_b$b || (_b$b = __template$n(["\n    min-width: max-content;\n    --card-fg-color: ", ";\n    color: var(--card-fg-color);\n  "])), fg);
});
var InnerStack = ut(Stack)(_c$5 || (_c$5 = __template$n(["\n  transition: opacity 200ms ease;\n\n  &[data-muted='true'] {\n    transition: unset;\n    opacity: 0.5;\n  }\n"])));
var ErrorFlex = ut(Flex)(_d$2 || (_d$2 = __template$n(["\n  min-height: ", "px;\n"])), AVATAR_HEIGHT);
var RetryCardButton = ut(Card)(_e$1 || (_e$1 = __template$n(["\n  // Add not on hover\n  &:not(:hover) {\n    background-color: transparent;\n  }\n"])));
var RootStack = ut(Stack)((_ref65) => {
  let { theme } = _ref65;
  const { space } = theme.sanity;
  return at(_f$1 || (_f$1 = __template$n(["\n    position: relative;\n\n    // Only show the floating layer on hover when hover is supported.\n    // Else, the layer is always visible.\n    @media (hover: hover) {\n      ", " {\n        opacity: 0;\n        position: absolute;\n        right: 0;\n        top: 0;\n        transform: translate(", "px, -", "px);\n      }\n\n      ", " {\n        &:focus-within {\n          opacity: 1;\n        }\n      }\n\n      &:hover {\n        ", " {\n          opacity: 1;\n        }\n      }\n    }\n\n    &[data-menu-open='true'] {\n      ", " {\n        opacity: 1;\n      }\n    }\n  "])), ContextMenuBox, space[1], space[1], ContextMenuBox, ContextMenuBox, ContextMenuBox);
});
var TIME_AGO_OPTS = { agoSuffix: true };
function CommentsListItemLayout(props) {
  const { canDelete, canEdit, comment, currentUser, hasError, isParent, isRetrying, mentionOptions, onCopyLink, onCreateRetry, onDelete, onEdit, onInputKeyDown, onStatusChange, readOnly } = props;
  const { _createdAt, authorId, message, _id, lastEditedAt } = comment;
  const [user] = useUser(authorId);
  const [value, setValue] = (0, import_react2.useState)(message);
  const [isEditing, setIsEditing] = (0, import_react2.useState)(false);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const startMessage = (0, import_react2.useRef)(message);
  const [menuOpen, setMenuOpen] = (0, import_react2.useState)(false);
  const hasChanges = useCommentHasChanged(value);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const commentInputRef = (0, import_react2.useRef)(null);
  const createdDate = _createdAt ? new Date(_createdAt) : /* @__PURE__ */ new Date();
  const createdTimeAgo = useTimeAgo(createdDate, TIME_AGO_OPTS);
  const formattedCreatedAt = format(createdDate, "PPPPp");
  const formattedLastEditAt = lastEditedAt ? format(new Date(lastEditedAt), "PPPPp") : null;
  const displayError = hasError || isRetrying;
  const handleMenuOpen = (0, import_react2.useCallback)(() => setMenuOpen(true), []);
  const handleMenuClose = (0, import_react2.useCallback)(() => setMenuOpen(false), []);
  const handleCopyLink = (0, import_react2.useCallback)(() => onCopyLink == null ? void 0 : onCopyLink(_id), [_id, onCopyLink]);
  const handleCreateRetry = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onCreateRetry == null ? void 0 : onCreateRetry(_id);
  }, [_id, onCreateRetry]);
  const handleDelete = (0, import_react2.useCallback)(() => onDelete(_id), [_id, onDelete]);
  const cancelEdit = (0, import_react2.useCallback)(() => {
    setIsEditing(false);
    setValue(startMessage.current);
  }, []);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    if (!hasValue || !hasChanges) {
      cancelEdit();
      return;
    }
    (_a2 = commentInputRef.current) == null ? void 0 : _a2.discardDialogController.open();
  }, [cancelEdit, hasChanges, hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
    if (onInputKeyDown)
      onInputKeyDown(event);
  }, [onInputKeyDown, startDiscard]);
  const cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null ? void 0 : _a2.discardDialogController.close();
  }, []);
  const confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null ? void 0 : _a2.discardDialogController.close();
    cancelEdit();
  }, [cancelEdit]);
  const handleEditSubmit = (0, import_react2.useCallback)(() => {
    onEdit(_id, { message: value });
    setIsEditing(false);
  }, [_id, onEdit, value]);
  const handleOpenStatusChange = (0, import_react2.useCallback)(() => {
    onStatusChange == null ? void 0 : onStatusChange(_id, comment.status === "open" ? "resolved" : "open");
  }, [_id, comment.status, onStatusChange]);
  const toggleEdit = (0, import_react2.useCallback)(() => {
    setIsEditing((v) => !v);
  }, []);
  const handleCloseMenu = (0, import_react2.useCallback)(() => setMenuOpen(false), []);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (!hasChanges) {
      cancelEdit();
    }
  }, [cancelEdit, hasChanges]);
  const handleRootKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape" && !hasChanges) {
      cancelEdit();
    }
  }, [cancelEdit, hasChanges]);
  useDidUpdate(isEditing, handleCloseMenu);
  useClickOutside(handleClickOutside, [rootElement]);
  const name = (user == null ? void 0 : user.displayName) ? (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", textOverflow: "ellipsis", title: user.displayName, children: user.displayName }) : (0, import_jsx_runtime2.jsx)(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE });
  return (0, import_jsx_runtime2.jsxs)(RootStack, { "data-menu-open": menuOpen ? "true" : "false", onKeyDown: handleRootKeyDown, ref: setRootElement, space: 4, children: [(0, import_jsx_runtime2.jsxs)(InnerStack, { space: 1, "data-muted": displayError, children: [(0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: FLEX_GAP, flex: 1, children: [(0, import_jsx_runtime2.jsx)(CommentsAvatar, { user }), (0, import_jsx_runtime2.jsx)(Flex, { align: "center", paddingBottom: 1, sizing: "border", flex: 1, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-end", gap: 2, children: [(0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: name }), !displayError && (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, children: [(0, import_jsx_runtime2.jsx)(TimeText, { muted: true, size: 0, title: formattedCreatedAt, children: createdTimeAgo }), formattedLastEditAt && (0, import_jsx_runtime2.jsx)(TimeText, { muted: true, size: 0, title: formattedLastEditAt, children: "(edited)" })] })] }) }), !isEditing && !displayError && (0, import_jsx_runtime2.jsx)(StopPropagationWrap, { isParent, children: (0, import_jsx_runtime2.jsx)(CommentsListItemContextMenu, { canDelete, canEdit, isParent, onCopyLink: handleCopyLink, onDeleteStart: handleDelete, onEditStart: toggleEdit, onMenuClose: handleMenuClose, onMenuOpen: handleMenuOpen, onStatusChange: handleOpenStatusChange, readOnly, status: comment.status }) })] }), isEditing && (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", gap: 2, children: [(0, import_jsx_runtime2.jsx)(SpacerAvatar, {}), (0, import_jsx_runtime2.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime2.jsx)(CommentInput, { currentUser, focusOnMount: true, mentionOptions, onChange: setValue, onDiscardCancel: cancelDiscard, onDiscardConfirm: confirmDiscard, onKeyDown: handleInputKeyDown, onSubmit: handleEditSubmit, readOnly, ref: commentInputRef, value, withAvatar: false }) })] }), !isEditing && (0, import_jsx_runtime2.jsxs)(Flex, { gap: FLEX_GAP, children: [(0, import_jsx_runtime2.jsx)(SpacerAvatar, {}), (0, import_jsx_runtime2.jsx)(CommentMessageSerializer, { blocks: message })] })] }), displayError && (0, import_jsx_runtime2.jsxs)(ErrorFlex, { gap: FLEX_GAP, children: [(0, import_jsx_runtime2.jsx)(SpacerAvatar, {}), (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, flex: 1, children: [(0, import_jsx_runtime2.jsxs)(Text, { muted: true, size: 1, children: [hasError && "Failed to send.", isRetrying && "Posting..."] }), (0, import_jsx_runtime2.jsx)(Flex, { hidden: isRetrying, children: (0, import_jsx_runtime2.jsx)(RetryCardButton, { __unstable_focusRing: true, display: "flex", forwardedAs: "button", onClick: handleCreateRetry, padding: 1, radius: 2, tone: "primary", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: "Retry" }) }) })] })] })] });
}
var __freeze$m = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$m = (cooked, raw) => __freeze$m(__defProp$m(cooked, "raw", { value: __freeze$m(raw || cooked.slice()) }));
var _a$m;
var ThreadCard = ut(Card).attrs((_ref66) => {
  let { tone } = _ref66;
  return { padding: 3, radius: 3, sizing: "border", tone: tone || "transparent" };
})(_a$m || (_a$m = __template$m(["\n  // ...\n"])));
var __freeze$l = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$l = (cooked, raw) => __freeze$l(__defProp$l(cooked, "raw", { value: __freeze$l(raw || cooked.slice()) }));
var _a$l;
var _b$a;
var _c$4;
var EMPTY_ARRAY$5 = [];
var MAX_COLLAPSED_REPLIES = 5;
var StyledThreadCard = ut(ThreadCard)((_ref67) => {
  let { theme } = _ref67;
  const { hovered } = theme.sanity.color.button.bleed.default;
  return at(_a$l || (_a$l = __template$l(["\n    position: relative;\n\n    &:has(> [data-ui='GhostButton']:focus:focus-visible) {\n      box-shadow:\n        inset 0 0 0 1px var(--card-border-color),\n        0 0 0 1px var(--card-bg-color),\n        0 0 0 3px var(--card-focus-ring-color);\n    }\n\n    // When the comment is not selected, we want to apply hover styles.\n    // The hover styles is managed with the [data-hovered] attribute instead of the :hover pseudo class\n    // since we want to show the hover styles when hovering over the menu items in the context menu as well.\n    // The context menu is rendered using a portal, so the :hover pseudo class won't work when hovering over\n    // the menu items.\n    &:not([data-active='true']) {\n      @media (hover: hover) {\n        &[data-hovered='true'] {\n          --card-bg-color: ", ";\n\n          [data-root-menu='true'] {\n            opacity: 1;\n          }\n        }\n      }\n    }\n  "])), hovered.bg2);
});
var ExpandButton = ut(Button2)((_ref68) => {
  let { theme } = _ref68;
  const { medium } = theme.sanity.fonts.text.weights;
  return at(_b$a || (_b$a = __template$l(["\n    font-weight: ", ";\n  "])), medium);
});
var GhostButton = ut.button(_c$4 || (_c$4 = __template$l(["\n  opacity: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  left: 0;\n"])));
var CommentsListItem = import_react2.default.memo(function CommentsListItem2(props) {
  var _a2, _b2;
  const { canReply, currentUser, isSelected, mentionOptions, onCopyLink, onCreateRetry, onDelete, onEdit, onKeyDown, onPathSelect, onReply, onStatusChange, parentComment, readOnly, replies = EMPTY_ARRAY$5 } = props;
  const [value, setValue] = (0, import_react2.useState)(EMPTY_ARRAY$5);
  const [collapsed, setCollapsed] = (0, import_react2.useState)(true);
  const didExpand = (0, import_react2.useRef)(false);
  const replyInputRef = (0, import_react2.useRef)(null);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const [mouseOver, setMouseOver] = (0, import_react2.useState)(false);
  const handleMouseEnter = (0, import_react2.useCallback)(() => setMouseOver(true), []);
  const handleMouseLeave = (0, import_react2.useCallback)(() => setMouseOver(false), []);
  const handleReplySubmit = (0, import_react2.useCallback)(() => {
    const nextComment = {
      fieldPath: parentComment.target.path.field,
      message: value,
      parentCommentId: parentComment._id,
      status: (parentComment == null ? void 0 : parentComment.status) || "open",
      // Since this is a reply to an existing comment, we use the same thread ID as the parent
      threadId: parentComment.threadId
    };
    onReply == null ? void 0 : onReply(nextComment);
    setValue(EMPTY_ARRAY$5);
  }, [onReply, parentComment._id, parentComment == null ? void 0 : parentComment.status, parentComment.target.path.field, parentComment.threadId, value]);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a3;
    if (!hasValue) {
      setValue(EMPTY_ARRAY$5);
      return;
    }
    (_a3 = replyInputRef.current) == null ? void 0 : _a3.discardDialogController.open();
  }, [hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
  }, [startDiscard]);
  const cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a3;
    (_a3 = replyInputRef.current) == null ? void 0 : _a3.discardDialogController.close();
  }, []);
  const confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a3, _b3;
    setValue(EMPTY_ARRAY$5);
    (_a3 = replyInputRef.current) == null ? void 0 : _a3.discardDialogController.close();
    (_b3 = replyInputRef.current) == null ? void 0 : _b3.focus();
  }, []);
  const handleThreadRootClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onPathSelect == null ? void 0 : onPathSelect({ fieldPath: parentComment.target.path.field, origin: "inspector", threadId: parentComment.threadId });
  }, [onPathSelect, parentComment.target.path.field, parentComment.threadId]);
  const handleExpand = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    setCollapsed(false);
    didExpand.current = true;
  }, []);
  const splicedReplies = (0, import_react2.useMemo)(() => {
    if (collapsed)
      return replies == null ? void 0 : replies.slice(-MAX_COLLAPSED_REPLIES);
    return replies;
  }, [replies, collapsed]);
  const showCollapseButton = (0, import_react2.useMemo)(() => {
    if (!replies)
      return false;
    return replies.length > MAX_COLLAPSED_REPLIES;
  }, [replies]);
  const expandButtonText = (0, import_react2.useMemo)(() => {
    return "".concat((replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES, " more ").concat((replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES === 1 ? "comment" : "comments");
  }, [replies == null ? void 0 : replies.length]);
  (0, import_react2.useEffect)(() => {
    if (replies.length > MAX_COLLAPSED_REPLIES && !didExpand.current) {
      setCollapsed(true);
    }
  }, [replies]);
  const renderedReplies = (0, import_react2.useMemo)(() => splicedReplies.map((reply) => {
    var _a3, _b3;
    return (0, import_jsx_runtime2.jsx)(Stack, { as: "li", "data-comment-id": reply._id, children: (0, import_jsx_runtime2.jsx)(CommentsListItemLayout, { canDelete: reply.authorId === currentUser.id, canEdit: reply.authorId === currentUser.id, comment: reply, currentUser, hasError: ((_a3 = reply._state) == null ? void 0 : _a3.type) === "createError", isRetrying: ((_b3 = reply._state) == null ? void 0 : _b3.type) === "createRetrying", mentionOptions, onInputKeyDown: handleInputKeyDown, onCopyLink, onCreateRetry, onDelete, onEdit, readOnly }) }, reply._id);
  }), [currentUser, handleInputKeyDown, mentionOptions, onCopyLink, onCreateRetry, onDelete, onEdit, readOnly, splicedReplies]);
  return (0, import_jsx_runtime2.jsx)(Stack, { space: 2, children: (0, import_jsx_runtime2.jsxs)(StyledThreadCard, { "data-active": isSelected ? "true" : "false", "data-hovered": mouseOver ? "true" : "false", onClick: handleThreadRootClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, tone: isSelected ? "primary" : void 0, children: [(0, import_jsx_runtime2.jsx)(GhostButton, { "data-ui": "GhostButton", "aria-label": "Go to field" }), (0, import_jsx_runtime2.jsxs)(Stack, { as: "ul", paddingBottom: canReply ? void 0 : 1, space: 4, children: [(0, import_jsx_runtime2.jsx)(Stack, { as: "li", "data-comment-id": parentComment._id, children: (0, import_jsx_runtime2.jsx)(CommentsListItemLayout, { canDelete: parentComment.authorId === currentUser.id, canEdit: parentComment.authorId === currentUser.id, comment: parentComment, currentUser, hasError: ((_a2 = parentComment._state) == null ? void 0 : _a2.type) === "createError", isParent: true, isRetrying: ((_b2 = parentComment._state) == null ? void 0 : _b2.type) === "createRetrying", mentionOptions, onCopyLink, onCreateRetry, onDelete, onEdit, onInputKeyDown: onKeyDown, onStatusChange, readOnly }) }), showCollapseButton && !didExpand.current && (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, paddingY: 1, sizing: "border", children: [(0, import_jsx_runtime2.jsx)(SpacerAvatar, {}), (0, import_jsx_runtime2.jsx)(ExpandButton, { iconRight: ChevronDownIcon, mode: "bleed", onClick: handleExpand, text: expandButtonText })] }), renderedReplies, canReply && (0, import_jsx_runtime2.jsx)(CommentInput, { currentUser, expandOnFocus: true, mentionOptions, onChange: setValue, onDiscardCancel: cancelDiscard, onDiscardConfirm: confirmDiscard, onKeyDown: handleInputKeyDown, onSubmit: handleReplySubmit, placeholder: "Reply", readOnly, ref: replyInputRef, value })] })] }) });
});
var separator = (0, import_jsx_runtime2.jsx)(Text, { muted: true, children: (0, import_jsx_runtime2.jsx)(ChevronRightIcon, {}) });
var renderItem = (item, index) => {
  return (0, import_jsx_runtime2.jsx)(Box, { as: "li", children: (0, import_jsx_runtime2.jsx)(Text, { textOverflow: "ellipsis", size: 1, weight: "medium", children: item }) }, "".concat(item, "-").concat(index));
};
function CommentBreadcrumbs(props) {
  const { titlePath, maxLength } = props;
  const items = (0, import_react2.useMemo)(() => {
    const len = titlePath.length;
    const beforeLength = Math.ceil(maxLength / 2);
    const afterLength = Math.floor(maxLength / 2);
    if (maxLength && len > maxLength) {
      return [...titlePath.slice(0, beforeLength - 1), titlePath.slice(beforeLength - 1, len - afterLength), ...titlePath.slice(len - afterLength)];
    }
    return titlePath;
  }, [maxLength, titlePath]);
  const nodes = (0, import_react2.useMemo)(() => {
    return items.map((item, index) => {
      const key = "".concat(item, "-").concat(index);
      const showSeparator = index < items.length - 1;
      if (Array.isArray(item)) {
        return (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Tooltip, { content: (0, import_jsx_runtime2.jsx)(Stack, { space: 2, padding: 2, children: item.map(renderItem) }), children: (0, import_jsx_runtime2.jsx)(Box, { children: renderItem("...", index) }) }), showSeparator && separator] }, key);
      }
      return (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [renderItem(item, index), showSeparator && separator] }, key);
    });
  }, [items]);
  return (0, import_jsx_runtime2.jsx)(Flex, { align: "center", as: "ol", gap: 2, children: nodes });
}
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = { _tr_init: _tr_init_1, _tr_stored_block: _tr_stored_block_1, _tr_flush_block: _tr_flush_block_1, _tr_tally: _tr_tally_1, _tr_align: _tr_align_1 };
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var { Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2 } = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan2 = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan2 + best_len - 1];
  let scan_end = _win[scan2 + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan2] || _win[++match] !== _win[scan2 + 1]) {
      continue;
    }
    scan2 += 2;
    match++;
    do {
    } while (_win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && scan2 < strend);
    len = MAX_MATCH - (strend - scan2);
    scan2 = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan2 + best_len - 1];
      scan_end = _win[scan2 + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan2, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan2 = s.strstart - 1;
      prev = _win[scan2];
      if (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && scan2 < strend);
        s.match_length = MAX_MATCH - (strend - scan2);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = { deflateInit: deflateInit_1, deflateInit2: deflateInit2_1, deflateReset: deflateReset_1, deflateResetKeep: deflateResetKeep_1, deflateSetHeader: deflateSetHeader_1, deflate: deflate_2$1, deflateEnd: deflateEnd_1, deflateSetDictionary: deflateSetDictionary_1, deflateInfo };
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = { assign, flattenChunks };
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = { string2buf, buf2string, utf8border };
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var { Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1 } = constants$2;
function Deflate$1(options) {
  this.options = common.assign({ level: Z_DEFAULT_COMPRESSION, method: Z_DEFLATED$1, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Z_DEFAULT_STRATEGY }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = { Deflate: Deflate_1$1, deflate: deflate_2, deflateRaw: deflateRaw_1$1, gzip: gzip_1$1, constants: constants$1 };
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from2;
  let from_source;
  let input, output;
  const state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state2.sane) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD$1;
                        break top;
                      }
                    }
                    from2 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from2 += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from2 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from2 += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from2++];
                      if (len > 1) {
                        output[_out++] = from_source[from2++];
                      }
                    }
                  } else {
                    from2 = _out - dist;
                    do {
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from2++];
                      if (len > 1) {
                        output[_out++] = output[from2++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state2.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state2.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var { Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED } = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state2 = strm.state;
  if (!state2 || state2.strm !== strm || state2.mode < HEAD || state2.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.flags = -1;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new Int32Array(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new Int32Array(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap;
  state2.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = new InflateState();
  strm.state = state2;
  state2.strm = strm;
  state2.window = null;
  state2.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state2) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inftrees(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inftrees(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, { bits: 5 });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new Uint8Array(state2.wsize);
  }
  if (copy >= state2.wsize) {
    state2.window.set(src.subarray(end - state2.wsize, end), 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state2.window.set(src.subarray(end - copy, end - copy + dist), state2.wnext);
    copy -= dist;
    if (copy) {
      state2.window.set(src.subarray(end - copy, end), 0);
      state2.wnext = copy;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state2;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from2;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            if (state2.wbits === 0) {
              state2.wbits = 15;
            }
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          }
          if (len > 15 || len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << state2.wbits;
          state2.flags = 0;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512 && state2.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512 && state2.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32_1(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512 && state2.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512 && state2.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32_1(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        case EXTRA:
          if (state2.flags & 1024) {
            copy = state2.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Uint8Array(state2.head.extra_len);
                }
                state2.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512 && state2.wrap & 4) {
                state2.check = crc32_1(state2.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state2.length -= copy;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state2.flags & 512 && state2.wrap & 4) {
              state2.check = crc32_1(state2.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state2.flags & 512 && state2.wrap & 4) {
              state2.check = crc32_1(state2.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 4 && hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state2.mode = COPY;
        case COPY:
          copy = state2.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state2.length -= copy;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts = { bits: state2.lenbits };
          ret = inftrees(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts = { bits: state2.lenbits };
          ret = inftrees(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts = { bits: state2.distbits };
          ret = inftrees(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
          state2.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state2.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        case LENEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        case DISTEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state2.offset > copy) {
            copy = state2.offset - copy;
            if (copy > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy > state2.wnext) {
              copy -= state2.wnext;
              from2 = state2.wsize - copy;
            } else {
              from2 = state2.wnext - copy;
            }
            if (copy > state2.length) {
              copy = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from2 = put - state2.offset;
            copy = state2.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state2.length -= copy;
          do {
            output[put++] = from_source[from2++];
          } while (--copy);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (state2.wrap & 4 && _out) {
              strm.adler = state2.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state2.flags ? crc32_1(state2.check, output, _out, put - _out) : adler32_1(state2.check, output, _out, put - _out);
            }
            _out = left;
            if (state2.wrap & 4 && (state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 4 && hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap & 4 && _out) {
    strm.adler = state2.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32_1(state2.check, output, _out, strm.next_out - _out) : adler32_1(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state2.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state2;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state2.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = { inflateReset: inflateReset_1, inflateReset2: inflateReset2_1, inflateResetKeep: inflateResetKeep_1, inflateInit: inflateInit_1, inflateInit2: inflateInit2_1, inflate: inflate_2$1, inflateEnd: inflateEnd_1, inflateGetHeader: inflateGetHeader_1, inflateSetDictionary: inflateSetDictionary_1, inflateInfo };
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString2 = Object.prototype.toString;
var { Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR } = constants$2;
function Inflate$1(options) {
  this.options = common.assign({ chunkSize: 1024 * 64, windowBits: 15, to: "" }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString2.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = { Inflate: Inflate_1$1, inflate: inflate_2, inflateRaw: inflateRaw_1$1, ungzip: ungzip$1, constants };
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = { Deflate: Deflate_1, deflate: deflate_1, deflateRaw: deflateRaw_1, gzip: gzip_1, Inflate: Inflate_1, inflate: inflate_1, inflateRaw: inflateRaw_1, ungzip: ungzip_1, constants: constants_1 };
function _basicAssign(target, source) {
  var prop;
  for (prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      target[prop] = source[prop];
    }
  }
  return target;
}
function _getProperty(source, prop) {
  return _isArray(source) ? source[Number(prop)] : source[prop];
}
function _getByPath(source, path) {
  if (!source) {
    return void 0;
  }
  var prop = path.shift();
  var value = _getProperty(source, prop);
  if (path.length && (_isArray(value) || _isRecord(value))) {
    return _getByPath(value, path);
  }
  return value;
}
function _isArray(value) {
  return Array.isArray(value);
}
function _isRecord(value) {
  return value && typeof value === "object";
}
function _setProperty(target, prop, value) {
  if (_isArray(target)) {
    target[Number(prop)] = value;
    return;
  }
  if (_isRecord(target)) {
    target[prop] = value;
    return;
  }
  throw new Error("shallowClone: target must be an object or an array");
}
function _shallowClone(source) {
  if (_isArray(source))
    return source.slice(0);
  if (_isRecord(source))
    return _basicAssign({}, source);
  throw new Error("shallowClone: source must be an object or an array");
}
function get2(source, key) {
  if (!key) {
    return source;
  }
  return _getByPath(source, key.split("/"));
}
function set(source, key, value) {
  if (!key) {
    if (_isArray(value) || _isRecord(value)) {
      return value;
    }
    throw new Error("set: cannot replace value with a non-record value");
  }
  if (get2(source, key) === value) {
    return source;
  }
  var target = _shallowClone(source);
  var path = key.split("/");
  var currSource = source;
  var currTarget = target;
  while (path.length) {
    var prop = path.shift();
    if (path.length) {
      var nextSource = _getProperty(currSource, prop);
      if (nextSource === void 0) {
        nextSource = {};
        _setProperty(currSource, prop, nextSource);
      }
      if (!_isArray(nextSource) && !_isRecord(nextSource)) {
        throw new Error('set: path is not targeting an object nor an array: "' + key + '"');
      }
      currSource = nextSource;
      var nextTarget = _shallowClone(currSource);
      _setProperty(currTarget, prop, nextTarget);
      currTarget = nextTarget;
    } else {
      _setProperty(currTarget, prop, value);
    }
  }
  return target;
}
var EMPTY_ARRAY$4 = [];
var EMPTY_RECORD$1 = {};
var DEFAULT_VIEWPORT_VALUE = "auto";
var DEFAULT_ZOOM_VALUE = 1;
var VIEWPORT_OPTIONS = [{ name: "auto", title: "Full", rect: { width: "auto" } }, { name: "768", title: "768px", rect: { width: 768 } }, { name: "375", title: "375px", rect: { width: 375, height: 667 } }, { name: "320", title: "320px", rect: { width: 320, height: 568 } }];
var ZOOM_OPTIONS = [{ value: 0.5, title: "50%" }, { value: 0.75, title: "75%" }, { value: 1, title: "100%" }, { value: 1.5, title: "150%" }, { value: 2, title: "200%" }, { value: 3, title: "300%" }];
function createPubsub() {
  const subscribers = /* @__PURE__ */ new Set();
  return { publish(msg) {
    for (const subscriber of subscribers) {
      subscriber(msg);
    }
  }, subscribe(subscriber) {
    subscribers.add(subscriber);
    return () => {
      subscribers.delete(subscriber);
    };
  } };
}
var qs = { parse(str) {
  const params = new URLSearchParams("?" + str);
  const q = {};
  params.forEach((value, key) => {
    q[key] = value;
  });
  return q;
}, stringify(q) {
  return Object.entries(q).map((_ref) => {
    let [key, value] = _ref;
    return "".concat(key, "=").concat(value);
  }).join("&");
} };
function resolveLocation(scopes, path) {
  const segments = path.split("/").slice(1).filter(Boolean);
  const p = segments.join("/");
  if (segments.length === 0) {
    return { scope: null, story: null };
  }
  for (const scope of scopes) {
    for (const story of scope.stories) {
      const storyPath = [scope.name, story.name].filter(Boolean).join("/");
      if (p === storyPath) {
        return { scope, story };
      }
    }
  }
  return { scope: null, story: null };
}
function buildFrameUrl(params) {
  const { baseUrl = "/frame/", path, payload, scheme, viewport, zoom } = params;
  return [baseUrl, "?path=".concat(encodeURIComponent(path)), "&scheme=".concat(scheme), "&viewport=".concat(viewport), "&zoom=".concat(zoom), ...Object.entries(payload).map((_ref2) => {
    let [key, value] = _ref2;
    return "&".concat(key, "=").concat(value);
  })].join("");
}
var PropsContext = (0, import_react2.createContext)(null);
function useProps() {
  const props = (0, import_react2.useContext)(PropsContext);
  if (!props) {
    throw new Error("Props: missing context value");
  }
  return props;
}
var BooleanProp = (0, import_react2.memo)(function BooleanProp2(props) {
  const { schema: schema2, value } = props;
  const { setPropValue } = useProps();
  return (0, import_jsx_runtime2.jsxs)(Flex, { as: "label", padding: 3, children: [(0, import_jsx_runtime2.jsx)(Box, { marginRight: 2, style: { lineHeight: 0 }, children: (0, import_jsx_runtime2.jsx)(Checkbox, { checked: value || false, onChange: (event) => setPropValue(schema2.name, event.currentTarget.checked) }) }), (0, import_jsx_runtime2.jsx)(Box, { paddingY: 1, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", children: schema2.name }) })] });
});
var NumberProp = (0, import_react2.memo)(function NumberProp2(props) {
  const { schema: schema2, value = "" } = props;
  const { setPropValue } = useProps();
  return (0, import_jsx_runtime2.jsxs)(Box, { padding: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", children: schema2.name }), (0, import_jsx_runtime2.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime2.jsx)(TextInput, { fontSize: [2, 2, 1], onChange: (event) => setPropValue(schema2.name, Number(event.currentTarget.value)), padding: 2, value }) })] });
});
var SelectProp = (0, import_react2.memo)(function SelectProp2(props) {
  const { schema: schema2, value: valueProp } = props;
  const { setPropValue } = useProps();
  const value = (0, import_react2.useMemo)(() => {
    const entries = Object.entries(schema2.options);
    for (const [k, v] of entries) {
      if (v === valueProp) {
        return k;
      }
    }
    return "";
  }, [schema2, valueProp]);
  return (0, import_jsx_runtime2.jsxs)(Box, { padding: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", children: schema2.name }), (0, import_jsx_runtime2.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime2.jsx)(Select, { fontSize: [2, 2, 1], onChange: (event) => {
    const optionKey = event.currentTarget.value;
    const optionValue = schema2.options[optionKey];
    setPropValue(schema2.name, optionValue);
  }, padding: 2, radius: 2, value: String(value || ""), children: Object.entries(schema2.options).map((_ref3) => {
    let [key] = _ref3;
    return (0, import_jsx_runtime2.jsx)("option", { value: key, children: key }, key);
  }) }) })] });
});
var StringProp = (0, import_react2.memo)(function StringProp2(props) {
  const { schema: schema2, value } = props;
  const { setPropValue } = useProps();
  return (0, import_jsx_runtime2.jsxs)(Box, { padding: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", children: schema2.name }), (0, import_jsx_runtime2.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime2.jsx)(TextInput, { fontSize: [2, 2, 1], onChange: (event) => setPropValue(schema2.name, event.currentTarget.value), padding: 2, value: value || "" }) })] });
});
var TextProp = (0, import_react2.memo)(function TextProp2(props) {
  const { schema: schema2, value } = props;
  const { setPropValue } = useProps();
  return (0, import_jsx_runtime2.jsxs)(Box, { padding: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", children: schema2.name }), (0, import_jsx_runtime2.jsx)(Box, { marginTop: 2, children: (0, import_jsx_runtime2.jsx)(TextArea, { fontSize: [2, 2, 1], onChange: (event) => setPropValue(schema2.name, event.currentTarget.value), rows: 4, value: value || "" }) })] });
});
function Prop(props) {
  const { schema: schema2, value } = props;
  if (schema2.type === "boolean") {
    return (0, import_jsx_runtime2.jsx)(BooleanProp, { schema: schema2, value });
  }
  if (schema2.type === "number") {
    return (0, import_jsx_runtime2.jsx)(NumberProp, { schema: schema2, value });
  }
  if (schema2.type === "select") {
    return (0, import_jsx_runtime2.jsx)(SelectProp, { schema: schema2, value });
  }
  if (schema2.type === "string") {
    return (0, import_jsx_runtime2.jsx)(StringProp, { schema: schema2, value });
  }
  if (schema2.type === "text") {
    return (0, import_jsx_runtime2.jsx)(TextProp, { schema: schema2, value });
  }
  return (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsxs)(Text, { size: 1, weight: "semibold", children: ["Unknown Prop type:", " ", (0, import_jsx_runtime2.jsxs)("code", { children: [schema2.name, ": ", schema2.type] })] }) });
}
var PropsInspector = (0, import_react2.memo)(function PropsInspector2() {
  const { schemas, value } = useProps();
  return (0, import_jsx_runtime2.jsxs)(Box, { padding: 2, children: [schemas.length === 0 && (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: [2, 2, 1], children: "No properties" }) }), schemas.length > 0 && schemas.map((schema2, schemaIndex) => (0, import_jsx_runtime2.jsx)(Prop, { schema: schema2, value: value[schema2.name] === void 0 ? schema2.defaultValue : value[schema2.name] }, schemaIndex))] });
});
var isEqual = import_isEqual3.default;
var WorkshopContext = (0, import_react2.createContext)(null);
function useWorkshop() {
  const workshop = (0, import_react2.useContext)(WorkshopContext);
  if (!workshop) {
    throw new Error("Workshop: missing context value");
  }
  return workshop;
}
var btoa = typeof window === "undefined" ? (str) => Buffer.from(str, "binary").toString("base64") : window.btoa;
var atob = typeof window === "undefined" ? (str) => Buffer.from(str, "base64").toString("binary") : window.atob;
function uint8ArrayToBase64(uint8array) {
  let str = "";
  for (let i = 0, { length } = uint8array; i < length; i++) {
    str += String.fromCharCode(uint8array[i]);
  }
  return btoa(str);
}
function base64ToUint8Array(base64) {
  const binStr = atob(base64);
  const len = binStr.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binStr.charCodeAt(i);
  }
  return bytes;
}
function decode(input) {
  if (input.length === 0)
    return "";
  const arr = base64ToUint8Array(input);
  return pako.inflate(arr, { to: "string" });
}
function encode(input) {
  if (input.length === 0)
    return "";
  const arr = pako.deflate(input);
  return uint8ArrayToBase64(arr);
}
function encodeValue(val) {
  return encode(JSON.stringify(val));
}
function decodeValue(val) {
  try {
    return JSON.parse(decode(val));
  } catch (_) {
    return {};
  }
}
function propsReducer(state2, msg) {
  if (msg.type === "workshop/props/setValue") {
    return { ...state2, value: msg.value };
  }
  if (msg.type === "workshop/props/registerProp") {
    return { ...state2, schemas: state2.schemas.concat([msg.schema]) };
  }
  if (msg.type === "workshop/props/unregisterProp") {
    const value = { ...state2.value };
    delete value[msg.name];
    return { ...state2, schemas: state2.schemas.filter((s) => s.name !== msg.name), value };
  }
  if (msg.type === "workshop/props/setPropValue") {
    return { ...state2, value: { ...state2.value, [msg.name]: msg.value } };
  }
  return state2;
}
var PropsProvider = (0, import_react2.memo)(function PropsProvider2(props) {
  const { children } = props;
  const { channel, broadcast, payload } = useWorkshop();
  const encodedValue = payload.value;
  const encodedValueRef = (0, import_react2.useRef)(encodedValue);
  const [{ schemas, value }, setState] = (0, import_react2.useState)({ schemas: [], value: decodeValue(String(encodedValue)) || {} });
  const registerProp = (0, import_react2.useCallback)((schema2) => {
    broadcast({ type: "workshop/props/registerProp", schema: schema2 });
  }, [broadcast]);
  const unregisterProp = (0, import_react2.useCallback)((name) => {
    broadcast({ type: "workshop/props/unregisterProp", name });
  }, [broadcast]);
  const setPropValue = (0, import_react2.useCallback)((name, value2) => {
    broadcast({ type: "workshop/props/setPropValue", name, value: value2 });
  }, [broadcast]);
  const ctx = (0, import_react2.useMemo)(() => ({ registerProp, schemas, setPropValue, unregisterProp, value }), [registerProp, schemas, setPropValue, unregisterProp, value]);
  (0, import_react2.useEffect)(() => channel.subscribe((msg) => {
    setState((prevState) => {
      const nextState = propsReducer(prevState, msg);
      if (isEqual(prevState, nextState)) {
        return prevState;
      }
      return nextState;
    });
  }), [channel]);
  (0, import_react2.useEffect)(() => {
    const nextEncodedValue = encodeValue(value);
    if (encodedValueRef.current !== nextEncodedValue) {
      encodedValueRef.current = nextEncodedValue;
      broadcast({ type: "workshop/setPayloadValue", key: "value", value: nextEncodedValue });
    }
  }, [broadcast, value]);
  (0, import_react2.useEffect)(() => {
    if (encodedValueRef.current === encodedValue) {
      return;
    }
    encodedValueRef.current = encodedValue;
    setState((prevState) => ({ ...prevState, value: decodeValue(String(encodedValue)) || {} }));
  }, [encodedValue]);
  return (0, import_jsx_runtime2.jsx)(PropsContext.Provider, { value: ctx, children });
});
function propsPlugin() {
  return { name: "props", title: "Properties", inspector: PropsInspector, provider: PropsProvider };
}
var WorkshopProvider = (0, import_react2.memo)(function WorkshopProvider2(props) {
  const { broadcast, children, channel, config, frameReady, origin, path, payload, scheme, viewport = "auto", zoom = 1 } = props;
  const { plugins: pluginsProp = EMPTY_ARRAY$4, collections = EMPTY_ARRAY$4, frameUrl = "/frame/", scopes, title = "Workshop" } = config;
  if (!payload) {
    throw new Error("missing `payload` property");
  }
  const plugins = (0, import_react2.useMemo)(() => [propsPlugin(), ...pluginsProp], [pluginsProp]);
  const { scope, story } = (0, import_react2.useMemo)(() => resolveLocation(scopes, path), [path, scopes]);
  const workshop = (0, import_react2.useMemo)(() => ({ plugins, broadcast, channel, collections, frameReady, frameUrl, origin, path, payload, scheme, scope, scopes, story, title, viewport, zoom }), [plugins, broadcast, channel, collections, frameReady, frameUrl, origin, path, payload, scheme, scope, scopes, story, title, viewport, zoom]);
  let wrappedChildren = children;
  for (const plugin of plugins) {
    if (plugin.provider) {
      wrappedChildren = (0, import_react2.createElement)(plugin.provider, { options: plugin.options || EMPTY_RECORD$1 }, wrappedChildren);
    }
  }
  return (0, import_jsx_runtime2.jsx)(WorkshopContext.Provider, { value: workshop, children: wrappedChildren });
});
function workshopReducer(state2, msg) {
  if (msg.type === "workshop/frameReady") {
    return { ...state2, frameReady: true };
  }
  if (msg.type === "workshop/setState") {
    if (isEqual(state2, msg.value)) {
      return state2;
    }
    return msg.value;
  }
  if (msg.type === "workshop/setZoom") {
    if (state2.zoom === msg.value)
      return state2;
    return { ...state2, zoom: msg.value };
  }
  if (msg.type === "workshop/setViewport") {
    if (state2.viewport === msg.value)
      return state2;
    return { ...state2, viewport: msg.value };
  }
  if (msg.type === "workshop/toggleScheme") {
    return { ...state2, scheme: state2.scheme === "light" ? "dark" : "light" };
  }
  if (msg.type === "workshop/setScheme") {
    if (state2.scheme === msg.value)
      return state2;
    return { ...state2, scheme: msg.value };
  }
  if (msg.type === "workshop/setPath") {
    if (state2.path === msg.value)
      return state2;
    return { ...state2, path: msg.value };
  }
  if (msg.type === "workshop/setPayload") {
    if (isEqual(state2.payload, msg.value)) {
      return state2;
    }
    return { ...state2, payload: msg.value };
  }
  if (msg.type === "workshop/setPayloadValue") {
    const payload = { ...state2.payload, [msg.key]: msg.value };
    if (isEqual(state2.payload, payload)) {
      return state2;
    }
    return { ...state2, payload };
  }
  return state2;
}
var ROOT_PATH = (() => {
  try {
    return process.env.ROOT_PATH;
  } catch (_) {
    return void 0;
  }
})();
var RE_URL = /http:\/\/([^:/\s]+)(:[0-9]+)?/g;
var RE_VITE_FS_PREFIX = /\/@fs\//g;
var RE_VITE_FS_SUFFIX = /\?([a-z]{1})=([0-9]+)/g;
function formatStack(stack) {
  let ret = decodeURIComponent(stack);
  ret = stack.replace(RE_URL, "").replace(RE_VITE_FS_PREFIX, "/").replace(RE_VITE_FS_SUFFIX, "");
  if (ROOT_PATH)
    return replaceRootPath(ret, ROOT_PATH + "/");
  return ret;
}
function replaceRootPath(str, rootPath) {
  const re = new RegExp(rootPath.replace(/\//g, "\\/"), "g");
  return str.replace(re, "");
}
var WorkshopCanvas$1 = (0, import_react2.memo)(function WorkshopCanvas2() {
  const { story } = useWorkshop();
  const [state2, setState] = (0, import_react2.useState)({ error: null, errorInfo: null });
  const catchError2 = (0, import_react2.useCallback)((_ref4) => {
    let { error, info: errorInfo } = _ref4;
    setState({ error, errorInfo });
  }, []);
  const handleRetry = (0, import_react2.useCallback)(() => {
    setState({ error: null, errorInfo: null });
  }, []);
  if (!story) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  }
  if (state2.error) {
    return (0, import_jsx_runtime2.jsx)(Card, { as: "main", height: "fill", overflow: "auto", tone: "critical", children: (0, import_jsx_runtime2.jsx)(ErrorScreen, { error: state2.error, errorInfo: state2.errorInfo, onRetry: handleRetry }) });
  }
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)("h1", { hidden: true, children: story.title }), (0, import_jsx_runtime2.jsx)(import_react2.Suspense, { fallback: (0, import_jsx_runtime2.jsx)(LoadingScreen, { story }), children: (0, import_jsx_runtime2.jsx)(Card, { as: "main", height: "fill", children: (0, import_jsx_runtime2.jsx)(ErrorBoundary, { onCatch: catchError2, children: (0, import_react2.createElement)(story.component) }) }) })] });
});
var LoadingScreen = (0, import_react2.memo)(function LoadingScreen2(props) {
  const { story } = props;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsxs)("h1", { hidden: true, children: ["Loading ", (0, import_jsx_runtime2.jsx)("em", { children: story.title }), "…"] }), (0, import_jsx_runtime2.jsx)(Flex, { align: "center", as: "main", height: "fill", justify: "center", children: (0, import_jsx_runtime2.jsx)(Spinner, { muted: true }) })] });
});
var ErrorScreen = (0, import_react2.memo)(function ErrorScreen2(props) {
  const { error, errorInfo, onRetry } = props;
  return (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime2.jsx)(Heading, { as: "h1", size: [1, 1, 2], children: error.message }), (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsx)(Button, { onClick: onRetry, text: "Retry" }) }), error.stack && (0, import_jsx_runtime2.jsx)(Code, { size: 1, children: formatStack(error.stack) }), errorInfo && (0, import_jsx_runtime2.jsx)(Code, { size: 1, children: "Component stack:" + formatStack(errorInfo.componentStack) })] }) });
});
function isArray2(value) {
  return Array.isArray(value);
}
function isRecord(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function createMainController() {
  const _subscribers = /* @__PURE__ */ new Set();
  let _msgQueue = [];
  let _flushTimeout = null;
  function _flush() {
    if (_flushTimeout) {
      clearInterval(_flushTimeout);
    }
    _flushTimeout = setTimeout(() => {
      window.parent.postMessage(_msgQueue);
      _msgQueue = [];
      _flushTimeout = null;
    }, 0);
  }
  function _handleMessage(event) {
    const msgs = event.data;
    if (isArray2(msgs)) {
      for (const msg of msgs) {
        if (isRecord(msg) && typeof msg.type === "string" && msg.type.startsWith("workshop/")) {
          for (const subscriber of _subscribers) {
            subscriber(msg);
          }
        }
      }
    }
  }
  function _mount() {
    window.addEventListener("message", _handleMessage, false);
  }
  function _unmount() {
    window.removeEventListener("message", _handleMessage, false);
  }
  return { message: { publish(msg) {
    _msgQueue.push(msg);
    _flush();
  }, subscribe(subscriber) {
    _subscribers.add(subscriber);
    if (_subscribers.size === 1) {
      _mount();
    }
    return () => {
      _subscribers.delete(subscriber);
      if (_subscribers.size === 0) {
        _unmount();
      }
    };
  } } };
}
function getStateFromLocation$1() {
  const query = typeof window === "undefined" ? {} : qs.parse(window.location.search.slice(1));
  const { path = "/", scheme, viewport, zoom, ...payload } = query;
  return { frameReady: false, path, payload, scheme: typeof scheme === "string" ? scheme : "light", viewport: typeof viewport === "string" ? viewport : "auto", zoom: typeof zoom === "string" ? Number(zoom) : 1 };
}
(0, import_react2.memo)(function WorkshopFrame2(props) {
  const { config, setScheme } = props;
  const main = (0, import_react2.useMemo)(() => createMainController(), []);
  const channel = (0, import_react2.useMemo)(() => createPubsub(), []);
  const [boundaryElement, setBoundaryElement] = (0, import_react2.useState)(null);
  const [portalElement, setPortalElement] = (0, import_react2.useState)(null);
  const broadcast = (0, import_react2.useCallback)((msg) => {
    channel.publish(msg);
    main.message.publish(msg);
  }, [channel, main]);
  const [{ frameReady, path, payload, scheme, viewport, zoom }, setState] = (0, import_react2.useState)(() => getStateFromLocation$1());
  (0, import_react2.useEffect)(() => channel.subscribe((msg) => setState((s) => workshopReducer(s, msg))), [channel]);
  (0, import_react2.useEffect)(() => main.message.subscribe(channel.publish), [channel, main]);
  (0, import_react2.useEffect)(() => setScheme(scheme), [setScheme, scheme]);
  (0, import_react2.useEffect)(() => broadcast({ type: "workshop/frameReady" }), [broadcast]);
  return (0, import_jsx_runtime2.jsx)(ToastProvider, { children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: boundaryElement, children: (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, children: (0, import_jsx_runtime2.jsx)(WorkshopProvider, { broadcast, config, channel, frameReady, origin: "frame", path, payload, scheme, viewport, zoom, children: (0, import_jsx_runtime2.jsxs)(Card, { height: "fill", ref: setBoundaryElement, children: [(0, import_jsx_runtime2.jsx)(WorkshopCanvas$1, {}), (0, import_jsx_runtime2.jsx)("div", { "data-portal": "", ref: setPortalElement })] }) }) }) }) });
});
var __freeze$4$1 = Object.freeze;
var __defProp$4$1 = Object.defineProperty;
var __template$4$1 = (cooked, raw) => __freeze$4$1(__defProp$4$1(cooked, "raw", { value: __freeze$4$1(raw || cooked.slice()) }));
var _a$4$1;
dt(_a$4$1 || (_a$4$1 = __template$4$1(["\n  body {\n    background-color: ", ";\n  }\n"])), (_ref5) => {
  let { theme } = _ref5;
  return theme.sanity.color.base.bg;
});
var __freeze$3$1 = Object.freeze;
var __defProp$3$1 = Object.defineProperty;
var __template$3$1 = (cooked, raw) => __freeze$3$1(__defProp$3$1(cooked, "raw", { value: __freeze$3$1(raw || cooked.slice()) }));
var _a$3$1;
var MemoTab = (0, import_react2.memo)(Tab);
var Root$4$1 = ut(Card)(_a$3$1 || (_a$3$1 = __template$3$1(["\n  line-height: 0;\n\n  @media screen and (max-width: ", "px) {\n    text-align: center;\n  }\n"])), (_ref6) => {
  let { theme } = _ref6;
  return theme.sanity.media[1] - 1;
});
var InspectorHeader = (0, import_react2.memo)(function InspectorHeader2(props) {
  const { currentTabId, onTabChange, tabs } = props;
  const layerStyle = (0, import_react2.useMemo)(() => ({ flex: "none", position: "sticky", top: 0 }), []);
  const children = (0, import_react2.useMemo)(() => tabs.map((tab) => (0, import_jsx_runtime2.jsx)(InspectorTabView, { onTabChange, selected: tab.id === currentTabId, tab }, tab.id)), [currentTabId, onTabChange, tabs]);
  return (0, import_jsx_runtime2.jsx)(Layer, { style: layerStyle, children: (0, import_jsx_runtime2.jsx)(Root$4$1, { padding: 2, shadow: 1, children: (0, import_jsx_runtime2.jsx)(TabList, { space: 1, children }) }) });
});
function InspectorTabView(props) {
  const { onTabChange, selected, tab } = props;
  const handleClick = (0, import_react2.useCallback)(() => {
    onTabChange(tab.id);
  }, [onTabChange, tab]);
  return (0, import_jsx_runtime2.jsx)(MemoTab, { "aria-controls": "".concat(tab.id, "-panel"), fontSize: [2, 2, 1], id: tab.id, label: tab.label, onClick: handleClick, selected, tone: tab.tone });
}
var __freeze$2$1 = Object.freeze;
var __defProp$2$1 = Object.defineProperty;
var __template$2$1 = (cooked, raw) => __freeze$2$1(__defProp$2$1(cooked, "raw", { value: __freeze$2$1(raw || cooked.slice()) }));
var _a$2$1;
var Root$3$1 = ut(Card)(_a$2$1 || (_a$2$1 = __template$2$1(["\n  overflow: hidden;\n\n  @media screen and (min-width: ", "px) {\n    border-left: 1px solid var(--card-border-color);\n    min-width: 180px;\n    max-width: 300px;\n    overflow: auto;\n  }\n"])), (_ref7) => {
  let { theme } = _ref7;
  return theme.sanity.media[1];
});
var MemoRender = (0, import_react2.memo)(function MemoRender2(props) {
  return (0, import_react2.createElement)(props.component, { options: props.options });
});
var WorkshopInspector = (0, import_react2.memo)(function WorkshopInspector2(props) {
  const { expanded } = props;
  const { plugins } = useWorkshop();
  const tabs = (0, import_react2.useMemo)(() => {
    return plugins.filter((plugin) => plugin.inspector).map((plugin) => {
      return { id: plugin.name, label: plugin.title, tone: void 0, plugin };
    });
  }, [plugins]);
  const [tabId, setTabId] = (0, import_react2.useState)(tabs.length > 0 ? tabs[0].id : null);
  const currentTab = tabs.find((tab) => tab.id === tabId);
  const showTabs = tabs.length > 1;
  const display = (0, import_react2.useMemo)(() => expanded ? ["block"] : ["none", "none", "block"], [expanded]);
  return (0, import_jsx_runtime2.jsx)(Root$3$1, { display, flex: 1, children: (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", children: [showTabs && (0, import_jsx_runtime2.jsx)(InspectorHeader, { currentTabId: tabId, onTabChange: setTabId, tabs }), showTabs && tabs.map((tab) => (0, import_jsx_runtime2.jsx)(TabPanel, { "aria-labelledby": "".concat(tab.id, "-tab"), flex: 1, hidden: tab.id !== tabId, id: "".concat(tab.id, "-panel"), overflow: "auto", children: tab.plugin.inspector && (0, import_jsx_runtime2.jsx)(MemoRender, { component: tab.plugin.inspector, options: tab.plugin.options || EMPTY_RECORD$1 }) }, tab.id)), !showTabs && (currentTab == null ? void 0 : currentTab.plugin.inspector) && (0, import_jsx_runtime2.jsx)(Box, { flex: 1, overflow: "auto", children: (0, import_jsx_runtime2.jsx)(MemoRender, { component: currentTab.plugin.inspector, options: currentTab.plugin.options || EMPTY_RECORD$1 }) })] }) });
});
var debounce2 = import_debounce2.default;
function NavbarBreadcrumbs() {
  const { broadcast, scope, story, title } = useWorkshop();
  const handleHomeClick = (0, import_react2.useCallback)((event) => {
    event.preventDefault();
    broadcast({ type: "workshop/setPath", value: "/" });
  }, [broadcast]);
  return (0, import_jsx_runtime2.jsx)(NavbarBreadcrumbsView, { onHomeClick: handleHomeClick, scopeTitle: scope == null ? void 0 : scope.title, storyTitle: story == null ? void 0 : story.title, title });
}
var NavbarBreadcrumbsView = (0, import_react2.memo)(function NavbarBreadcrumbsView2(props) {
  const { onHomeClick, scopeTitle, storyTitle, title } = props;
  return (0, import_jsx_runtime2.jsxs)(Breadcrumbs, { separator: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: [2, 2, 1], children: "/" }), space: 2, children: [(0, import_jsx_runtime2.jsx)(Text, { size: [2, 2, 1], weight: "bold", children: (0, import_jsx_runtime2.jsx)("a", { href: "/", onClick: onHomeClick, style: { color: "inherit" }, children: title }) }), scopeTitle && (0, import_jsx_runtime2.jsx)(Text, { align: "center", size: [2, 2, 1], children: scopeTitle }), storyTitle && (0, import_jsx_runtime2.jsx)(Text, { size: [2, 2, 1], children: storyTitle })] });
});
var OpenCanvasButton = (0, import_react2.memo)(function OpenCanvasButton2() {
  const { frameUrl, path, payload, scheme, zoom, viewport } = useWorkshop();
  const canvasUrl = (0, import_react2.useMemo)(() => path === "/" ? void 0 : buildFrameUrl({ baseUrl: frameUrl, path, payload, scheme, zoom, viewport }), [frameUrl, path, payload, scheme, zoom, viewport]);
  return (0, import_jsx_runtime2.jsx)(Button, { as: canvasUrl ? "a" : "button", disabled: !canvasUrl, fontSize: 1, href: canvasUrl, iconRight: LaunchIcon, mode: "ghost", padding: 2, rel: "noopener noreferrer", target: "_blank", text: "Open story" });
});
function SchemeMenu() {
  const { broadcast, scheme } = useWorkshop();
  const handleToggleScheme = (0, import_react2.useCallback)(() => {
    broadcast({ type: "workshop/toggleScheme" });
  }, [broadcast]);
  return (0, import_jsx_runtime2.jsx)(SchemeMenuView, { dark: scheme === "dark", onToggleScheme: handleToggleScheme });
}
var SchemeMenuView = (0, import_react2.memo)(function SchemeMenuView2(props) {
  const { dark, onToggleScheme } = props;
  return (0, import_jsx_runtime2.jsx)(Button, { fontSize: 1, icon: dark ? MoonIcon : SunIcon, mode: "bleed", onClick: onToggleScheme, padding: 2 });
});
var ViewportMenu = (0, import_react2.memo)(function ViewportMenu2() {
  const { broadcast, story, viewport } = useWorkshop();
  const setViewport = (0, import_react2.useCallback)((value) => {
    broadcast({ type: "workshop/setViewport", value });
  }, [broadcast]);
  return (0, import_jsx_runtime2.jsx)(ViewportMenuView, { disabled: !story, setViewport, viewport });
});
var POPOVER_PROPS$1 = { constrainSize: true, matchReferenceWidth: true, placement: "bottom", portal: true };
var ViewportMenuView = (0, import_react2.memo)(function ViewportMenuView2(props) {
  var _a2;
  const { disabled, setViewport, viewport } = props;
  return (0, import_jsx_runtime2.jsx)(MenuButton, { button: (0, import_jsx_runtime2.jsx)(Button, { disabled, fontSize: 1, iconRight: SelectIcon, mode: "ghost", padding: 2, style: { minWidth: 80 }, text: (_a2 = VIEWPORT_OPTIONS.find((o) => o.name === viewport)) == null ? void 0 : _a2.title }), id: "viewport-menu", menu: (0, import_jsx_runtime2.jsx)(Menu, { children: VIEWPORT_OPTIONS.map((option) => (0, import_jsx_runtime2.jsx)(MenuItem, { fontSize: 1, onClick: () => setViewport(option.name), padding: 2, selected: option.name === viewport, text: option.title }, option.name)) }), popover: POPOVER_PROPS$1 });
});
function ZoomMenu() {
  const { broadcast, story, zoom } = useWorkshop();
  const setZoom = (0, import_react2.useCallback)((value) => broadcast({ type: "workshop/setZoom", value }), [broadcast]);
  return (0, import_jsx_runtime2.jsx)(ZoomMenuView, { disabled: !story, setZoom, zoom });
}
var POPOVER_PROPS = { constrainSize: true, matchReferenceWidth: true, placement: "bottom", portal: true };
var ZoomMenuView = (0, import_react2.memo)(function ZoomMenuView2(props) {
  var _a2;
  const { disabled, setZoom, zoom } = props;
  return (0, import_jsx_runtime2.jsx)(MenuButton, { button: (0, import_jsx_runtime2.jsx)(Button, { disabled, fontSize: 1, iconRight: SelectIcon, mode: "ghost", padding: 2, style: { minWidth: 80 }, text: (_a2 = ZOOM_OPTIONS.find((o) => o.value === zoom)) == null ? void 0 : _a2.title }), id: "zoom-menu", menu: (0, import_jsx_runtime2.jsx)(Menu, { children: ZOOM_OPTIONS.map((option) => (0, import_jsx_runtime2.jsx)(MenuItem, { fontSize: 1, onClick: () => setZoom(option.value), padding: 2, selected: option.value === zoom, text: option.title }, option.value)) }), popover: POPOVER_PROPS });
});
var WorkshopNavbar = (0, import_react2.memo)(function WorkshopNavbar2(props) {
  const { inspectorExpanded, navigatorExpanded, onInspectorToggle, onNavigatorToggle } = props;
  const mediaIndex = useMediaIndex();
  const { story, title } = useWorkshop();
  return (0, import_jsx_runtime2.jsx)(Card, { borderBottom: true, flex: "none", padding: 2, style: { lineHeight: 0 }, children: (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, children: [(0, import_jsx_runtime2.jsx)(Box, { display: ["block", "block", "none"], flex: "none", children: (0, import_jsx_runtime2.jsx)(Button, { "aria-label": "Open navigator", fontSize: [2, 2, 1], icon: MenuIcon, mode: "bleed", onClick: onNavigatorToggle, padding: 2, selected: navigatorExpanded }) }), (0, import_jsx_runtime2.jsxs)(Flex, { flex: 1, justify: ["center", "center", "flex-start"], padding: 2, sizing: "border", style: { minWidth: 250 }, children: [mediaIndex < 2 && (0, import_jsx_runtime2.jsx)(Text, { weight: "bold", children: (story == null ? void 0 : story.title) || title }), mediaIndex >= 2 && (0, import_jsx_runtime2.jsx)(NavbarBreadcrumbs, {})] }), (0, import_jsx_runtime2.jsx)(Box, { display: ["block", "block", "none"], flex: "none", children: (0, import_jsx_runtime2.jsx)(Button, { "aria-label": "Open inspector", fontSize: [2, 2, 1], icon: ControlsIcon, mode: "bleed", onClick: onInspectorToggle, padding: 2, selected: inspectorExpanded }) }), (0, import_jsx_runtime2.jsx)(Box, { display: ["none", "none", "block"], flex: "none", children: (0, import_jsx_runtime2.jsxs)(Inline, { space: 1, children: [(0, import_jsx_runtime2.jsx)(OpenCanvasButton, {}), (0, import_jsx_runtime2.jsx)(ViewportMenu, {}), (0, import_jsx_runtime2.jsx)(ZoomMenu, {}), (0, import_jsx_runtime2.jsx)(SchemeMenu, {})] }) })] }) });
});
function parseMenuNode(collections, node, name) {
  if (node.__scope__) {
    const scope = node.__scope__;
    if (scope.name === "@@root@@") {
      return scope.stories.map((s) => ({ type: "story", ...s }));
    }
    return [{ type: "scope", name: scope.name || "@@root@@", title: scope.title || "(root)", scope }];
  }
  const coll = collections.find((c) => c.name === name);
  const entries = Object.entries(node).filter((_ref8) => {
    let [key] = _ref8;
    return key !== "__scope__";
  });
  const items = entries.flatMap((_ref9) => {
    let [key, child] = _ref9;
    return parseMenuNode((coll == null ? void 0 : coll.children) || [], child, key);
  });
  return [{ type: "list", name, title: (coll == null ? void 0 : coll.title) || name, items }];
}
function buildMenu(collections, scopes) {
  const scopeMap = {};
  for (const scope of scopes) {
    const scopeName = scope.name || "@@root@@";
    const prevScope = scopeMap[scopeName] || { name: scopeName, title: scope.title, stories: [] };
    const mergedScope = { ...prevScope, name: scopeName, stories: prevScope.stories.concat(scope.stories) };
    scopeMap[scopeName] = mergedScope;
  }
  let tree = {};
  for (const scope of Object.values(scopeMap)) {
    tree = set(tree, scope.name || "@@root@@", { __scope__: scope });
  }
  const rootNode = { type: "list", name: "@@root@@", items: [] };
  for (const [key, entry] of Object.entries(tree)) {
    rootNode.items.push(...parseMenuNode(collections, entry, key));
  }
  return rootNode;
}
var SearchResults = (0, import_react2.memo)(function SearchResults2(props) {
  const { matches, onStoryClick } = props;
  return (0, import_jsx_runtime2.jsx)(Stack, { space: 1, children: matches.map((_ref10) => {
    let { scope, story } = _ref10;
    return (0, import_jsx_runtime2.jsx)(Card, { as: "a", "data-path": "/".concat(scope.name, "/").concat(story.name), href: "/".concat(scope.name, "/").concat(story.name), onClick: onStoryClick, padding: 2, radius: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, textOverflow: "ellipsis", children: [scope.title || "", story.title].filter(Boolean).join(" / ") }) }, "".concat(scope.name, "/").concat(story.name));
  }) });
});
var StoryTree = (0, import_react2.memo)(function StoryTree2(props) {
  const { items } = props;
  return (0, import_jsx_runtime2.jsx)(Tree, { space: 1, children: (0, import_jsx_runtime2.jsx)(MenuItems, { items }) });
});
var MenuItems = (0, import_react2.memo)(function MenuItems2(props) {
  const { basePath = "", items } = props;
  const { broadcast, path: workshopPath, scope: currentScope, story: currentStory } = useWorkshop();
  const handleStoryClick = (0, import_react2.useCallback)((event) => {
    event.preventDefault();
    const target = event.currentTarget;
    const targetPath = target.getAttribute("data-path");
    if (targetPath) {
      broadcast({ type: "workshop/setPath", value: targetPath });
    }
  }, [broadcast]);
  return (0, import_react2.useMemo)(() => {
    if (items.length === 0) {
      return null;
    }
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: items.map((item, itemIndex) => {
      if (item.type === "list") {
        const path = "".concat(basePath, "/").concat(item.name);
        return (0, import_jsx_runtime2.jsx)(MemoList, { expanded: workshopPath.startsWith(path + "/"), item, path }, item.name || itemIndex);
      }
      if (item.type === "story") {
        return (0, import_jsx_runtime2.jsx)(TreeItem, { "data-path": "/".concat(item.name || ""), fontSize: [2, 2, 1], href: "/".concat(item.name || ""), onClick: handleStoryClick, padding: 2, selected: (currentStory == null ? void 0 : currentStory.component) === item.component, text: item.title }, item.name);
      }
      if (item.type === "scope") {
        return (0, import_jsx_runtime2.jsx)(MemoScope, { currentStory, expanded: item.scope === currentScope, item, onStoryClick: handleStoryClick }, item.name);
      }
      return (0, import_jsx_runtime2.jsx)(TreeItem, { text: "unknown" }, itemIndex);
    }) });
  }, [basePath, currentScope, currentStory, handleStoryClick, items, workshopPath]);
});
var MemoList = (0, import_react2.memo)(function MemoList2(props) {
  const { expanded, item, path } = props;
  const children = (0, import_react2.useMemo)(() => (0, import_jsx_runtime2.jsx)(MenuItems, { basePath: path, items: item.items }), [item, path]);
  return (0, import_jsx_runtime2.jsx)(TreeItem, { expanded, fontSize: [2, 2, 1], padding: 2, text: item.title, weight: "semibold", children });
});
var MemoScope = (0, import_react2.memo)(function MemoScope2(props) {
  const { currentStory, expanded, item, onStoryClick } = props;
  const children = (0, import_react2.useMemo)(() => item.scope.stories.map((story) => (0, import_jsx_runtime2.jsx)(TreeItem, { "data-path": "/".concat(item.scope.name, "/").concat(story.name), fontSize: [2, 2, 1], href: "/".concat(item.scope.name, "/").concat(story.name), onClick: onStoryClick, padding: 2, selected: currentStory === story, text: story.title }, story.name)), [currentStory, item, onStoryClick]);
  return (0, import_jsx_runtime2.jsx)(TreeItem, { expanded, fontSize: [2, 2, 1], padding: 2, text: item.title, weight: "semibold", children });
});
var __freeze$1$1 = Object.freeze;
var __defProp$1$1 = Object.defineProperty;
var __template$1$1 = (cooked, raw) => __freeze$1$1(__defProp$1$1(cooked, "raw", { value: __freeze$1$1(raw || cooked.slice()) }));
var _a$1$1;
var Root$2$1 = ut(Card)(_a$1$1 || (_a$1$1 = __template$1$1(["\n  overflow: hidden;\n\n  @media screen and (min-width: ", "px) {\n    border-right: 1px solid var(--card-border-color);\n    min-width: 180px;\n    max-width: 300px;\n    overflow: auto;\n  }\n"])), (_ref11) => {
  let { theme } = _ref11;
  return theme.sanity.media[1];
});
var flexNoneStyle = { flex: "none" };
var lineHeightNoneStyle = { lineHeight: 0 };
var textInputFontSize = [2, 2, 1];
var WorkshopNavigator = (0, import_react2.memo)(function WorkshopNavigator2(props) {
  const { collections = [], expanded } = props;
  const { broadcast, scopes } = useWorkshop();
  const menu = (0, import_react2.useMemo)(() => buildMenu(collections, scopes), [collections, scopes]);
  const [query, setQuery] = (0, import_react2.useState)("");
  const matches = (0, import_react2.useMemo)(() => {
    var _a2;
    if (!query)
      return EMPTY_ARRAY$4;
    const q = query.toLowerCase();
    const ret = [];
    for (const scope of scopes) {
      for (const story of scope.stories) {
        if (((_a2 = scope.title) == null ? void 0 : _a2.toLowerCase().includes(q)) || story.title.toLowerCase().includes(q)) {
          ret.push({ scope, story });
        }
      }
    }
    return ret;
  }, [query, scopes]);
  const handleSearchQueryChange = (0, import_react2.useCallback)((event) => setQuery(event.currentTarget.value), []);
  const handleSearchQueryClear = (0, import_react2.useCallback)(() => setQuery(""), []);
  const handleStoryClick = (0, import_react2.useCallback)((event) => {
    event.preventDefault();
    const target = event.currentTarget;
    const targetPath = target.getAttribute("data-path");
    if (targetPath) {
      broadcast({ type: "workshop/setPath", value: targetPath });
      setQuery("");
    }
  }, [broadcast]);
  return (0, import_jsx_runtime2.jsx)(NavigatorView, { expanded, matches, menu, onSearchQueryChange: handleSearchQueryChange, onSearchQueryClear: handleSearchQueryClear, onStoryClick: handleStoryClick, query });
});
var NavigatorView = (0, import_react2.memo)(function NavigatorView2(props) {
  const { expanded, matches, menu, onSearchQueryChange, onSearchQueryClear, onStoryClick, query } = props;
  const display = (0, import_react2.useMemo)(() => expanded ? ["block"] : ["none", "none", "block"], [expanded]);
  return (0, import_jsx_runtime2.jsx)(Root$2$1, { display, flex: 1, children: (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", children: [(0, import_jsx_runtime2.jsx)(Layer, { style: flexNoneStyle, children: (0, import_jsx_runtime2.jsx)(Card, { padding: 2, shadow: 1, style: lineHeightNoneStyle, children: (0, import_jsx_runtime2.jsx)(TextInput, { border: false, clearButton: Boolean(query), fontSize: textInputFontSize, icon: SearchIcon, onChange: onSearchQueryChange, onClear: onSearchQueryClear, padding: 2, placeholder: "Stories", radius: 2, space: 2, value: query }) }) }), (0, import_jsx_runtime2.jsxs)(Card, { flex: 1, overflow: "auto", children: [query && matches.length > 0 && (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(SearchResults, { matches, onStoryClick }) }), !query && menu.type === "list" && (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(StoryTree, { items: menu.items }) })] })] }) });
});
var __freeze$k = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$k = (cooked, raw) => __freeze$k(__defProp$k(cooked, "raw", { value: __freeze$k(raw || cooked.slice()) }));
var _a$k;
var Frame = ut.iframe(_a$k || (_a$k = __template$k(["\n  display: block;\n  border: 0;\n  height: 100%;\n  width: 100%;\n"])));
var WorkshopCanvas = (0, import_react2.memo)(function WorkshopCanvas22(props) {
  const { frameRef, hidden } = props;
  const { frameReady, frameUrl, path, payload, scheme, title, viewport, zoom } = useWorkshop();
  const viewportOption = VIEWPORT_OPTIONS.find((o) => o.name === viewport) || VIEWPORT_OPTIONS[0];
  const viewportW = viewportOption == null ? void 0 : viewportOption.rect.width;
  const viewportH = viewportOption == null ? void 0 : viewportOption.rect.height;
  const [initialFrameUrl] = (0, import_react2.useState)(() => buildFrameUrl({ baseUrl: frameUrl, path, payload, scheme, viewport, zoom }));
  const containerStyle = (0, import_react2.useMemo)(() => ({ maxWidth: viewportW === "auto" ? void 0 : "".concat((viewportW || 1) * zoom, "px"), maxHeight: viewportH ? "".concat((viewportH || 1) * zoom, "px") : void 0 }), [viewportW, viewportH, zoom]);
  const display = (0, import_react2.useMemo)(() => hidden ? "none" : "block", [hidden]);
  const frameStyle = (0, import_react2.useMemo)(() => ({ transform: "scale(".concat(zoom, ")"), transformOrigin: "0 0", width: "".concat(100 / zoom, "%"), height: "".concat(100 / zoom, "%") }), [zoom]);
  return (0, import_jsx_runtime2.jsx)(Card, { display, flex: 1, overflow: "hidden", tone: "transparent", children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", height: "fill", justify: "center", sizing: "border", children: [path === "/" && (0, import_jsx_runtime2.jsx)(Container, { width: 0, children: (0, import_jsx_runtime2.jsxs)(Stack, { padding: 4, space: 4, children: [(0, import_jsx_runtime2.jsx)(Heading, { align: "center", children: title }), (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, children: "Browse workshop stories in the navigator to the left." })] }) }), !frameReady && path !== "/" && (0, import_jsx_runtime2.jsx)(Spinner, { muted: true }), (0, import_jsx_runtime2.jsx)(Container, { height: "fill", hidden: !frameReady || path === "/", style: containerStyle, width: "auto", children: (0, import_jsx_runtime2.jsx)(Card, { height: "fill", shadow: 1, children: (0, import_jsx_runtime2.jsx)(Frame, { ref: frameRef, src: initialFrameUrl, style: frameStyle }) }) })] }) });
});
function createWorkshopFrameController() {
  const _subscribers = /* @__PURE__ */ new Set();
  let _frameElement = null;
  let _msgQueue = [];
  let _flushTimeout = null;
  function _flush() {
    if (_flushTimeout) {
      clearInterval(_flushTimeout);
    }
    _flushTimeout = setTimeout(() => {
      var _a2;
      (_a2 = _frameElement == null ? void 0 : _frameElement.contentWindow) == null ? void 0 : _a2.postMessage(_msgQueue, window.location.origin);
      _msgQueue = [];
      _flushTimeout = null;
    }, 0);
  }
  function _handleMessage(event) {
    const msgs = event.data;
    if (isArray2(msgs)) {
      for (const msg of msgs) {
        if (isRecord(msg) && typeof msg.type === "string" && msg.type.startsWith("workshop/")) {
          for (const subscriber of _subscribers) {
            subscriber(msg);
          }
        }
      }
    }
  }
  function _mount() {
    if (_frameElement == null ? void 0 : _frameElement.contentWindow) {
      window.addEventListener("message", _handleMessage);
    }
  }
  function _unmount(el) {
    if (el == null ? void 0 : el.contentWindow) {
      window.removeEventListener("message", _handleMessage);
    }
  }
  return { message: { publish(msg) {
    _msgQueue.push(msg);
    _flush();
  }, subscribe(subscriber) {
    _subscribers.add(subscriber);
    return () => {
      _subscribers.delete(subscriber);
    };
  } }, setElement(el) {
    const prevFrameElement = _frameElement;
    _frameElement = el;
    if (el) {
      _mount();
    } else if (prevFrameElement) {
      _unmount(prevFrameElement);
    }
  } };
}
function getStateFromLocation(loc, schemeProp, frameReady) {
  const path = loc.path;
  const query = loc.query || {};
  const { scheme, viewport, zoom, ...payload } = query;
  return { frameReady: frameReady || false, path, payload, scheme: schemeProp || (typeof scheme === "string" ? scheme : "light"), viewport: typeof viewport === "string" ? viewport : "auto", zoom: typeof zoom === "number" ? zoom : 1 };
}
function getQueryFromState(state2) {
  let withPayload = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  const { payload, scheme, viewport, zoom } = state2;
  const query = { scheme };
  if (viewport && viewport !== DEFAULT_VIEWPORT_VALUE) {
    query.viewport = viewport;
  }
  if (zoom && zoom !== DEFAULT_ZOOM_VALUE) {
    query.zoom = zoom;
  }
  if (withPayload) {
    for (const [key, val] of Object.entries(payload)) {
      if (["schema", "viewport", "zoom"].includes(key)) {
        console.warn('Workshop: the payload cannot contain a property named "'.concat(key, '" (protected name)'));
      } else {
        query[key] = val;
      }
    }
  }
  return query;
}
(0, import_react2.memo)(function Workshop2(props) {
  var _a2, _b2;
  const { config, locationStore, onSchemeChange, scheme: schemeProp } = props;
  const withNavbar = (_b2 = (_a2 = config.features) == null ? void 0 : _a2.navbar) != null ? _b2 : true;
  const channel = (0, import_react2.useMemo)(() => createPubsub(), []);
  const frame = (0, import_react2.useMemo)(() => createWorkshopFrameController(), []);
  const [boundaryElement, setBoundaryElement] = (0, import_react2.useState)(null);
  const [portalElement, setPortalElement] = (0, import_react2.useState)(null);
  const [{ frameReady, path, payload, scheme, viewport, zoom }, setState] = (0, import_react2.useState)(() => getStateFromLocation(locationStore.get(), schemeProp));
  const mediaIndex = useMediaIndex();
  const [navigatorExpanded, setNavigatorExpanded] = (0, import_react2.useState)(false);
  const [inspectorExpanded, setInspectorExpanded] = (0, import_react2.useState)(false);
  const frameReadyRef = (0, import_react2.useRef)(frameReady);
  const schemeRef = (0, import_react2.useRef)(scheme);
  const pathRef = (0, import_react2.useRef)(path);
  const queryRef = (0, import_react2.useRef)({ scheme, viewport, zoom, ...payload });
  const broadcast = (0, import_react2.useCallback)((msg) => {
    channel.publish(msg);
    frame.message.publish(msg);
  }, [channel, frame]);
  const _pushLocation = (0, import_react2.useMemo)(() => debounce2((loc) => locationStore.push(loc), 150), [locationStore]);
  const _replaceLocation = (0, import_react2.useMemo)(() => debounce2((loc) => locationStore.replace(loc), 150), [locationStore]);
  const handleNavigatorToggle = (0, import_react2.useCallback)(() => {
    setNavigatorExpanded((v) => !v);
    setInspectorExpanded(false);
  }, []);
  const handleInspectorToggle = (0, import_react2.useCallback)(() => {
    setNavigatorExpanded(false);
    setInspectorExpanded((v) => !v);
  }, []);
  const mediaIndexRef = (0, import_react2.useRef)(mediaIndex);
  (0, import_react2.useEffect)(() => {
    const prevMediaIndex = mediaIndexRef.current;
    if (prevMediaIndex < 2 && mediaIndex >= 2) {
      setNavigatorExpanded(false);
      setInspectorExpanded(false);
    }
    mediaIndexRef.current = mediaIndex;
  }, [mediaIndex]);
  (0, import_react2.useEffect)(() => {
    setNavigatorExpanded(false);
  }, [path]);
  (0, import_react2.useEffect)(() => () => _pushLocation.cancel(), [_pushLocation]);
  (0, import_react2.useEffect)(() => () => _replaceLocation.cancel(), [_replaceLocation]);
  (0, import_react2.useEffect)(() => channel.subscribe((msg) => {
    setState((prevState) => {
      const nextState = workshopReducer(prevState, msg);
      const changed = !isEqual(prevState, nextState);
      if (changed) {
        if (msg.type === "workshop/setPath") {
          if (pathRef.current !== nextState.path) {
            pathRef.current = nextState.path;
            const nextQuery = getQueryFromState(nextState, false);
            _pushLocation({ path: nextState.path, query: nextQuery });
          }
        } else if (msg.type !== "workshop/setState") {
          const nextQuery = getQueryFromState(nextState);
          if (!isEqual(queryRef.current, nextQuery)) {
            queryRef.current = nextQuery;
            _replaceLocation({ path: nextState.path, query: nextQuery });
          }
        }
      }
      return changed ? nextState : prevState;
    });
  }), [_pushLocation, _replaceLocation, channel, locationStore]);
  (0, import_react2.useEffect)(() => frame.message.subscribe(channel.publish), [channel, frame]);
  (0, import_react2.useEffect)(() => {
    frameReadyRef.current = frameReady;
  }, [frameReady]);
  (0, import_react2.useEffect)(() => locationStore.subscribe((loc) => {
    const nextState = getStateFromLocation(loc, void 0, frameReady);
    broadcast({ type: "workshop/setState", value: nextState });
  }), [broadcast, frameReady, locationStore]);
  (0, import_react2.useEffect)(() => {
    schemeRef.current = scheme;
    onSchemeChange(scheme);
  }, [onSchemeChange, scheme]);
  (0, import_react2.useEffect)(() => {
    if (schemeProp) {
      if (schemeRef.current !== schemeProp) {
        schemeRef.current = schemeProp;
        broadcast({ type: "workshop/setScheme", value: schemeProp });
      }
    }
  }, [broadcast, schemeProp]);
  if (!config.scopes) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: "No scopes" });
  }
  return (0, import_jsx_runtime2.jsx)(WorkshopProvider, { config, broadcast, channel, frameReady, origin: "main", path, payload, scheme, viewport, zoom, children: (0, import_jsx_runtime2.jsx)(ToastProvider, { children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: boundaryElement, children: (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, children: (0, import_jsx_runtime2.jsxs)(Flex, { "data-boundary": "", direction: "column", height: "fill", ref: setBoundaryElement, style: { minWidth: 320 }, children: [withNavbar && (0, import_jsx_runtime2.jsx)(WorkshopNavbar, { inspectorExpanded, navigatorExpanded, onInspectorToggle: handleInspectorToggle, onNavigatorToggle: handleNavigatorToggle }), (0, import_jsx_runtime2.jsxs)(Flex, { flex: 1, children: [(0, import_jsx_runtime2.jsx)(WorkshopNavigator, { collections: config.collections, expanded: navigatorExpanded }), (0, import_jsx_runtime2.jsx)(WorkshopCanvas, { frameRef: frame.setElement, hidden: navigatorExpanded || inspectorExpanded }), (0, import_jsx_runtime2.jsx)(WorkshopInspector, { expanded: inspectorExpanded })] }), (0, import_jsx_runtime2.jsx)("div", { "data-portal": "", ref: setPortalElement })] }) }) }) }) });
});
function CreateNewThreadInput(props) {
  const { currentUser, fieldName, mentionOptions, onBlur, onFocus, onKeyDown, onNewThreadCreate, readOnly } = props;
  const [value, setValue] = (0, import_react2.useState)(EMPTY_ARRAY$4);
  const commentInputHandle = (0, import_react2.useRef)(null);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    onNewThreadCreate == null ? void 0 : onNewThreadCreate(value);
    setValue(EMPTY_ARRAY$4);
  }, [onNewThreadCreate, value]);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    if (!hasValue) {
      return;
    }
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.open();
  }, [hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
    if (onKeyDown)
      onKeyDown(event);
  }, [onKeyDown, startDiscard]);
  const confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a2, _b2;
    setValue(EMPTY_ARRAY$4);
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
    (_b2 = commentInputHandle.current) == null ? void 0 : _b2.focus();
  }, []);
  const cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
  }, []);
  const placeholder = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: ["Add comment to ", (0, import_jsx_runtime2.jsx)("b", { children: fieldName })] });
  return (0, import_jsx_runtime2.jsx)(CommentInput, { currentUser, expandOnFocus: true, mentionOptions, onBlur, onChange: setValue, onDiscardCancel: cancelDiscard, onDiscardConfirm: confirmDiscard, onKeyDown: handleInputKeyDown, onFocus, onSubmit: handleSubmit, placeholder, readOnly, ref: commentInputHandle, value });
}
var __freeze$j = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$j = (cooked, raw) => __freeze$j(__defProp$j(cooked, "raw", { value: __freeze$j(raw || cooked.slice()) }));
var _a$j;
var _b$9;
var HeaderFlex = ut(Flex)(_a$j || (_a$j = __template$j(["\n  min-height: 25px;\n"])));
var BreadcrumbsButton = ut(Button)((_ref69) => {
  let { theme } = _ref69;
  const fg = theme.sanity.color.base.fg;
  return at(_b$9 || (_b$9 = __template$j(["\n    --card-fg-color: ", ";\n\n    // The width is needed to make the text ellipsis work\n    // in the breadcrumbs component\n    max-width: 100%;\n  "])), fg);
});
function CommentThreadLayout(props) {
  const { breadcrumbs, canCreateNewThread, children, currentUser, fieldPath, isSelected, mentionOptions, onNewThreadCreate, onPathSelect, readOnly } = props;
  const handleNewThreadCreate = (0, import_react2.useCallback)((payload) => {
    const nextComment = {
      fieldPath,
      message: payload,
      parentCommentId: void 0,
      status: "open",
      // Since this is a new comment, we generate a new thread ID
      threadId: v4_default()
    };
    onNewThreadCreate == null ? void 0 : onNewThreadCreate(nextComment);
  }, [onNewThreadCreate, fieldPath]);
  const handleBreadcrumbsClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onPathSelect == null ? void 0 : onPathSelect({ fieldPath, origin: "inspector", threadId: null });
  }, [fieldPath, onPathSelect]);
  const handleNewThreadClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    if (e2.detail === 0)
      return;
    onPathSelect == null ? void 0 : onPathSelect({ fieldPath, origin: "inspector", threadId: null });
  }, [fieldPath, onPathSelect]);
  const crumbsTitlePath = (0, import_react2.useMemo)(() => (breadcrumbs == null ? void 0 : breadcrumbs.map((p) => p.title)) || [], [breadcrumbs]);
  const lastCrumb = crumbsTitlePath[crumbsTitlePath.length - 1];
  return (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime2.jsx)(HeaderFlex, { align: "center", gap: 2, paddingRight: 1, sizing: "border", children: (0, import_jsx_runtime2.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime2.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime2.jsx)(BreadcrumbsButton, { "aria-label": "Go to ".concat(lastCrumb, " field"), mode: "bleed", onClick: handleBreadcrumbsClick, padding: 2, space: 2, children: (0, import_jsx_runtime2.jsx)(CommentBreadcrumbs, { maxLength: 3, titlePath: crumbsTitlePath }) }) }) }) }), canCreateNewThread && (0, import_jsx_runtime2.jsx)(ThreadCard, { onClick: handleNewThreadClick, tone: isSelected ? "primary" : void 0, children: (0, import_jsx_runtime2.jsx)(CreateNewThreadInput, { currentUser, fieldName: lastCrumb, mentionOptions, onNewThreadCreate: handleNewThreadCreate, readOnly }) }), (0, import_jsx_runtime2.jsx)(Stack, { space: 2, children })] });
}
var EMPTY_STATE_MESSAGES = { open: { title: "No open comments yet", message: (0, import_jsx_runtime2.jsxs)("span", { children: ["Open comments on this document ", (0, import_jsx_runtime2.jsx)("br", {}), "will be shown here."] }) }, resolved: { title: "No resolved comments yet", message: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: ["Resolved comments on this document ", (0, import_jsx_runtime2.jsx)("br", {}), "will be shown here."] }) } };
function CommentsListStatus(props) {
  const { status, error, loading, hasNoComments } = props;
  if (error) {
    return (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "center", flex: 1, padding: 4, children: (0, import_jsx_runtime2.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: "Something went wrong" }) }) });
  }
  if (loading) {
    return (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true, title: "Loading comments" });
  }
  if (hasNoComments) {
    return (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "center", flex: 1, sizing: "border", children: (0, import_jsx_runtime2.jsx)(Container, { width: 0, padding: 4, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { align: "center", size: 1, muted: true, weight: "medium", children: EMPTY_STATE_MESSAGES[status].title }), (0, import_jsx_runtime2.jsx)(Text, { align: "center", size: 1, muted: true, children: EMPTY_STATE_MESSAGES[status].message })] }) }) });
  }
  return null;
}
var SCROLL_INTO_VIEW_OPTIONS$1 = { behavior: "smooth", block: "start", inline: "nearest" };
function groupThreads(comments2) {
  return comments2.reduce((acc, comment) => {
    const field = comment.fieldPath;
    if (!acc[field]) {
      acc[field] = [];
    }
    acc[field].push(comment);
    return acc;
  }, {});
}
var CommentsListInner = (0, import_react2.forwardRef)(function CommentsListInner2(props, ref) {
  const { comments: comments2, currentUser, error, loading, mentionOptions, onCopyLink, onCreateRetry, onDelete, onEdit, onNewThreadCreate, onPathSelect, onReply, onStatusChange, readOnly, selectedPath, status } = props;
  const [boundaryElement, setBoundaryElement] = (0, import_react2.useState)(null);
  const scrollToComment = (0, import_react2.useCallback)((id) => {
    const commentElement = document == null ? void 0 : document.querySelector('[data-comment-id="'.concat(id, '"]'));
    if (commentElement) {
      commentElement.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS$1);
    }
  }, []);
  (0, import_react2.useImperativeHandle)(ref, () => {
    return { scrollToComment };
  }, [scrollToComment]);
  const groupedThreads = (0, import_react2.useMemo)(() => Object.entries(groupThreads(comments2)), [comments2]);
  const showComments = !loading && !error && groupedThreads.length > 0;
  return (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", flex: 1, height: "fill", overflow: "hidden", ref: setBoundaryElement, sizing: "border", children: [(0, import_jsx_runtime2.jsx)(CommentsListStatus, { error, hasNoComments: groupedThreads.length === 0, loading, status }), showComments && (0, import_jsx_runtime2.jsx)(Stack, { as: "ul", flex: 1, overflow: "auto", padding: 3, paddingTop: 1, paddingBottom: 6, sizing: "border", space: 1, children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: boundaryElement, children: groupedThreads == null ? void 0 : groupedThreads.map((_ref70) => {
    let [fieldPath, group] = _ref70;
    const breadcrumbs = group[0].breadcrumbs;
    const firstThreadId = group[0].threadId;
    const newThreadSelected = (selectedPath == null ? void 0 : selectedPath.fieldPath) === fieldPath && !selectedPath.threadId;
    return (0, import_jsx_runtime2.jsx)(Stack, { as: "li", "data-group-id": firstThreadId, paddingTop: 3, children: (0, import_jsx_runtime2.jsx)(CommentThreadLayout, { breadcrumbs, canCreateNewThread: status === "open", currentUser, fieldPath, isSelected: newThreadSelected, mentionOptions, onNewThreadCreate, onPathSelect, readOnly, children: group.map((item) => {
      var _a2, _b2;
      const replies = item.replies.slice().reverse();
      const canReply = status === "open" && ((_a2 = item.parentComment._state) == null ? void 0 : _a2.type) !== "createError" && ((_b2 = item.parentComment._state) == null ? void 0 : _b2.type) !== "createRetrying";
      const threadIsSelected = (selectedPath == null ? void 0 : selectedPath.threadId) === item.parentComment.threadId && (selectedPath == null ? void 0 : selectedPath.fieldPath) === item.parentComment.target.path.field;
      return (0, import_jsx_runtime2.jsx)(CommentsListItem, { canReply, currentUser, isSelected: threadIsSelected, mentionOptions, onCopyLink, onCreateRetry, onDelete, onEdit, onPathSelect, onReply, onStatusChange, parentComment: item.parentComment, readOnly, replies }, item.parentComment._id);
    }) }, fieldPath) }, fieldPath);
  }) }) })] });
});
var CommentsList = import_react2.default.memo(CommentsListInner);
var DIALOG_COPY = { thread: { title: "Delete this comment thread?", body: "This comment and its replies will be deleted, and once deleted cannot be recovered.", confirmButtonText: "Delete thread" }, comment: { title: "Delete this comment?", body: "Once deleted, a comment cannot be recovered.", confirmButtonText: "Delete comment" } };
function CommentDeleteDialog(props) {
  const { isParent, onClose, commentId, onConfirm, loading, error } = props;
  const { title, body, confirmButtonText } = DIALOG_COPY[isParent ? "thread" : "comment"];
  const handleDelete = (0, import_react2.useCallback)(() => {
    onConfirm(commentId);
  }, [commentId, onConfirm]);
  return (0, import_jsx_runtime2.jsx)(Dialog2, { footer: { cancelButton: { onClick: onClose }, confirmButton: { loading, onClick: handleDelete, text: confirmButtonText, tone: "critical" } }, header: title, id: "delete-comment-dialog", onClose, width: 0, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, children: body }), error && (0, import_jsx_runtime2.jsx)(TextWithTone, { tone: "critical", children: "An error occurred while deleting the comment. Please try again." })] }) });
}
var __freeze$i = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$i = (cooked, raw) => __freeze$i(__defProp$i(cooked, "raw", { value: __freeze$i(raw || cooked.slice()) }));
var _a$i;
var _b$8;
var _c$3;
var Root$7 = ut(Box)(_a$i || (_a$i = __template$i(["\n  max-width: 280px;\n"])));
var fadeInKeyFrame = ht(_b$8 || (_b$8 = __template$i(["\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n"])));
var StyledPopover = ut(Popover2)(_c$3 || (_c$3 = __template$i(["\n  opacity: 0;\n  // Fade in the popover after 500ms\n  animation: ", " 200ms 500ms forwards;\n"])), fadeInKeyFrame);
function CommentsOnboardingPopover(props) {
  const { onDismiss } = props;
  return (0, import_jsx_runtime2.jsx)(StyledPopover, { content: (0, import_jsx_runtime2.jsx)(Root$7, { padding: 4, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { weight: "medium", size: 1, children: "Document fields now have comments" }), (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: "You can add comments to any field in a document. They'll show up here, grouped by field." }), (0, import_jsx_runtime2.jsx)(Flex, { justify: "flex-end", marginTop: 2, children: (0, import_jsx_runtime2.jsx)(Button2, { text: "Got it", tone: "primary", onClick: onDismiss }) })] }) }), open: true, portal: true, ...props });
}
var CommentsContext = (0, import_react2.createContext)(null);
function getParams(user) {
  const params = {};
  if (user !== null) {
    params.identity = user.id;
  }
  return params;
}
var PARSED_FILTERS_MEMO = /* @__PURE__ */ new Map();
async function matchesFilter(user, filter, document2) {
  if (!PARSED_FILTERS_MEMO.has(filter)) {
    PARSED_FILTERS_MEMO.set(filter, parse("*[".concat(filter, "]")));
  }
  const parsed = PARSED_FILTERS_MEMO.get(filter);
  const evalParams = getParams(user);
  const { identity } = evalParams;
  const params = { ...evalParams };
  const data = await (await evaluateQuery(parsed, { dataset: [document2], identity, params })).get();
  return (data == null ? void 0 : data.length) === 1;
}
async function grantsPermissionOn(user, grants, permission, document2) {
  if (!document2) {
    return { granted: true, reason: "Null document, nothing to check" };
  }
  if (!grants.length) {
    return { granted: false, reason: "No document grants" };
  }
  const matchingGrants = [];
  for (const grant of grants) {
    if (await matchesFilter(user, grant.filter, document2)) {
      matchingGrants.push(grant);
    }
  }
  const foundMatch = matchingGrants.some((grant) => grant.permissions.some((p) => p === permission));
  return { granted: foundMatch, reason: foundMatch ? "Matching grant" : "No matching grants found" };
}
var INITIAL_STATE$2 = { data: [], error: null, loading: true };
var cachedSystemGroups = null;
function useMentionOptions(opts) {
  const { documentValue } = opts;
  const projectStore = useProjectStore();
  const userStore = useUserStore();
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [state2, setState] = (0, import_react2.useState)(INITIAL_STATE$2);
  const list$ = (0, import_react2.useMemo)(() => {
    const members$ = projectStore.get().pipe(map((res) => {
      var _a2;
      return (_a2 = res.members) == null ? void 0 : _a2.filter((m) => !m.isRobot);
    }));
    const users$ = members$.pipe(switchMap(async (members) => {
      const ids = members.map((_ref71) => {
        let { id } = _ref71;
        return id;
      });
      const users = await userStore.getUsers(ids);
      return users;
    }), map((res) => res.map((user) => ({ displayName: user.displayName, id: user.id, canBeMentioned: false }))));
    const cached = cachedSystemGroups;
    const systemGroup$ = cached ? of(cached) : client.observable.fetch('*[_type == "system.group"]');
    const grants$ = forkJoin([users$, systemGroup$]).pipe(mergeMap(async (_ref72) => {
      let [users, groups] = _ref72;
      if (!cached) {
        cachedSystemGroups = groups;
      }
      const grantPromises = users == null ? void 0 : users.map(async (user) => {
        const grants = groups.map((group) => {
          if (group.members.includes(user.id)) {
            return group.grants;
          }
          return [];
        });
        const flattenedGrants = [...grants].flat();
        const { granted } = await grantsPermissionOn(user, flattenedGrants, "read", documentValue);
        return { ...user, canBeMentioned: granted };
      });
      const usersWithPermission = await Promise.all(grantPromises || []);
      return usersWithPermission;
    }));
    const $alphabetical = grants$.pipe(map((res) => ({ error: null, loading: false, data: (0, import_sortBy2.default)(res, "displayName") })));
    return $alphabetical;
  }, [client.observable, documentValue, projectStore, userStore]);
  (0, import_react2.useEffect)(() => {
    const initial$ = of(INITIAL_STATE$2);
    const state$ = concat(initial$, list$);
    const sub = state$.subscribe(setState);
    return () => {
      sub.unsubscribe();
    };
  }, [list$]);
  return state2;
}
function useNotificationTarget(opts) {
  const { documentId, documentType } = opts || {};
  const schemaType = useSchema().get(documentType);
  const { title: workspaceTitle } = useWorkspace();
  const { createPathWithParams, params } = usePaneRouter();
  const documentPreviewStore = useDocumentPreviewStore();
  const previewState = useMemoObservable(() => {
    if (!documentId || !schemaType)
      return of(null);
    return getPreviewStateObservable(documentPreviewStore, schemaType, documentId, "");
  }, [documentId, documentPreviewStore, schemaType]);
  const { published, draft } = previewState || {};
  const documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title) || "Sanity document";
  const handleGetNotificationValue = (0, import_react2.useCallback)((_ref73) => {
    let { commentId } = _ref73;
    const path = createPathWithParams({ ...params, comment: commentId, inspect: COMMENTS_INSPECTOR_NAME });
    const url = "".concat(window.location.origin).concat(path);
    return { documentTitle, url, workspaceTitle };
  }, [createPathWithParams, documentTitle, params, workspaceTitle]);
  return { getNotificationValue: handleGetNotificationValue };
}
function useCommentOperations(opts) {
  const { client, currentUser, dataset, documentId, documentType, getThreadLength, onCreate, onCreateError, onEdit, onRemove, onUpdate, projectId, runSetup, workspace } = opts;
  const authorId = currentUser == null ? void 0 : currentUser.id;
  const activeToolName = useRouterState((0, import_react2.useCallback)((routerState) => typeof routerState.tool === "string" ? routerState.tool : void 0, []));
  const { tools } = useWorkspace();
  const activeTool = (0, import_react2.useMemo)(() => tools.find((tool) => tool.name === activeToolName), [activeToolName, tools]);
  const { getNotificationValue } = useNotificationTarget({ documentId, documentType });
  const handleCreate = (0, import_react2.useCallback)(async (comment) => {
    const commentId = (comment == null ? void 0 : comment.id) || v4_default();
    const currentThreadLength = ((getThreadLength == null ? void 0 : getThreadLength(comment.threadId)) || 0) + 1;
    const { documentTitle = "", url = "", workspaceTitle = "" } = getNotificationValue({ commentId }) || {};
    const notification = { currentThreadLength, documentTitle, url, workspaceTitle };
    const nextComment = {
      _id: commentId,
      _type: "comment",
      authorId: authorId || "",
      // improve
      lastEditedAt: void 0,
      message: comment.message,
      parentCommentId: comment.parentCommentId,
      status: comment.status,
      threadId: comment.threadId,
      context: { payload: { workspace }, notification, tool: (activeTool == null ? void 0 : activeTool.name) || "" },
      target: { path: { field: comment.fieldPath }, document: { _dataset: dataset, _projectId: projectId, _ref: documentId, _type: "crossDatasetReference", _weak: true }, documentType }
    };
    onCreate == null ? void 0 : onCreate(nextComment);
    if (!client) {
      try {
        await runSetup(nextComment);
      } catch (err2) {
        onCreateError == null ? void 0 : onCreateError(nextComment._id, err2);
        throw err2;
      }
      return;
    }
    try {
      await client.create(nextComment);
    } catch (err2) {
      onCreateError == null ? void 0 : onCreateError(nextComment._id, err2);
      throw err2;
    }
  }, [activeTool == null ? void 0 : activeTool.name, authorId, client, dataset, documentId, documentType, getNotificationValue, getThreadLength, onCreate, onCreateError, projectId, runSetup, workspace]);
  const handleRemove = (0, import_react2.useCallback)(async (id) => {
    if (!client)
      return;
    onRemove == null ? void 0 : onRemove(id);
    await Promise.all([client.delete({ query: '*[_type == "comment" && parentCommentId == "'.concat(id, '"]') }), client.delete(id)]);
  }, [client, onRemove]);
  const handleEdit = (0, import_react2.useCallback)(async (id, comment) => {
    if (!client)
      return;
    const editedComment = { message: comment.message, lastEditedAt: (/* @__PURE__ */ new Date()).toISOString() };
    onEdit == null ? void 0 : onEdit(id, editedComment);
    await client.patch(id).set(editedComment).commit();
  }, [client, onEdit]);
  const handleUpdate = (0, import_react2.useCallback)(async (id, comment) => {
    if (!client)
      return;
    onUpdate == null ? void 0 : onUpdate(id, comment);
    if (comment.status) {
      await Promise.all([client.patch({ query: '*[_type == "comment" && parentCommentId == "'.concat(id, '"]') }).set({ status: comment.status }).commit(), client.patch(id).set(comment).commit()]);
      return;
    }
    await (client == null ? void 0 : client.patch(id).set(comment).commit());
  }, [client, onUpdate]);
  const operation = (0, import_react2.useMemo)(() => ({ create: handleCreate, edit: handleEdit, remove: handleRemove, update: handleUpdate }), [handleCreate, handleRemove, handleEdit, handleUpdate]);
  return { operation };
}
function useComments() {
  const value = (0, import_react2.useContext)(CommentsContext);
  if (!value) {
    throw new Error("useComments must be used within a CommentsProvider");
  }
  return value;
}
function useCommentsSetup() {
  const ctx = (0, import_react2.useContext)(CommentsSetupContext);
  if (!ctx) {
    throw new Error("useCommentsSetup: missing context value");
  }
  return ctx;
}
var CommentsEnabledContext = (0, import_react2.createContext)(null);
var CommentsEnabledProvider = import_react2.default.memo(function CommentsEnabledProvider2(props) {
  const { children, documentId, documentType } = props;
  const isEnabled = useResolveCommentsEnabled(documentId, documentType);
  return (0, import_jsx_runtime2.jsx)(CommentsEnabledContext.Provider, { value: isEnabled, children });
});
function useCommentsEnabled() {
  const ctx = (0, import_react2.useContext)(CommentsEnabledContext);
  if (ctx === null) {
    throw new Error("useCommentsEnabled: missing context value");
  }
  return ctx;
}
var CommentsOnboardingContext = (0, import_react2.createContext)(null);
var VERSION = 1;
var LOCAL_STORAGE_KEY = "sanityStudio:comments:inspector:onboarding:dismissed:v".concat(VERSION);
var setLocalStorage = (value) => {
  try {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(value));
  } catch (_) {
  }
};
var getLocalStorage = () => {
  try {
    const value = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    return value ? JSON.parse(value) : false;
  } catch (_) {
    return false;
  }
};
function CommentsOnboardingProvider(props) {
  const { children } = props;
  const [dismissed, setDismissed] = (0, import_react2.useState)(getLocalStorage());
  const handleDismiss = (0, import_react2.useCallback)(() => {
    setDismissed(true);
    setLocalStorage(true);
  }, [setDismissed]);
  const ctxValue = (0, import_react2.useMemo)(() => ({ setDismissed: handleDismiss, isDismissed: dismissed }), [handleDismiss, dismissed]);
  return (0, import_jsx_runtime2.jsx)(CommentsOnboardingContext.Provider, { value: ctxValue, children });
}
function useCommentsOnboarding() {
  const ctx = (0, import_react2.useContext)(CommentsOnboardingContext);
  if (!ctx) {
    throw new Error("useCommentsOnboarding: missing context value");
  }
  return ctx;
}
function useCommentsSelectedPath() {
  const ctx = (0, import_react2.useContext)(CommentsSelectedPathContext);
  if (!ctx) {
    throw new Error("useCommentsSelectedPath: missing context value");
  }
  return ctx;
}
function useResolveCommentsEnabled(documentId, documentType) {
  const { enabled: featureEnabled, isLoading } = useFeatureEnabled("studioComments");
  const { enabled } = useSource().document.unstable_comments;
  const enabledFromConfig = (0, import_react2.useMemo)(() => enabled({ documentType, documentId: getPublishedId(documentId) }), [documentId, documentType, enabled]);
  const isEnabled = !isLoading && featureEnabled && enabledFromConfig;
  return isEnabled;
}
function createCommentsSet(comments2) {
  const commentsById = comments2.reduce((acc, comment) => ({ ...acc, [comment._id]: comment }), {});
  return commentsById;
}
function commentsReducer(state2, action) {
  switch (action.type) {
    case "COMMENTS_SET": {
      const commentsById = createCommentsSet(action.comments);
      return { ...state2, comments: commentsById };
    }
    case "COMMENT_ADDED": {
      const nextCommentResult = action.payload;
      const nextCommentValue = nextCommentResult;
      const nextComment = { [nextCommentResult._id]: {
        ...state2.comments[nextCommentResult._id],
        ...nextCommentValue,
        _state: nextCommentResult._state || void 0,
        // If the comment is created optimistically, it won't have a createdAt date.
        // In that case, we'll use the current date.
        // The correct date will be set when the comment is created on the server
        // and the comment is received in the realtime listener.
        _createdAt: nextCommentResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
      } };
      const commentExists = state2.comments && state2.comments[nextCommentResult._id];
      if (commentExists) {
        return { ...state2, comments: { ...state2.comments, ...nextComment } };
      }
      const nextComments = { ...state2.comments || {}, ...nextComment };
      return { ...state2, comments: nextComments };
    }
    case "COMMENT_RECEIVED": {
      const nextCommentResult = action.payload;
      return { ...state2, comments: { ...state2.comments, [nextCommentResult._id]: nextCommentResult } };
    }
    case "COMMENT_DELETED": {
      const { [action.id]: _, ...restComments } = state2.comments;
      Object.keys(restComments).forEach((commentId) => {
        if (restComments[commentId].parentCommentId === action.id) {
          delete restComments[commentId];
        }
      });
      return { ...state2, comments: restComments };
    }
    case "COMMENT_UPDATED": {
      const updatedComment = action.payload;
      const id = updatedComment._id;
      return { ...state2, comments: { ...state2.comments, [id]: { ...state2.comments[id], ...updatedComment } } };
    }
    default:
      return state2;
  }
}
var INITIAL_STATE$1 = { comments: {} };
var LISTEN_OPTIONS = { events: ["welcome", "mutation", "reconnect"], includeResult: true, visibility: "query" };
var SORT_FIELD = "_createdAt";
var SORT_ORDER = "desc";
var QUERY_FILTERS = ['_type == "comment"', "target.document._ref == $documentId"];
var QUERY_PROJECTION = "{\n  _createdAt,\n  _id,\n  authorId,\n  lastEditedAt,\n  message,\n  parentCommentId,\n  status,\n  target,\n  threadId,\n}";
var QUERY_SORT_ORDER = "order(".concat(SORT_FIELD, " ").concat(SORT_ORDER, ")");
var QUERY = "*[".concat(QUERY_FILTERS.join(" && "), "] ").concat(QUERY_PROJECTION, " | ").concat(QUERY_SORT_ORDER);
function useCommentsStore(opts) {
  const { client, documentId } = opts;
  const [state2, dispatch] = (0, import_react2.useReducer)(commentsReducer, INITIAL_STATE$1);
  const [loading, setLoading] = (0, import_react2.useState)(client !== null);
  const [error, setError] = (0, import_react2.useState)(null);
  const params = (0, import_react2.useMemo)(() => ({ documentId: getPublishedId(documentId) }), [documentId]);
  const initialFetch = (0, import_react2.useCallback)(async () => {
    if (!client) {
      setLoading(false);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({ type: "COMMENTS_SET", comments: res });
      setLoading(false);
    } catch (err2) {
      setError(err2);
    }
  }, [client, params]);
  const handleListenerEvent = (0, import_react2.useCallback)(async (event) => {
    if (event.type === "welcome") {
      setLoading(true);
      await initialFetch();
      setLoading(false);
    }
    if (event.type === "reconnect") {
      setLoading(true);
    }
    if (event.type === "mutation") {
      if (event.transition === "appear") {
        const nextComment = event.result;
        if (nextComment) {
          dispatch({ type: "COMMENT_RECEIVED", payload: nextComment });
        }
      }
      if (event.transition === "disappear") {
        dispatch({ type: "COMMENT_DELETED", id: event.documentId });
      }
      if (event.transition === "update") {
        const updatedComment = event.result;
        if (updatedComment) {
          dispatch({ type: "COMMENT_UPDATED", payload: updatedComment });
        }
      }
    }
  }, [initialFetch]);
  const listener$ = (0, import_react2.useMemo)(() => {
    if (!client)
      return of();
    const events$ = client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(catchError((err2) => {
      setError(err2);
      return of(err2);
    }));
    return events$;
  }, [client, params]);
  (0, import_react2.useEffect)(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null ? void 0 : sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]);
  const commentsAsArray = (0, import_react2.useMemo)(() => Object.values(state2.comments), [state2.comments]);
  return { data: commentsAsArray, dispatch, error, loading };
}
function getSchemaField(schemaType, fieldPath) {
  var _a2;
  const paths = fromString(fieldPath);
  const firstPath = paths[0];
  if (firstPath && isObjectSchemaType(schemaType)) {
    const field = (_a2 = schemaType == null ? void 0 : schemaType.fields) == null ? void 0 : _a2.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = toString(paths.slice(1));
      if (nextPath) {
        return getSchemaField(field.type, nextPath);
      }
      return field;
    }
  }
  return void 0;
}
function findArrayItemIndex(array, pathSegment) {
  if (typeof pathSegment === "number") {
    return pathSegment;
  }
  const index = (0, import_findIndex.default)(array, pathSegment);
  return index === -1 ? false : index;
}
function buildCommentBreadcrumbs(props) {
  const { currentUser, schemaType, fieldPath, documentValue } = props;
  const paths = fromString(fieldPath);
  const fieldPaths = [];
  let currentSchemaType = null;
  paths.forEach((seg, index) => {
    var _a2, _b2, _c2, _d2, _e2;
    const currentPath = paths.slice(0, index + 1);
    const previousPath = paths.slice(0, index);
    const field = getSchemaField(schemaType, toString(currentPath));
    const isKeySegment2 = seg.hasOwnProperty("_key");
    const parentValue = getValueAtPath(documentValue, previousPath);
    const currentValue = getValueAtPath(documentValue, currentPath);
    const conditionalContext = { document: documentValue, currentUser, parent: parentValue, value: currentValue };
    if (isKeySegment2 && Array.isArray(parentValue)) {
      const arrayItemIndex = findArrayItemIndex(parentValue, seg);
      const isNumber2 = typeof arrayItemIndex === "number";
      fieldPaths.push({ invalid: arrayItemIndex === false, isArrayItem: true, title: isNumber2 ? "#".concat(Number(arrayItemIndex) + 1) : "Unknown array item" });
      return;
    }
    if (field == null ? void 0 : field.type) {
      const hidden = resolveConditionalProperty(field.type.hidden, conditionalContext);
      fieldPaths.push({ invalid: hidden, isArrayItem: false, title: getSchemaTypeTitle(field.type) });
      currentSchemaType = field.type;
      return;
    }
    if (isArraySchemaType(currentSchemaType)) {
      const arrayValue = getValueAtPath(documentValue, previousPath);
      const objectType = arrayValue == null ? void 0 : arrayValue._type;
      const objectField = (_a2 = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _a2.find((type) => type.name === objectType);
      const currentField = (_b2 = objectField == null ? void 0 : objectField.fields) == null ? void 0 : _b2.find((f) => f.name === seg);
      if (!objectType && currentValue) {
        const allCurrentFields = (_c2 = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _c2.map((o) => o == null ? void 0 : o.fields).filter(Boolean).flat();
        const anonymousField = allCurrentFields == null ? void 0 : allCurrentFields.find((f) => (f == null ? void 0 : f.name) === seg);
        const hidden = resolveConditionalProperty((_d2 = anonymousField == null ? void 0 : anonymousField.type) == null ? void 0 : _d2.hidden, conditionalContext);
        if (anonymousField) {
          fieldPaths.push({ invalid: hidden, isArrayItem: false, title: getSchemaTypeTitle(anonymousField == null ? void 0 : anonymousField.type) });
          currentSchemaType = anonymousField == null ? void 0 : anonymousField.type;
        }
        return;
      }
      if (!currentField) {
        fieldPaths.push({ invalid: true, isArrayItem: false, title: "Unknown field" });
        return;
      }
      const currentTitle = getSchemaTypeTitle(currentField == null ? void 0 : currentField.type);
      const objectFieldHidden = resolveConditionalProperty((_e2 = objectField == null ? void 0 : objectField.type) == null ? void 0 : _e2.hidden, conditionalContext);
      const currentFieldHidden = resolveConditionalProperty(currentField == null ? void 0 : currentField.type.hidden, conditionalContext);
      const isHidden = objectFieldHidden || currentFieldHidden;
      fieldPaths.push({ invalid: isHidden, isArrayItem: false, title: currentTitle });
      currentSchemaType = currentField == null ? void 0 : currentField.type;
      return;
    }
    fieldPaths.push({ invalid: true, isArrayItem: false, title: "Unknown field" });
  });
  return fieldPaths;
}
function buildCommentThreadItems(props) {
  const { comments: comments2, currentUser, documentValue, schemaType } = props;
  const parentComments = comments2 == null ? void 0 : comments2.filter((c) => !c.parentCommentId);
  const items = parentComments.map((parentComment) => {
    const crumbs = buildCommentBreadcrumbs({ currentUser, documentValue, fieldPath: parentComment.target.path.field, schemaType });
    const hasInvalidBreadcrumb = crumbs.some((bc) => bc.invalid);
    if (hasInvalidBreadcrumb)
      return void 0;
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id);
    const commentsCount = [parentComment, ...replies].length;
    return { breadcrumbs: crumbs, commentsCount, fieldPath: parentComment.target.path.field, parentComment, replies, threadId: parentComment.threadId };
  }).filter(Boolean);
  return items;
}
var EMPTY_ARRAY$3 = [];
var EMPTY_COMMENTS_DATA = { open: EMPTY_ARRAY$3, resolved: EMPTY_ARRAY$3 };
var CommentsProvider = (0, import_react2.memo)(function CommentsProvider2(props) {
  const { children, documentId, documentType, isCommentsOpen, onCommentsOpen } = props;
  const [status, setStatus] = (0, import_react2.useState)("open");
  const { client, runSetup, isRunningSetup } = useCommentsSetup();
  const publishedId = getPublishedId(documentId);
  const editState = useEditState(publishedId, documentType, "low");
  const documentValue = (0, import_react2.useMemo)(() => {
    return editState.draft || editState.published;
  }, [editState.draft, editState.published]);
  const { dispatch, data = EMPTY_ARRAY$3, error, loading } = useCommentsStore({ documentId: publishedId, client });
  const mentionOptions = useMentionOptions((0, import_react2.useMemo)(() => ({ documentValue }), [documentValue]));
  const schemaType = useSchema().get(documentType);
  const currentUser = useCurrentUser();
  const { name: workspaceName, dataset, projectId } = useWorkspace();
  const threadItemsByStatus = (0, import_react2.useMemo)(() => {
    if (!schemaType || !currentUser)
      return EMPTY_COMMENTS_DATA;
    const sorted = (0, import_orderBy2.default)(data, ["_createdAt"], ["desc"]);
    const items = buildCommentThreadItems({ comments: sorted, schemaType, currentUser, documentValue });
    return { open: items.filter((item) => item.parentComment.status === "open"), resolved: items.filter((item) => item.parentComment.status === "resolved") };
  }, [currentUser, data, documentValue, schemaType]);
  const getThreadLength = (0, import_react2.useCallback)((threadId) => {
    return threadItemsByStatus.open.filter((item) => item.threadId === threadId).length;
  }, [threadItemsByStatus.open]);
  const getComment = (0, import_react2.useCallback)((id) => data == null ? void 0 : data.find((c) => c._id === id), [data]);
  const handleOnCreate = (0, import_react2.useCallback)(async (payload) => {
    var _a2, _b2;
    const hasError = ((_b2 = (_a2 = data == null ? void 0 : data.find((c) => c._id === payload._id)) == null ? void 0 : _a2._state) == null ? void 0 : _b2.type) === "createError";
    dispatch({ type: "COMMENT_ADDED", payload: { ...payload, _state: hasError ? { type: "createRetrying" } : void 0 } });
  }, [data, dispatch]);
  const handleOnUpdate = (0, import_react2.useCallback)((id, payload) => {
    dispatch({ type: "COMMENT_UPDATED", payload: { _id: id, ...payload } });
  }, [dispatch]);
  const handleOnEdit = (0, import_react2.useCallback)((id, payload) => {
    dispatch({ type: "COMMENT_UPDATED", payload: { _id: id, ...payload } });
  }, [dispatch]);
  const handleOnCreateError = (0, import_react2.useCallback)((id, err2) => {
    dispatch({ type: "COMMENT_UPDATED", payload: { _id: id, _state: { error: err2, type: "createError" } } });
  }, [dispatch]);
  const { operation } = useCommentOperations((0, import_react2.useMemo)(() => ({
    client,
    currentUser,
    dataset,
    documentId: publishedId,
    documentType,
    projectId,
    schemaType,
    workspace: workspaceName,
    getThreadLength,
    // This function runs when the first comment creation is executed.
    // It is used to create the addon dataset and configure a client for
    // the addon dataset.
    runSetup,
    // The following callbacks runs when the comment operations are executed.
    // They are used to update the local state of the comments immediately after
    // a comment operation has been executed. This is done to avoid waiting for
    // the real time listener to update the comments and make the UI feel more
    // responsive. The comment will be updated again when we receive an mutation
    // event from the real time listener.
    onCreate: handleOnCreate,
    onCreateError: handleOnCreateError,
    onEdit: handleOnEdit,
    onUpdate: handleOnUpdate
  }), [client, currentUser, dataset, publishedId, documentType, projectId, schemaType, workspaceName, getThreadLength, runSetup, handleOnCreate, handleOnCreateError, handleOnEdit, handleOnUpdate]));
  const ctxValue = (0, import_react2.useMemo)(() => ({ isRunningSetup, status, setStatus, getComment, isCommentsOpen, onCommentsOpen, comments: { data: threadItemsByStatus, error, loading: loading || isRunningSetup }, create: { execute: operation.create }, remove: { execute: operation.remove }, edit: { execute: operation.edit }, update: { execute: operation.update }, mentionOptions }), [error, getComment, isCommentsOpen, isRunningSetup, loading, mentionOptions, onCommentsOpen, operation.create, operation.edit, operation.remove, operation.update, status, threadItemsByStatus]);
  return (0, import_jsx_runtime2.jsx)(CommentsContext.Provider, { value: ctxValue, children });
});
var CommentsSetupContext = (0, import_react2.createContext)(null);
var API_VERSION = "v2023-11-13";
function CommentsSetupProvider(props) {
  const { children } = props;
  const { dataset, projectId } = useWorkspace();
  const originalClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [addonDatasetClient, setAddonDatasetClient] = (0, import_react2.useState)(null);
  const [isRunningSetup, setIsRunningSetup] = (0, import_react2.useState)(false);
  const getAddonDatasetName = (0, import_react2.useCallback)(async () => {
    var _a2;
    const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({ uri: "/projects/".concat(projectId, "/datasets?datasetProfile=comments&addonFor=").concat(dataset), tag: "sanity.studio" });
    return (_a2 = res == null ? void 0 : res[0]) == null ? void 0 : _a2.name;
  }, [dataset, originalClient, projectId]);
  const handleCreateClient = (0, import_react2.useCallback)((addonDatasetName) => {
    const client = originalClient.withConfig({ apiVersion: API_VERSION, dataset: addonDatasetName, projectId, requestTagPrefix: "sanity.studio", useCdn: false, withCredentials: true });
    return client;
  }, [originalClient, projectId]);
  const handleRunSetup = (0, import_react2.useCallback)(async (comment) => {
    setIsRunningSetup(true);
    try {
      const addonDatasetName = await getAddonDatasetName();
      if (addonDatasetName) {
        const client = handleCreateClient(addonDatasetName);
        setAddonDatasetClient(client);
        await client.create(comment);
        setIsRunningSetup(false);
        return;
      }
    } catch (_) {
    }
    try {
      const res = await originalClient.withConfig({ apiVersion: API_VERSION }).request({ uri: "/comments/".concat(dataset, "/setup"), method: "POST" });
      const datasetName = res == null ? void 0 : res.datasetName;
      if (!datasetName) {
        setIsRunningSetup(false);
        return;
      }
      const client = handleCreateClient(datasetName);
      setAddonDatasetClient(client);
      await client.create(comment);
    } catch (err2) {
      throw err2;
    } finally {
      setIsRunningSetup(false);
    }
  }, [dataset, getAddonDatasetName, handleCreateClient, originalClient]);
  (0, import_react2.useEffect)(() => {
    getAddonDatasetName().then((addonDatasetName) => {
      if (!addonDatasetName)
        return;
      const client = handleCreateClient(addonDatasetName);
      setAddonDatasetClient(client);
    });
  }, [getAddonDatasetName, handleCreateClient]);
  const ctxValue = (0, import_react2.useMemo)(() => ({ client: addonDatasetClient, runSetup: handleRunSetup, isRunningSetup }), [addonDatasetClient, handleRunSetup, isRunningSetup]);
  return (0, import_jsx_runtime2.jsx)(CommentsSetupContext.Provider, { value: ctxValue, children });
}
var CommentsSelectedPathContext = (0, import_react2.createContext)(null);
var CommentsSelectedPathProvider = import_react2.default.memo(function CommentsSelectedPathProvider2(props) {
  const { children } = props;
  const [selectedPath, setSelectedPath] = (0, import_react2.useState)(null);
  const handleSelectPath = (0, import_react2.useCallback)((nextPath) => {
    setSelectedPath(nextPath);
  }, []);
  const ctxValue = (0, import_react2.useMemo)(() => ({ selectedPath, setSelectedPath: handleSelectPath }), [selectedPath, handleSelectPath]);
  return (0, import_jsx_runtime2.jsx)(CommentsSelectedPathContext.Provider, { value: ctxValue, children });
});
var Root$6 = ut(Card)({ position: "relative", zIndex: 1, lineHeight: 0 });
var CommentsInspectorHeader = (0, import_react2.forwardRef)(function CommentsInspectorHeader2(props, ref) {
  const { onClose, onViewChange, view } = props;
  const handleSetOpenView = (0, import_react2.useCallback)(() => onViewChange("open"), [onViewChange]);
  const handleSetResolvedView = (0, import_react2.useCallback)(() => onViewChange("resolved"), [onViewChange]);
  return (0, import_jsx_runtime2.jsx)(Root$6, { ref, children: (0, import_jsx_runtime2.jsxs)(Flex, { padding: 2, children: [(0, import_jsx_runtime2.jsxs)(Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, padding: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { as: "h1", size: 1, weight: "medium", children: "Comments" }), (0, import_jsx_runtime2.jsx)(BetaBadge, {})] }), (0, import_jsx_runtime2.jsxs)(Flex, { flex: "none", padding: 1, gap: 2, children: [(0, import_jsx_runtime2.jsx)(MenuButton2, { id: "comment-status-menu-button", button: (0, import_jsx_runtime2.jsx)(Button2, { text: (0, import_startCase2.default)(view), mode: "bleed", iconRight: ChevronDownIcon }), menu: (0, import_jsx_runtime2.jsxs)(Menu, { style: { width: "180px" }, children: [(0, import_jsx_runtime2.jsx)(MenuItem2, { iconRight: view === "open" ? CheckmarkIcon : void 0, onClick: handleSetOpenView, text: "Open comments" }), (0, import_jsx_runtime2.jsx)(MenuItem2, { iconRight: view === "resolved" ? CheckmarkIcon : void 0, onClick: handleSetResolvedView, text: "Resolved comments" })] }), popover: { placement: "bottom-end" } }), (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": "Close comments", icon: DoubleChevronRightIcon, mode: "bleed", onClick: onClose, tooltipProps: { content: "Close comments" } })] })] }) });
});
var __freeze$h = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$h = (cooked, raw) => __freeze$h(__defProp$h(cooked, "raw", { value: __freeze$h(raw || cooked.slice()) }));
var _a$h;
var _b$7;
var FEEDBACK_FORM_LINK = "https://snty.link/comments-beta-feedback";
var Span = ut.span(_a$h || (_a$h = __template$h(["\n  margin-right: 0.2em;\n"])));
var Link = ut.a(_b$7 || (_b$7 = __template$h(["\n  white-space: nowrap;\n"])));
var FooterCard = ut(Card)({ position: "relative", zIndex: 1 });
function CommentsInspectorFeedbackFooter() {
  return (0, import_jsx_runtime2.jsx)(FooterCard, { padding: 4, children: (0, import_jsx_runtime2.jsxs)(Text, { muted: true, size: 1, children: ["Help improve comments.", " ", (0, import_jsx_runtime2.jsxs)(Link, { href: FEEDBACK_FORM_LINK, target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime2.jsx)(Span, { children: "Share your feedback " }), " ", (0, import_jsx_runtime2.jsx)(LaunchIcon, {})] })] }) });
}
var __freeze$g = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$g = (cooked, raw) => __freeze$g(__defProp$g(cooked, "raw", { value: __freeze$g(raw || cooked.slice()) }));
var _a$g;
var RootLayer = ut(Layer)(_a$g || (_a$g = __template$g(["\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  overflow: hidden;\n"])));
function CommentsInspector(props) {
  const isEnabled = useCommentsEnabled();
  if (!isEnabled)
    return null;
  return (0, import_jsx_runtime2.jsx)(RootLayer, { children: (0, import_jsx_runtime2.jsx)(CommentsInspectorInner, { ...props }) });
}
function CommentsInspectorInner(props) {
  const { onClose } = props;
  const [showDeleteDialog, setShowDeleteDialog] = (0, import_react2.useState)(false);
  const [commentToDelete, setCommentToDelete] = (0, import_react2.useState)(null);
  const [deleteLoading, setDeleteLoading] = (0, import_react2.useState)(false);
  const [deleteError, setDeleteError] = (0, import_react2.useState)(null);
  const commentsListHandleRef = (0, import_react2.useRef)(null);
  const rootRef = (0, import_react2.useRef)(null);
  const currentUser = useCurrentUser();
  const { params, createPathWithParams, setParams } = usePaneRouter();
  const uniqueParams = useUnique(params) || EMPTY_PARAMS$2;
  const commentIdParamRef = (0, import_react2.useRef)(uniqueParams == null ? void 0 : uniqueParams.comment);
  const didScrollToCommentFromParam = (0, import_react2.useRef)(false);
  const pushToast = useToast().push;
  const { onPathOpen, ready } = useDocumentPane();
  const { isDismissed, setDismissed } = useCommentsOnboarding();
  const { comments: comments2, create, edit, getComment, isRunningSetup, mentionOptions, remove, setStatus, status, update } = useComments();
  const { isTopLayer } = useLayer();
  const currentComments = (0, import_react2.useMemo)(() => comments2.data[status], [comments2, status]);
  const loading = (0, import_react2.useMemo)(() => {
    return comments2.loading || !ready;
  }, [comments2.loading, ready]);
  const { selectedPath, setSelectedPath } = useCommentsSelectedPath();
  const handleChangeView = (0, import_react2.useCallback)((nextView) => {
    setStatus(nextView);
    setSelectedPath(null);
  }, [setSelectedPath, setStatus]);
  const handleCloseInspector = (0, import_react2.useCallback)(() => {
    onClose();
    setSelectedPath(null);
  }, [onClose, setSelectedPath]);
  const handleCopyLink = (0, import_react2.useCallback)((id) => {
    const path = createPathWithParams({ ...params, comment: id });
    const url = "".concat(window.location.origin).concat(path);
    navigator.clipboard.writeText(url).then(() => {
      pushToast({ closable: true, status: "info", title: "Copied link to clipboard" });
    }).catch(() => {
      pushToast({ closable: true, status: "error", title: "Unable to copy link to clipboard" });
    });
  }, [createPathWithParams, params, pushToast]);
  const handleCreateRetry = (0, import_react2.useCallback)((id) => {
    const comment = getComment(id);
    if (!comment)
      return;
    create.execute({ fieldPath: comment.target.path.field, id: comment._id, message: comment.message, parentCommentId: comment.parentCommentId, status: comment.status, threadId: comment.threadId });
  }, [create, getComment]);
  const closeDeleteDialog = (0, import_react2.useCallback)(() => {
    if (deleteLoading)
      return;
    setShowDeleteDialog(false);
    setCommentToDelete(null);
  }, [deleteLoading]);
  const handlePathSelect = (0, import_react2.useCallback)((nextPath) => {
    setSelectedPath(nextPath);
    if (nextPath == null ? void 0 : nextPath.fieldPath) {
      const path = fromString(nextPath.fieldPath);
      onPathOpen(path);
    }
  }, [onPathOpen, setSelectedPath]);
  const handleNewThreadCreate = (0, import_react2.useCallback)((payload) => {
    create.execute(payload);
    setSelectedPath({ fieldPath: payload.fieldPath, origin: "inspector", threadId: payload.threadId });
  }, [create, setSelectedPath]);
  const handleReply = (0, import_react2.useCallback)((payload) => {
    create.execute(payload);
  }, [create]);
  const handleEdit = (0, import_react2.useCallback)((id, payload) => {
    edit.execute(id, payload);
  }, [edit]);
  const onDeleteStart = (0, import_react2.useCallback)((id) => {
    var _a2;
    const parent = currentComments.find((c) => {
      var _a3;
      return ((_a3 = c.parentComment) == null ? void 0 : _a3._id) === id;
    });
    const isParent = Boolean(parent && ((_a2 = parent == null ? void 0 : parent.replies) == null ? void 0 : _a2.length) > 0);
    setShowDeleteDialog(true);
    setCommentToDelete({ commentId: id, isParent });
  }, [currentComments]);
  const handleDeleteConfirm = (0, import_react2.useCallback)(async (id) => {
    try {
      setDeleteLoading(true);
      await remove.execute(id);
      closeDeleteDialog();
    } catch (err2) {
      setDeleteError(err2);
    } finally {
      setDeleteLoading(false);
    }
  }, [closeDeleteDialog, remove]);
  const handleScrollToComment = (0, import_react2.useCallback)((id, origin) => {
    const comment = getComment(id);
    if (comment) {
      setSelectedPath({ fieldPath: comment.target.path.field || null, origin: origin || "inspector", threadId: comment.threadId || null });
      setTimeout(() => {
        var _a2;
        (_a2 = commentsListHandleRef.current) == null ? void 0 : _a2.scrollToComment(id);
      });
    }
  }, [getComment, setSelectedPath]);
  const handleStatusChange = (0, import_react2.useCallback)((id, nextStatus) => {
    update.execute(id, { status: nextStatus });
    if (nextStatus === "open") {
      setStatus("open");
      handleScrollToComment(id);
    }
  }, [handleScrollToComment, setStatus, update]);
  const handleDeselectPath = (0, import_react2.useCallback)(() => {
    if (selectedPath && isTopLayer) {
      setSelectedPath(null);
    }
  }, [isTopLayer, selectedPath, setSelectedPath]);
  useClickOutside(handleDeselectPath, [rootRef.current]);
  (0, import_react2.useEffect)(() => {
    const commentToScrollTo = getComment(commentIdParamRef.current || "");
    if (!loading && commentToScrollTo && didScrollToCommentFromParam.current === false) {
      setStatus(commentToScrollTo.status || "open");
      handleScrollToComment(commentToScrollTo._id, "url");
      didScrollToCommentFromParam.current = true;
      commentIdParamRef.current = void 0;
      setParams({ ...params, comment: void 0 });
    }
  }, [getComment, handleScrollToComment, loading, params, setParams, setStatus]);
  return (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [commentToDelete && showDeleteDialog && (0, import_jsx_runtime2.jsx)(CommentDeleteDialog, { ...commentToDelete, error: deleteError, loading: deleteLoading, onClose: closeDeleteDialog, onConfirm: handleDeleteConfirm }), (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", flex: 1, height: "fill", onClick: handleDeselectPath, overflow: "hidden", ref: rootRef, children: [(0, import_jsx_runtime2.jsx)(CommentsOnboardingPopover, { onDismiss: setDismissed, open: !isDismissed, placement: "left-start", children: (0, import_jsx_runtime2.jsx)(CommentsInspectorHeader, { onClose: handleCloseInspector, onViewChange: handleChangeView, view: status }) }), currentUser && (0, import_jsx_runtime2.jsx)(CommentsList, { comments: currentComments, currentUser, error: comments2.error, loading, mentionOptions, onCopyLink: handleCopyLink, onCreateRetry: handleCreateRetry, onDelete: onDeleteStart, onEdit: handleEdit, onNewThreadCreate: handleNewThreadCreate, onPathSelect: handlePathSelect, onReply: handleReply, onStatusChange: handleStatusChange, readOnly: isRunningSetup, ref: commentsListHandleRef, selectedPath, status }), (0, import_jsx_runtime2.jsx)(CommentsInspectorFeedbackFooter, {})] })] });
}
function useMenuItem$1() {
  const isEnabled = useCommentsEnabled();
  return { hidden: !isEnabled, icon: CommentIcon, showAsAction: true, title: "Comments" };
}
var commentsInspector = defineDocumentInspector({ name: COMMENTS_INSPECTOR_NAME, component: CommentsInspector, useMenuItem: useMenuItem$1 });
var __freeze$f = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template$f = (cooked, raw) => __freeze$f(__defProp$f(cooked, "raw", { value: __freeze$f(raw || cooked.slice()) }));
var _a$f;
var ContentStack = ut(Stack)(_a$f || (_a$f = __template$f(["\n  width: 320px;\n"])));
function CommentsFieldButton(props) {
  const { count, currentUser, fieldTitle, isRunningSetup, mentionOptions, onChange, onClick, onCommentAdd, onDiscard, onInputKeyDown, open, setOpen, value } = props;
  const [popoverElement, setPopoverElement] = (0, import_react2.useState)(null);
  const [addCommentButtonElement, setAddCommentButtonElement] = (0, import_react2.useState)(null);
  const commentInputHandle = (0, import_react2.useRef)(null);
  const hasComments = Boolean(count > 0);
  const closePopover = (0, import_react2.useCallback)(() => {
    if (!open)
      return;
    setOpen(false);
    addCommentButtonElement == null ? void 0 : addCommentButtonElement.focus();
  }, [addCommentButtonElement, open, setOpen]);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    onCommentAdd();
    closePopover();
  }, [closePopover, onCommentAdd]);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    if (!hasValue) {
      closePopover();
      return;
    }
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.open();
  }, [closePopover, hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (onInputKeyDown)
      onInputKeyDown(event);
  }, [onInputKeyDown]);
  const handleDiscardCancel = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
  }, []);
  const handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
    closePopover();
    onDiscard();
  }, [closePopover, onDiscard]);
  const handlePopoverKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
  }, [startDiscard]);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (!open)
      return;
    startDiscard();
  }, [open, startDiscard]);
  useClickOutside(handleClickOutside, [popoverElement]);
  if (!hasComments) {
    const placeholder = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: ["Add comment to ", (0, import_jsx_runtime2.jsx)("b", { children: fieldTitle })] });
    const content = (0, import_jsx_runtime2.jsx)(ContentStack, { padding: 2, space: 4, children: (0, import_jsx_runtime2.jsx)(CommentInput, { currentUser, focusLock: true, focusOnMount: true, mentionOptions, onChange, onDiscardCancel: handleDiscardCancel, onDiscardConfirm: handleDiscardConfirm, onKeyDown: handleInputKeyDown, onSubmit: handleSubmit, placeholder, readOnly: isRunningSetup, ref: commentInputHandle, value }) });
    return (0, import_jsx_runtime2.jsx)(Popover2, { constrainSize: true, content, fallbackPlacements: ["bottom-end"], open, placement: "right-start", portal: true, ref: setPopoverElement, onKeyDown: handlePopoverKeyDown, children: (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": "Add comment", disabled: isRunningSetup, icon: AddCommentIcon, mode: "bleed", onClick, ref: setAddCommentButtonElement, selected: open, tooltipProps: { content: "Add comment", placement: "top" } }) }) });
  }
  return (0, import_jsx_runtime2.jsx)(Tooltip, { portal: true, placement: "top", content: "View comment".concat(count > 1 ? "s" : ""), children: (0, import_jsx_runtime2.jsx)(Button, { "aria-label": "Open comments", mode: "bleed", onClick, padding: 2, space: 2, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(CommentIcon2, {}) }), (0, import_jsx_runtime2.jsx)(Text, { size: 0, children: count > 9 ? "9+" : count })] }) }) });
}
var __freeze$e = Object.freeze;
var __defProp$e = Object.defineProperty;
var __template$e = (cooked, raw) => __freeze$e(__defProp$e(cooked, "raw", { value: __freeze$e(raw || cooked.slice()) }));
var _a$e;
var _b$6;
var HIGHLIGHT_BLOCK_VARIANTS = { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 } };
function CommentsField(props) {
  const isEnabled = useCommentsEnabled();
  if (isEnabled)
    return (0, import_jsx_runtime2.jsx)(CommentFieldInner, { ...props });
  return props.renderDefault(props);
}
var SCROLL_INTO_VIEW_OPTIONS = { behavior: "smooth", block: "start" };
var HighlightDiv = ut(motion.div)((_ref74) => {
  let { theme } = _ref74;
  const { radius, space, color } = theme.sanity;
  const bg = hues.blue[color.dark ? 900 : 50].hex;
  return at(_a$e || (_a$e = __template$e(["\n    mix-blend-mode: ", ";\n    border-radius: ", "px;\n    top: -", "px;\n    left: -", "px;\n    bottom: -", "px;\n    right: -", "px;\n    pointer-events: none;\n    position: absolute;\n    z-index: 1;\n    width: calc(100% + ", "px);\n    height: calc(100% + ", "px);\n    background-color: ", ";\n  "])), color.dark ? "screen" : "multiply", radius[3], space[2], space[2], space[2], space[2], space[2] * 2, space[2] * 2, bg);
});
var FieldStack = ut(Stack)(_b$6 || (_b$6 = __template$e(["\n  position: relative;\n"])));
function CommentFieldInner(props) {
  const [open, setOpen] = (0, import_react2.useState)(false);
  const [value, setValue] = (0, import_react2.useState)(null);
  const rootElementRef = (0, import_react2.useRef)(null);
  const { element: boundaryElement } = useBoundaryElement();
  const currentUser = useCurrentUser();
  const { comments: comments2, create, isCommentsOpen, isRunningSetup, mentionOptions, onCommentsOpen, setStatus, status } = useComments();
  const { selectedPath, setSelectedPath } = useCommentsSelectedPath();
  const fieldTitle = (0, import_react2.useMemo)(() => getSchemaTypeTitle(props.schemaType), [props.schemaType]);
  const [threadIdToScrollTo, setThreadIdToScrollTo] = (0, import_react2.useState)(null);
  const isSelected = (0, import_react2.useMemo)(() => {
    if (!isCommentsOpen)
      return false;
    if ((selectedPath == null ? void 0 : selectedPath.origin) === "form" || (selectedPath == null ? void 0 : selectedPath.origin) === "url")
      return false;
    return (selectedPath == null ? void 0 : selectedPath.fieldPath) === toString(props.path);
  }, [isCommentsOpen, props.path, selectedPath == null ? void 0 : selectedPath.fieldPath, selectedPath == null ? void 0 : selectedPath.origin]);
  const count = (0, import_react2.useMemo)(() => {
    const stringPath = toString(props.path);
    const commentsCount = comments2.data.open.map((c) => c.fieldPath === stringPath ? c.commentsCount : 0).reduce((acc, val) => acc + val, 0);
    return commentsCount || 0;
  }, [comments2.data.open, props.path]);
  const hasComments = Boolean(count > 0);
  const handleSetThreadToScrollTo = (0, import_react2.useCallback)((threadId) => {
    setSelectedPath({ threadId, origin: "form", fieldPath: toString(props.path) });
    setThreadIdToScrollTo(threadId);
  }, [props.path, setSelectedPath]);
  const handleClick = (0, import_react2.useCallback)(() => {
    var _a2;
    if (hasComments) {
      if (status === "resolved") {
        setStatus("open");
      }
      setOpen(false);
      onCommentsOpen == null ? void 0 : onCommentsOpen();
      const scrollToThreadId = (_a2 = comments2.data.open.find((c) => c.fieldPath === toString(props.path))) == null ? void 0 : _a2.threadId;
      if (scrollToThreadId) {
        handleSetThreadToScrollTo(scrollToThreadId);
      }
      return;
    }
    setOpen((v) => !v);
  }, [hasComments, status, onCommentsOpen, comments2.data.open, setStatus, props.path, handleSetThreadToScrollTo]);
  const handleCommentAdd = (0, import_react2.useCallback)(() => {
    if (value) {
      const newThreadId = v4_default();
      const nextComment = { fieldPath: toString(props.path), message: value, parentCommentId: void 0, status: "open", threadId: newThreadId };
      create.execute(nextComment);
      onCommentsOpen == null ? void 0 : onCommentsOpen();
      if (status === "resolved") {
        setStatus("open");
      }
      setValue(null);
      handleSetThreadToScrollTo(newThreadId);
    }
  }, [create, handleSetThreadToScrollTo, onCommentsOpen, props.path, setStatus, status, value]);
  const handleDiscard = (0, import_react2.useCallback)(() => setValue(null), []);
  const scrollIntoViewIfNeededOpts = (0, import_react2.useMemo)(() => ({ ...SCROLL_INTO_VIEW_OPTIONS, boundary: boundaryElement, scrollMode: "if-needed", block: "start" }), [boundaryElement]);
  (0, import_react2.useEffect)(() => {
    if (isSelected && rootElementRef.current && isCommentsOpen) {
      e(rootElementRef.current, scrollIntoViewIfNeededOpts);
    }
  }, [boundaryElement, isCommentsOpen, isSelected, props.path, scrollIntoViewIfNeededOpts]);
  (0, import_react2.useEffect)(() => {
    if (isCommentsOpen && threadIdToScrollTo) {
      const node = document.querySelector('[data-group-id="'.concat(threadIdToScrollTo, '"]'));
      if (node) {
        node.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS);
        setThreadIdToScrollTo(null);
      }
    }
  }, [isCommentsOpen, threadIdToScrollTo]);
  const internalComments = (0, import_react2.useMemo)(() => ({ button: currentUser && (0, import_jsx_runtime2.jsx)(CommentsFieldButton, { count: Number(count), currentUser, fieldTitle, isRunningSetup, mentionOptions, onChange: setValue, onClick: handleClick, onCommentAdd: handleCommentAdd, onDiscard: handleDiscard, open, setOpen, value }), hasComments, isAddingComment: open }), [currentUser, count, fieldTitle, mentionOptions, handleClick, handleCommentAdd, handleDiscard, open, value, isRunningSetup, hasComments]);
  return (0, import_jsx_runtime2.jsxs)(FieldStack, { ref: rootElementRef, children: [props.renderDefault({
    ...props,
    // eslint-disable-next-line camelcase
    __internal_comments: internalComments
  }), (0, import_jsx_runtime2.jsx)(AnimatePresence, { children: isSelected && (0, import_jsx_runtime2.jsx)(HighlightDiv, { animate: "animate", exit: "exit", initial: "initial", variants: HIGHLIGHT_BLOCK_VARIANTS }) })] });
}
function CommentsDocumentLayout(props) {
  const { documentId, documentType } = props;
  return (0, import_jsx_runtime2.jsx)(CommentsEnabledProvider, { documentId, documentType, children: (0, import_jsx_runtime2.jsx)(CommentsDocumentLayoutInner, { ...props }) });
}
function CommentsDocumentLayoutInner(props) {
  const { documentId, documentType } = props;
  const commentsEnabled = useCommentsEnabled();
  const { openInspector, inspector } = useDocumentPane();
  const handleOpenCommentsInspector = (0, import_react2.useCallback)(() => {
    if ((inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME)
      return;
    openInspector(COMMENTS_INSPECTOR_NAME);
  }, [inspector == null ? void 0 : inspector.name, openInspector]);
  if (!commentsEnabled) {
    return props.renderDefault(props);
  }
  return (0, import_jsx_runtime2.jsx)(CommentsProvider, { documentId, documentType, isCommentsOpen: (inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME, onCommentsOpen: handleOpenCommentsInspector, children: (0, import_jsx_runtime2.jsx)(CommentsSelectedPathProvider, { children: props.renderDefault(props) }) });
}
function CommentsStudioLayout(props) {
  return (0, import_jsx_runtime2.jsx)(CommentsSetupProvider, { children: (0, import_jsx_runtime2.jsx)(CommentsOnboardingProvider, { children: props.renderDefault(props) }) });
}
var comments = definePlugin({ name: "sanity/structure/comments", document: { inspectors: [commentsInspector], components: { unstable_layout: CommentsDocumentLayout } }, form: { components: { field: CommentsField } }, studio: { components: { layout: CommentsStudioLayout } } });
var StructureToolContext = (0, import_react2.createContext)(null);
function useStructureTool() {
  const structureTool2 = (0, import_react2.useContext)(StructureToolContext);
  if (!structureTool2)
    throw new Error("StructureTool: missing context value");
  return structureTool2;
}
var TIMELINE_ICON_COMPONENTS = { create: AddCircleIcon, delete: TrashIcon, discardDraft: CloseIcon, initial: AddCircleIcon, editDraft: EditIcon, editLive: EditIcon, publish: PublishIcon, unpublish: UnpublishIcon };
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
function UserAvatarStack(_ref75) {
  let { maxLength, userIds } = _ref75;
  return (0, import_jsx_runtime2.jsx)(AvatarStack, { maxLength, children: userIds.map((userId) => (0, import_jsx_runtime2.jsx)(UserAvatar, { user: userId, withTooltip: true }, userId)) });
}
var __freeze$d = Object.freeze;
var __defProp$d = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$d(cooked, "raw", { value: __freeze$d(raw || cooked.slice()) }));
var _a$d;
var _b$5;
var _c$2;
var _d$1;
var _e;
var _f;
var IconWrapper = ut(Flex)((_ref76) => {
  let { theme } = _ref76;
  var _a2;
  const borderColor = (_a2 = theme.sanity.color.base.skeleton) == null ? void 0 : _a2.from;
  return at(_a$d || (_a$d = __template$d(["\n    --timeline-hairline-width: 1px;\n    position: relative;\n    z-index: 2;\n    margin: 0;\n    padding: 0;\n\n    &::before {\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: var(--timeline-hairline-width);\n      background: ", ";\n      top: 0;\n      left: calc((100% - var(--timeline-hairline-width)) / 2);\n      z-index: 1;\n    }\n  "])), borderColor);
});
var Root$5 = ut(Button)((_ref77) => {
  let { $selected, $disabled } = _ref77;
  return at(_d$1 || (_d$1 = __template$d(["\n    position: relative;\n    width: 100%;\n\n    /* Line styling */\n    &[data-first] ", "::before {\n      height: 50%;\n      top: unset;\n      bottom: 0;\n    }\n\n    &[data-last] ", "::before {\n      height: 50%;\n    }\n\n    ", "\n\n    ", "\n  "])), IconWrapper, IconWrapper, $selected && at(_b$5 || (_b$5 = __template$d(["\n      ", "::before {\n        background: transparent;\n      }\n    "])), IconWrapper), $disabled && at(_c$2 || (_c$2 = __template$d(["\n      cursor: not-allowed;\n    "]))));
});
var IconBox = ut(Box)(_e || (_e = __template$d(["\n  background: var(--card-bg-color);\n  border-radius: 50px;\n  position: relative;\n  z-index: 2;\n"])));
var TimestampBox = ut(Box)(_f || (_f = __template$d(["\n  min-width: 1rem;\n  margin-left: ", ";\n"])), (_ref78) => {
  let { theme } = _ref78;
  return "-".concat(rem(theme.sanity.space[1]));
});
var TIMELINE_ITEM_I18N_KEY_MAPPING = { initial: "timeline.operation.created-initial", create: "timeline.operation.created", publish: "timeline.operation.published", editLive: "timeline.operation.edited-live", editDraft: "timeline.operation.edited-draft", unpublish: "timeline.operation.unpublished", discardDraft: "timeline.operation.draft-discarded", delete: "timeline.operation.deleted" };
var TIMELINE_ITEM_EVENT_TONE = { initial: "primary", create: "primary", publish: "positive", editLive: "caution", editDraft: "caution", unpublish: "critical", discardDraft: "critical", delete: "critical", withinSelection: "primary" };
function TimelineItem(_ref79) {
  let { chunk, isFirst, isLast, isLatest, isSelected, onSelect, timestamp, type } = _ref79;
  const { t } = useTranslation2("studio");
  const iconComponent = getTimelineEventIconComponent(type);
  const authorUserIds = Array.from(chunk.authors);
  const isSelectable = type !== "delete";
  const dateFormat = useDateTimeFormat({ dateStyle: "medium", timeStyle: "short" });
  const formattedTimestamp = (0, import_react2.useMemo)(() => {
    const parsedDate = new Date(timestamp);
    const formattedDate = dateFormat.format(parsedDate);
    return formattedDate;
  }, [timestamp, dateFormat]);
  const handleClick = (0, import_react2.useCallback)((evt) => {
    evt.preventDefault();
    evt.stopPropagation();
    if (isSelectable) {
      onSelect(chunk);
    }
  }, [onSelect, chunk, isSelectable]);
  return (0, import_jsx_runtime2.jsx)(Root$5, { $selected: isSelected, $disabled: !isSelectable, "data-chunk-id": chunk.id, "data-first": isFirst ? true : void 0, "data-last": isLast ? true : void 0, "data-ui": "timelineItem", mode: isSelected ? "default" : "bleed", onClick: handleClick, padding: 0, radius: 2, tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type], children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "stretch", children: [(0, import_jsx_runtime2.jsx)(IconWrapper, { align: "center", children: (0, import_jsx_runtime2.jsx)(IconBox, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 2, children: iconComponent && (0, import_react2.createElement)(iconComponent) }) }) }), (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, margin: 2, children: [isLatest && (0, import_jsx_runtime2.jsx)(Flex, { children: (0, import_jsx_runtime2.jsx)(Card, { padding: 1, radius: 2, shadow: 1, tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type], children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 0, weight: "medium", children: t("timeline.latest") }) }) }), (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t(TIMELINE_ITEM_I18N_KEY_MAPPING[type]) || (0, import_jsx_runtime2.jsx)("code", { children: type }) }) }), (0, import_jsx_runtime2.jsx)(TimestampBox, { paddingX: 1, children: (0, import_jsx_runtime2.jsx)(Text, { as: "time", size: 0, muted: true, dateTime: timestamp, children: formattedTimestamp }) })] }), (0, import_jsx_runtime2.jsx)(Flex, { flex: 1, justify: "flex-end", align: "center", children: (0, import_jsx_runtime2.jsx)(UserAvatarStack, { maxLength: 3, userIds: authorUserIds }) })] }) }) });
}
var __freeze$c = Object.freeze;
var __defProp$c = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$c(cooked, "raw", { value: __freeze$c(raw || cooked.slice()) }));
var _a$c;
var _b$4;
var _c$1;
var _d;
var StackWrapper = ut(Stack)(_a$c || (_a$c = __template$c(["\n  max-width: 200px;\n"])));
var ListWrapper = ut(Flex)(_b$4 || (_b$4 = __template$c(["\n  max-height: calc(100vh - 198px);\n  min-width: 244px;\n"])));
var Root$4 = ut(Box)((_ref80) => {
  let { $visible } = _ref80;
  return at(_d || (_d = __template$c(["\n    opacity: 0;\n    pointer-events: none;\n\n    ", "\n  "])), $visible && at(_c$1 || (_c$1 = __template$c(["\n      opacity: 1;\n      pointer-events: auto;\n    "]))));
});
var Timeline = (_ref81) => {
  let { chunks, disabledBeforeFirstChunk, hasMoreChunks, lastChunk, onLoadMore, onSelect, firstChunk } = _ref81;
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  const { t } = useTranslation2("studio");
  const filteredChunks = (0, import_react2.useMemo)(() => {
    return chunks.filter((c) => {
      if (disabledBeforeFirstChunk && firstChunk) {
        return c.index < firstChunk.index;
      }
      return true;
    });
  }, [chunks, disabledBeforeFirstChunk, firstChunk]);
  const selectedIndex = (0, import_react2.useMemo)(() => (lastChunk == null ? void 0 : lastChunk.id) ? filteredChunks.findIndex((c) => c.id === lastChunk.id) : -1, [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]);
  const renderItem2 = (0, import_react2.useCallback)((chunk, _ref82) => {
    let { activeIndex } = _ref82;
    const isFirst = activeIndex === 0;
    const isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || false;
    return (0, import_jsx_runtime2.jsxs)(Box, { paddingBottom: isLast ? 1 : 0, paddingTop: isFirst ? 1 : 0, paddingX: 1, children: [(0, import_jsx_runtime2.jsx)(TimelineItem, { chunk, isFirst, isLast, isLatest: activeIndex === 0 && !disabledBeforeFirstChunk, isSelected: activeIndex === selectedIndex, onSelect, timestamp: chunk.endTimestamp, type: chunk.type }), activeIndex === filteredChunks.length - 1 && hasMoreChunks && (0, import_jsx_runtime2.jsx)(LoadingBlock, {})] });
  }, [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]);
  (0, import_react2.useEffect)(() => setMounted(true), []);
  return (0, import_jsx_runtime2.jsxs)(Root$4, { $visible: !selectedIndex || mounted, "data-ui": "timeline", children: [filteredChunks.length === 0 && (0, import_jsx_runtime2.jsxs)(StackWrapper, { padding: 3, space: 3, children: [(0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }), (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t("timeline.error.no-document-history-description") })] }), filteredChunks.length > 0 && (0, import_jsx_runtime2.jsx)(ListWrapper, { direction: "column", children: (0, import_jsx_runtime2.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t("timeline.list.aria-label"), autoFocus: "list", initialIndex: selectedIndex, initialScrollAlign: "center", itemHeight: 40, items: filteredChunks, onEndReached: onLoadMore, onEndReachedIndexOffset: 20, overscan: 5, renderItem: renderItem2, wrapAround: false }) })] });
};
Timeline.displayName = "Timeline";
function TimelineError() {
  const { t } = useTranslation2("studio");
  return (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", gap: 3, padding: 4, children: [(0, import_jsx_runtime2.jsx)(TextWithTone, { tone: "critical", children: (0, import_jsx_runtime2.jsx)(ErrorOutlineIcon, {}) }), (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime2.jsx)(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t("timeline.error.load-document-changes-title") }), (0, import_jsx_runtime2.jsx)(TextWithTone, { size: 1, tone: "critical", children: t("timeline.error.load-document-changes-description") })] })] });
}
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", { value: __freeze$b(raw || cooked.slice()) }));
var _a$b;
var Root$3 = ut(Popover2)(_a$b || (_a$b = __template$b(["\n  overflow: hidden;\n  overflow: clip;\n"])));
function TimelineMenu(_ref83) {
  let { chunk, mode, placement } = _ref83;
  const { setTimelineRange, setTimelineMode, timelineError, ready, timelineStore } = useDocumentPane();
  const [open, setOpen] = (0, import_react2.useState)(false);
  const [button, setButton] = (0, import_react2.useState)(null);
  const [popover, setPopover] = (0, import_react2.useState)(null);
  const toast = useToast();
  const chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks);
  const loading = useTimelineSelector(timelineStore, (state2) => state2.isLoading);
  const hasMoreChunks = useTimelineSelector(timelineStore, (state2) => state2.hasMoreChunks);
  const realRevChunk = useTimelineSelector(timelineStore, (state2) => state2.realRevChunk);
  const sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime);
  const { t } = useTranslation2("studio");
  const handleOpen = (0, import_react2.useCallback)(() => {
    setTimelineMode(mode);
    setOpen(true);
  }, [mode, setTimelineMode]);
  const handleClose = (0, import_react2.useCallback)(() => {
    setTimelineMode("closed");
    setOpen(false);
  }, [setTimelineMode]);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (open) {
      handleClose();
    }
  }, [handleClose, open]);
  const handleGlobalKeyDown = (0, import_react2.useCallback)((event) => {
    if (open && (event.key === "Escape" || event.key === "Tab")) {
      handleClose();
      button == null ? void 0 : button.focus();
    }
  }, [button, handleClose, open]);
  useClickOutside(handleClickOutside, [button, popover]);
  useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = (0, import_react2.useCallback)((revChunk) => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err2) {
      toast.push({ closable: true, description: err2.message, status: "error", title: t("timeline.error.unable-to-load-revision") });
    }
  }, [setTimelineMode, setTimelineRange, t, timelineStore, toast]);
  const selectSince = (0, import_react2.useCallback)((sinceChunk) => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err2) {
      toast.push({ closable: true, description: err2.message, status: "error", title: t("timeline.error.unable-to-load-revision") });
    }
  }, [setTimelineMode, setTimelineRange, t, timelineStore, toast]);
  const handleLoadMore = (0, import_react2.useCallback)(() => {
    if (!loading) {
      timelineStore.loadMore();
    }
  }, [loading, timelineStore]);
  const content = timelineError ? (0, import_jsx_runtime2.jsx)(TimelineError, {}) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [mode === "rev" && (0, import_jsx_runtime2.jsx)(Timeline, { chunks, firstChunk: realRevChunk, hasMoreChunks, lastChunk: realRevChunk, onLoadMore: handleLoadMore, onSelect: selectRev }), mode === "since" && (0, import_jsx_runtime2.jsx)(Timeline, { chunks, disabledBeforeFirstChunk: true, firstChunk: realRevChunk, hasMoreChunks, lastChunk: sinceTime, onLoadMore: handleLoadMore, onSelect: selectSince })] });
  const formatParams = { timestamp: { dateStyle: "medium", timeStyle: "short" } };
  const revLabel = chunk ? t(TIMELINE_ITEM_I18N_KEY_MAPPING[chunk.type], { context: "timestamp", timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp), formatParams }) : t("timeline.latest-version");
  const sinceLabel = chunk ? t("timeline.since", { timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp), formatParams }) : t("timeline.since-version-missing");
  const buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return (0, import_jsx_runtime2.jsx)(Root$3, { constrainSize: true, content: open && content, "data-ui": "versionMenu", open, placement, portal: true, ref: setPopover, children: (0, import_jsx_runtime2.jsx)(Button2, { disabled: !ready, mode: "bleed", iconRight: ChevronDownIcon, onClick: open ? handleClose : handleOpen, ref: setButton, selected: open, style: { maxWidth: "100%" }, text: ready ? buttonLabel : t("timeline.loading-history") }) });
}
var Root$2 = ut(Card)({ position: "relative", zIndex: 1, lineHeight: 0 });
function DocumentInspectorHeader(props) {
  const { as: forwardedAs, children, closeButtonLabel, onClose, title, ...restProps } = props;
  return (0, import_jsx_runtime2.jsxs)(Root$2, { ...restProps, as: forwardedAs, children: [(0, import_jsx_runtime2.jsxs)(Flex, { padding: 2, children: [(0, import_jsx_runtime2.jsx)(Box, { flex: 1, padding: 3, children: (0, import_jsx_runtime2.jsx)(Text, { as: "h1", size: 1, weight: "medium", children: title }) }), (0, import_jsx_runtime2.jsx)(Box, { flex: "none", padding: 1, children: (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": closeButtonLabel, icon: CloseIcon, mode: "bleed", onClick: onClose, tooltipProps: { content: "Close" } }) })] }), children] });
}
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", { value: __freeze$a(raw || cooked.slice()) }));
var _a$a;
var Root$1 = ut.div(_a$a || (_a$a = __template$a(["\n  position: absolute;\n  top: 0;\n  left: -4px;\n  bottom: 0;\n  width: 9px;\n  z-index: 201;\n  cursor: ew-resize;\n\n  /* Border */\n  & > span:nth-child(1) {\n    display: block;\n    border-left: 1px solid var(--card-border-color);\n    position: absolute;\n    top: 0;\n    left: 4px;\n    bottom: 0;\n    transition: opacity 200ms;\n  }\n\n  /* Hover effect */\n  & > span:nth-child(2) {\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 9px;\n    bottom: 0;\n    background-color: var(--card-border-color);\n    opacity: 0;\n    transition: opacity 150ms;\n  }\n\n  @media (hover: hover) {\n    &:hover > span:nth-child(2) {\n      opacity: 0.2;\n    }\n  }\n"])));
function Resizer(props) {
  const { onResize, onResizeStart } = props;
  const mouseXRef = (0, import_react2.useRef)(0);
  const handleMouseDown = (0, import_react2.useCallback)((event) => {
    event.preventDefault();
    mouseXRef.current = event.pageX;
    onResizeStart();
    const handleMouseMove = (e2) => {
      e2.preventDefault();
      onResize(e2.pageX - mouseXRef.current);
    };
    const handleMouseUp = () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [onResize, onResizeStart]);
  return (0, import_jsx_runtime2.jsxs)(Root$1, { onMouseDown: handleMouseDown, children: [(0, import_jsx_runtime2.jsx)("span", {}), (0, import_jsx_runtime2.jsx)("span", {})] });
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", { value: __freeze$9(raw || cooked.slice()) }));
var _a$9;
var Root = ut(Box)(_a$9 || (_a$9 = __template$9(["\n  position: relative;\n  flex: 1;\n  padding-left: 1px;\n"])));
function Resizable(props) {
  const { as: forwardedAs, children, minWidth, maxWidth, ...restProps } = props;
  const [element, setElement] = (0, import_react2.useState)(null);
  const elementWidthRef = (0, import_react2.useRef)();
  const [targetWidth, setTargetWidth] = (0, import_react2.useState)();
  const handleResizeStart = (0, import_react2.useCallback)(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]);
  const handleResize = (0, import_react2.useCallback)((deltaX) => {
    const w = elementWidthRef.current;
    if (!w)
      return;
    setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
  }, [minWidth, maxWidth]);
  const style = (0, import_react2.useMemo)(() => targetWidth ? { flex: "none", width: targetWidth } : { minWidth, maxWidth }, [minWidth, maxWidth, targetWidth]);
  return (0, import_jsx_runtime2.jsxs)(Root, { as: forwardedAs, ...restProps, ref: setElement, style, children: [children, (0, import_jsx_runtime2.jsx)(Resizer, { onResize: handleResize, onResizeStart: handleResizeStart })] });
}
function DocumentInspectorPanel(props) {
  const { documentId, documentType, flex } = props;
  const { collapsed } = usePane();
  const { closeInspector, inspector } = useDocumentPane();
  const { features } = useStructureTool();
  const handleClose = (0, import_react2.useCallback)(() => {
    if (inspector)
      closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector)
    return null;
  const element = (0, import_react2.createElement)(inspector.component, { onClose: handleClose, documentId, documentType });
  if (features.resizablePanes) {
    return (0, import_jsx_runtime2.jsx)(Resizable, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH, minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH, children: element });
  }
  return (0, import_jsx_runtime2.jsx)(Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element });
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */ new Map();
  visitDiff(diff, (child) => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation) {
      return true;
    }
    const { author, timestamp } = child.annotation;
    const previous = authorMap.get(author);
    if (!previous || previous.timestamp < timestamp) {
      authorMap.set(author, child.annotation);
    }
    return true;
  });
  return Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", { value: __freeze$8(raw || cooked.slice()) }));
var _a$8;
var Scroller$1 = ut(ScrollContainer)(_a$8 || (_a$8 = __template$8(["\n  height: 100%;\n  overflow: auto;\n  position: relative;\n  scroll-behavior: smooth;\n"])));
function ChangesInspector(props) {
  const { onClose } = props;
  const { documentId, schemaType, timelineError, timelineStore, value } = useDocumentPane();
  const scrollRef = (0, import_react2.useRef)(null);
  const diff = useTimelineSelector(timelineStore, (state2) => state2.diff);
  const onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const selectionState = useTimelineSelector(timelineStore, (state2) => state2.selectionState);
  const sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime);
  const loading = selectionState === "loading";
  const isComparingCurrent = !onOlderRevision;
  const { t } = useTranslation2("studio");
  const documentContext = import_react2.default.useMemo(() => ({ documentId, schemaType, FieldWrapper: ChangeFieldWrapper, rootDiff: diff, isComparingCurrent, value }), [documentId, diff, isComparingCurrent, schemaType, value]);
  const changeAnnotations = import_react2.default.useMemo(() => diff ? collectLatestAuthorAnnotations(diff) : [], [diff]);
  return (0, import_jsx_runtime2.jsxs)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [(0, import_jsx_runtime2.jsx)(DocumentInspectorHeader, { as: "header", closeButtonLabel: t("changes.action.close-label"), flex: "none", onClose, title: t("changes.title"), children: (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, padding: 3, paddingTop: 0, paddingBottom: 2, children: [(0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }) }), (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(DiffTooltip, { annotations: changeAnnotations, description: t("changes.changes-by-author"), portal: true, children: (0, import_jsx_runtime2.jsx)(AvatarStack, { maxLength: 4, "aria-label": t("changes.changes-by-author"), children: changeAnnotations.map((_ref84) => {
    let { author } = _ref84;
    return (0, import_jsx_runtime2.jsx)(UserAvatar, { user: author }, author);
  }) }) }) })] }) }), (0, import_jsx_runtime2.jsx)(Card, { flex: 1, children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: scrollRef.current, children: (0, import_jsx_runtime2.jsx)(Scroller$1, { "data-ui": "Scroller", ref: scrollRef, children: (0, import_jsx_runtime2.jsx)(Box, { flex: 1, padding: 4, children: (0, import_jsx_runtime2.jsx)(Content$1, { diff, documentContext, error: timelineError, loading, schemaType }) }) }) }) })] });
}
function Content$1(_ref85) {
  let { error, diff, documentContext, loading, schemaType } = _ref85;
  if (error) {
    return (0, import_jsx_runtime2.jsx)(NoChanges, {});
  }
  if (loading) {
    return (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true });
  }
  if (!diff) {
    return (0, import_jsx_runtime2.jsx)(NoChanges, {});
  }
  return (0, import_jsx_runtime2.jsx)(DocumentChangeContext.Provider, { value: documentContext, children: (0, import_jsx_runtime2.jsx)(ChangeList, { diff, schemaType }) });
}
var changesInspector = { name: HISTORY_INSPECTOR_NAME, useMenuItem: () => {
  const { features } = useStructureTool();
  const { t } = useTranslation2();
  return { hidden: !features.reviewChanges, icon: RestoreIcon, title: t("changes.title") };
}, component: ChangesInspector, onClose: (_ref86) => {
  let { params } = _ref86;
  return { params: { ...params, since: void 0 } };
}, onOpen: (_ref87) => {
  let { params } = _ref87;
  return { params: { ...params, since: "@lastPublished" } };
} };
function getPathTitles(options) {
  const { path, schemaType, value } = options;
  const result = [];
  let s = schemaType;
  let v = value;
  for (const segment of path) {
    if (typeof segment === "string") {
      if (!isRecord$4(v) && v !== void 0) {
        throw new Error("Parent value is not an object, cannot get path segment: .".concat(segment));
      }
      if (s.jsonType !== "object") {
        throw new Error("Parent type is not an object schema type, cannot get path segment: .".concat(segment));
      }
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field) {
        result.push({ name: segment });
        return result;
      }
      s = field.type;
      result.push(s);
      continue;
    }
    if (typeof segment === "number") {
      if (!isArray(v) && v !== void 0) {
        throw new Error("Parent value is not an array, cannot get path segment: [".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: [".concat(segment, "]"));
      }
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find((ofType) => {
        if (typeof v === "string") {
          return ofType.jsonType === "string";
        }
        if (typeof v === "number") {
          return ofType.jsonType === "number";
        }
        if (typeof v === "boolean") {
          return ofType.jsonType === "boolean";
        }
        if (isRecord$4(v)) {
          return ofType.name === (v == null ? void 0 : v._type);
        }
        return false;
      });
      if (!itemType) {
        throw new Error("Item type not found: [".concat(segment, "]"));
      }
      s = itemType;
      result.push(s);
      continue;
    }
    if (isRecord$4(segment) && segment._key) {
      if (!isArray(v)) {
        throw new Error("Parent value is not an array, cannot get path segment: [_key == ".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: .".concat(segment));
      }
      const values = v != null ? v : [];
      v = values.find((i) => isRecord$4(i) && i._key === segment._key);
      if (!isRecord$4(v)) {
        throw new Error("Array item not found: [_key == ".concat(segment._key, "]"));
      }
      const ofType = s.of.find((i) => isRecord$4(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType) {
        throw new Error("Array item type not found: .".concat(v == null ? void 0 : v._type));
      }
      s = ofType;
      result.push(s);
      continue;
    }
    throw new Error("Invalid path segment: ".concat(JSON.stringify(segment)));
  }
  return result;
}
var MARKER_ICON = { error: ErrorOutlineIcon, warning: WarningOutlineIcon, info: InfoOutlineIcon };
var MARKER_TONE = { error: "critical", warning: "caution", info: "primary" };
function ValidationInspector(props) {
  const { onClose } = props;
  const { onFocus, onPathOpen, schemaType, validation, value } = useDocumentPane();
  const { t } = useTranslation2("validation");
  const handleOpen = (0, import_react2.useCallback)((path) => {
    onPathOpen(path);
    onFocus(path);
  }, [onFocus, onPathOpen]);
  return (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [(0, import_jsx_runtime2.jsx)(DocumentInspectorHeader, { as: "header", closeButtonLabel: t("panel.close-button-aria-label"), flex: "none", onClose, title: t("panel.title") }), (0, import_jsx_runtime2.jsxs)(Card, { flex: 1, overflow: "auto", padding: 3, children: [validation.length === 0 && (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t("panel.no-errors-message") }) }), validation.length > 0 && (0, import_jsx_runtime2.jsx)(Stack, { space: 2, children: validation.map((marker, i) => (0, import_jsx_runtime2.jsx)(ValidationCard, { marker, onOpen: handleOpen, schemaType, value }, i)) })] })] });
}
function ValidationCard(props) {
  const { marker, onOpen, schemaType, value } = props;
  const handleOpen = (0, import_react2.useCallback)(() => onOpen(marker.path), [marker, onOpen]);
  const [errorInfo, setErrorInfo] = (0, import_react2.useState)(null);
  return (0, import_jsx_runtime2.jsxs)(ErrorBoundary, { onCatch: setErrorInfo, children: [errorInfo && (0, import_jsx_runtime2.jsx)(Card, { padding: 3, radius: 2, tone: "critical", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: errorInfo.error.message }) }), !errorInfo && (0, import_jsx_runtime2.jsx)(Card, { __unstable_focusRing: true, as: "button", onClick: handleOpen, padding: 3, radius: 2, tone: MARKER_TONE[marker.level], children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", gap: 3, children: [(0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_react2.createElement)(MARKER_ICON[marker.level]) }) }), (0, import_jsx_runtime2.jsxs)(Stack, { flex: 1, space: 2, children: [(0, import_jsx_runtime2.jsx)(DocumentNodePathBreadcrumbs, { path: marker.path, schemaType, value }), (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: marker.message })] })] }) })] });
}
function DocumentNodePathBreadcrumbs(props) {
  const { path, schemaType, value } = props;
  const pathTitles = (0, import_react2.useMemo)(() => getPathTitles({ path, schemaType, value }), [path, schemaType, value]);
  if (!pathTitles.length)
    return null;
  return (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: pathTitles.map((t, i) => (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [i > 0 && (0, import_jsx_runtime2.jsx)("span", { style: { color: "var(--card-muted-fg-color)", opacity: 0.5 }, children: " / " }), (0, import_jsx_runtime2.jsx)("span", { style: { fontWeight: 500 }, children: t.title || t.name })] }, i)) });
}
function useMenuItem(props) {
  const { documentId, documentType } = props;
  const { t } = useTranslation2("validation");
  const { validation: validationMarkers } = useValidationStatus(documentId, documentType);
  const validation = (0, import_react2.useMemo)(() => validationMarkers.map((item) => ({ level: item.level, message: item.message, path: item.path })), [validationMarkers]);
  const hasErrors = validation.some(isValidationError);
  const hasWarnings = validation.some(isValidationWarning);
  const icon = (0, import_react2.useMemo)(() => {
    if (hasErrors)
      return ErrorOutlineIcon;
    if (hasWarnings)
      return WarningOutlineIcon;
    return CheckmarkCircleIcon;
  }, [hasErrors, hasWarnings]);
  const tone = (0, import_react2.useMemo)(() => {
    if (hasErrors)
      return "critical";
    if (hasWarnings)
      return "caution";
    return "positive";
  }, [hasErrors, hasWarnings]);
  return { hidden: validation.length === 0, icon, title: t("panel.title"), tone, showAsAction: true };
}
var validationInspector = { name: VALIDATION_INSPECTOR_NAME, component: ValidationInspector, useMenuItem };
var documentActions = [PublishAction, UnpublishAction, DiscardChangesAction, DuplicateAction, DeleteAction, HistoryRestoreAction];
var documentBadges = [LiveEditBadge];
var inspectors = [validationInspector, changesInspector];
var structureTool = definePlugin((options) => {
  const icon = (options == null ? void 0 : options.icon) || MasterDetailIcon;
  return { name: "sanity/structure", document: { actions: (prevActions) => {
    return Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions]));
  }, badges: (prevBadges) => {
    return Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges]));
  }, inspectors: (prevInspectors) => {
    return Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]));
  } }, plugins: [comments()], tools: [{
    name: (options == null ? void 0 : options.name) || "structure",
    title: (options == null ? void 0 : options.title) || "Structure",
    icon,
    component: (0, import_react2.lazy)(() => import("./index-nhKDW7Y9-WZB3YFPM.js")),
    canHandleIntent: (intent, params) => {
      if (intent === "create")
        return canHandleCreateIntent(params);
      if (intent === "edit")
        return canHandleEditIntent(params);
      return false;
    },
    getIntentState,
    // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
    controlsDocumentTitle: true,
    options,
    router
  }], i18n: { bundles: [structureUsEnglishLocaleBundle] } };
});
function canHandleCreateIntent(params) {
  if (!("type" in params)) {
    return false;
  }
  return "template" in params ? { template: true } : true;
}
function canHandleEditIntent(params) {
  if (!("id" in params)) {
    return false;
  }
  return "mode" in params ? { mode: params.mode === "structure" } : true;
}
var SerializeError = class extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    const segment = typeof pathSegment === "undefined" ? "<unknown>" : "".concat(pathSegment);
    this.path = (parentPath || []).concat(hint ? "".concat(segment, " (").concat(hint, ")") : segment);
  }
  withHelpUrl(id) {
    this.helpId = id;
    return this;
  }
};
var HELP_URL = ((HELP_URL2) => {
  HELP_URL2["ID_REQUIRED"] = "structure-node-id-required";
  HELP_URL2["TITLE_REQUIRED"] = "structure-title-required";
  HELP_URL2["FILTER_REQUIRED"] = "structure-filter-required";
  HELP_URL2["INVALID_LIST_ITEM"] = "structure-invalid-list-item";
  HELP_URL2["COMPONENT_REQUIRED"] = "structure-view-component-required";
  HELP_URL2["DOCUMENT_ID_REQUIRED"] = "structure-document-id-required";
  HELP_URL2["DOCUMENT_TYPE_REQUIRED"] = "structure-document-type-required";
  HELP_URL2["SCHEMA_TYPE_REQUIRED"] = "structure-schema-type-required";
  HELP_URL2["SCHEMA_TYPE_NOT_FOUND"] = "structure-schema-type-not-found";
  HELP_URL2["LIST_ITEMS_MUST_BE_ARRAY"] = "structure-list-items-must-be-array";
  HELP_URL2["QUERY_PROVIDED_FOR_FILTER"] = "structure-query-provided-for-filter";
  HELP_URL2["ACTION_OR_INTENT_REQUIRED"] = "structure-action-or-intent-required";
  HELP_URL2["LIST_ITEM_IDS_MUST_BE_UNIQUE"] = "structure-list-item-ids-must-be-unique";
  HELP_URL2["ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE"] = "structure-action-and-intent-mutually-exclusive";
  HELP_URL2["API_VERSION_REQUIRED_FOR_CUSTOM_FILTER"] = "structure-api-version-required-for-custom-filter";
  return HELP_URL2;
})(HELP_URL || {});
var IMPLICIT_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType)) {
    return "";
  }
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_FIELDS.includes(head)) {
      console.warn('The current ordering config targeted the nonexistent field "%s" on schema type "%s". It should be one of %o', head, schemaType.name, schemaType.fields.map((field) => field.name));
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return "".concat(head, "->{").concat(refTypes.map((refType) => joinReferences(refType, tail)).join(","), "}");
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail);
  const tailWrapper = tailFields ? "{".concat(tailFields, "}") : "";
  return tail.length > 0 ? "".concat(head).concat(tailWrapper) : head;
}
function getExtendedProjection(schemaType, orderBy2) {
  return orderBy2.map((ordering) => joinReferences(schemaType, ordering.field.split("."))).join(", ");
}
var ORDER_BY_UPDATED_AT = { title: "Last edited", i18n: { title: { key: "menu-items.sort-by.last-edited", ns: structureLocaleNamespace } }, name: "lastEditedDesc", by: [{ field: "_updatedAt", direction: "desc" }] };
var ORDER_BY_CREATED_AT = { title: "Created", i18n: { title: { key: "menu-items.sort-by.created", ns: structureLocaleNamespace } }, name: "lastCreatedDesc", by: [{ field: "_createdAt", direction: "desc" }] };
var DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT;
var DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
var MenuItemBuilder = class _MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Set menu item action
  * @param action - menu item action. See {@link MenuItemActionType}
  * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
  */
  action(action) {
    return this.clone({ action });
  }
  /**
  * Get menu item action
  * @returns menu item builder action. See {@link PartialMenuItem}
  */
  getAction() {
    return this.spec.action;
  }
  /**
  * Set menu item intent
  * @param intent - menu item intent. See {@link Intent}
  * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
  */
  intent(intent) {
    return this.clone({ intent });
  }
  /**
  * Get menu item intent
  * @returns menu item intent. See {@link PartialMenuItem}
  */
  getIntent() {
    return this.spec.intent;
  }
  /**
  * Set menu item title
  * @param title - menu item title
  * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
  */
  title(title) {
    return this.clone({ title });
  }
  /**
  * Get menu item title. Note that the `i18n` configuration will take
  * precedence and this title is left here for compatibility.
  * @returns menu item title
  */
  getTitle() {
    return this.spec.title;
  }
  /**
  * Set the i18n key and namespace used to populate the localized title.
  * @param i18n - object with i18n key and related namespace
  * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /**
  * Get the i18n key and namespace used to populate the localized title.
  * @returns the i18n key and namespace used to populate the localized title.
  */
  getI18n() {
    return this.spec.i18n;
  }
  /**
  * Set menu item group
  * @param group - menu item group
  * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
  */
  group(group) {
    return this.clone({ group });
  }
  /**
  * Get menu item group
  * @returns menu item group. See {@link PartialMenuItem}
  */
  getGroup() {
    return this.spec.group;
  }
  /**
  * Set menu item icon
  * @param icon - menu item icon
  * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
  */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
  * Get menu item icon
  * @returns menu item icon. See {@link PartialMenuItem}
  */
  getIcon() {
    return this.spec.icon;
  }
  /**
  * Set menu item parameters
  * @param params - menu item parameters. See {@link MenuItemParamsType}
  * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
  */
  params(params) {
    return this.clone({ params });
  }
  /**
  * Get meny item parameters
  * @returns menu item parameters. See {@link PartialMenuItem}
  */
  getParams() {
    return this.spec.params;
  }
  /**
  * Set menu item to show as action
  * @param showAsAction - determine if menu item should show as action
  * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
  */
  showAsAction() {
    let showAsAction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({ showAsAction: Boolean(showAsAction) });
  }
  /**
  * Check if menu item should show as action
  * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
  */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns menu item node based on path provided in options. See {@link MenuItem}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { title, action, intent } = this.spec;
    if (!title) {
      const hint = typeof action === "string" ? 'action: "'.concat(action, '"') : void 0;
      throw new SerializeError("`title` is required for menu item", options.path, options.index, hint).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent) {
      throw new SerializeError("`action` or `intent` required for menu item with title ".concat(this.spec.title), options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    }
    if (intent && action) {
      throw new SerializeError("cannot set both `action` AND `intent`", options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    }
    return { ...this.spec, title };
  }
  /** Clone menu item builder
  * @param withSpec - menu item options. See {@link PartialMenuItem}
  * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
  */
  clone(withSpec) {
    const builder = new _MenuItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
function getOrderingMenuItem(context, _ref88, extendedProjection) {
  let { by, title, i18n } = _ref88;
  let builder = new MenuItemBuilder(context).group("sorting").title(context.i18n.t("default-menu-item.fallback-title", {
    // note this lives in the `studio` bundle because that one is loaded by default
    ns: "studio",
    replace: { title }
    // replaces the `{{title}}` option
  })).icon(SortIcon).action("setSortOrder").params({ by, extendedProjection });
  if (i18n) {
    builder = builder.i18n(i18n);
  }
  return builder;
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const { schema: schema2 } = context;
  const type = typeof typeName === "string" ? schema2.get(typeName) : typeName;
  if (!type || !("orderings" in type)) {
    return [];
  }
  return (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map((ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by)));
}
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({ path, index }) : item;
}
var MenuItemGroupBuilder = class _MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this._id = spec ? spec.id : "";
    this._title = spec ? spec.title : "";
    this._i18n = spec ? spec.i18n : void 0;
  }
  /**
  * Set menu item group ID
  * @param id - menu item group ID
  * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
  */
  id(id) {
    return new _MenuItemGroupBuilder(this._context, { id, title: this._title, i18n: this._i18n });
  }
  /**
  * Get menu item group ID
  * @returns menu item group ID
  */
  getId() {
    return this._id;
  }
  /**
  * Set menu item group title
  * @param title - menu item group title
  * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
  */
  title(title) {
    return new _MenuItemGroupBuilder(this._context, { title, id: this._id, i18n: this._i18n });
  }
  /**
  * Get menu item group title
  * @returns menu item group title
  */
  getTitle() {
    return this._title;
  }
  /**
  * Set the i18n key and namespace used to populate the localized title.
  * @param i18n - object with i18n key and related namespace
  * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
  */
  i18n(i18n) {
    return new _MenuItemGroupBuilder(this._context, { i18n, id: this._id, title: this._title });
  }
  /**
  * Get the i18n key and namespace used to populate the localized title.
  * @returns the i18n key and namespace used to populate the localized title.
  */
  getI18n() {
    return this._i18n;
  }
  /**
  * Serialize menu item group builder
  * @param options - serialization options (path). See {@link SerializeOptions}
  * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { _id, _title, _i18n } = this;
    if (!_id) {
      throw new SerializeError("`id` is required for a menu item group", options.path, options.index, _title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!_title) {
      throw new SerializeError("`title` is required for a menu item group", options.path, _id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return { id: _id, title: _title, i18n: _i18n };
  }
};
var disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id !== "string") {
    throw new SerializeError("Structure node id must be of type string, got ".concat(typeof id), parentPath, pathSegment);
  }
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar) {
    throw new SerializeError('Structure node id cannot contain character "'.concat(disallowedChar, '"'), parentPath, pathSegment);
  }
  if (id.startsWith("__edit__")) {
    throw new SerializeError("Structure node id cannot start with __edit__", parentPath, pathSegment);
  }
  return id;
}
function getStructureNodeId(title, id) {
  if (id) {
    return id;
  }
  const camelCased = (0, import_camelCase.default)(title);
  return disallowedPattern.test(camelCased) ? (0, import_camelCase.default)((0, import_speakingurl2.default)(title)) : camelCased;
}
var ComponentBuilder = class _ComponentBuilder {
  constructor(spec) {
    this.spec = { options: {}, ...spec ? spec : {} };
  }
  /** Set Component ID
  * @param id - component ID
  * @returns component builder based on ID provided
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get ID
  * @returns ID
  */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
  * @param title - component title
  * @returns component builder based on title provided (and ID)
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Component title
  * @returns title
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Component child
  * @param child - child component
  * @returns component builder based on child component provided
  */
  child(child) {
    return this.clone({ child });
  }
  /** Get Component child
  * @returns child component
  */
  getChild() {
    return this.spec.child;
  }
  /** Set component
  * @param component - user built component
  * @returns component builder based on component provided
  */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get Component
  * @returns component
  */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
  * @param options - component options
  * @returns component builder based on options provided
  */
  options(options) {
    return this.clone({ options });
  }
  /** Get Component options
  * @returns component options
  */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
  * @param menuItems - component menu items
  * @returns component builder based on menuItems provided
  */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get Component menu items
  * @returns menu items
  */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
  * @param menuItemGroups - component menu item groups
  * @returns component builder based on menuItemGroups provided
  */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get Component menu item groups
  * @returns menu item groups
  */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Serialize component
  * @param options - serialization options
  * @returns component object based on path provided in options
  *
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { id, title, child, options: componentOptions, component: component2 } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!component2) {
      throw new SerializeError("`component` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return { id: validateId(id, options.path, options.index), title, type: "component", child, component: component2, options: componentOptions || {}, menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, options.path)), menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, options.path)) };
  }
  /** Clone component builder (allows for options overriding)
  * @param withSpec - component builder options
  * @returns cloned builder
  */
  clone(withSpec) {
    const builder = new _ComponentBuilder();
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type";
  const documentId = getPublishedId(id);
  const draftId = getDraftId(id);
  const types = await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(query, { documentId, draftId }, { tag: "structure.resolve-type" });
  return types[0];
}
var GenericViewBuilder = class {
  constructor() {
    this.spec = {};
  }
  /** Set generic view ID
  * @param id - generic view ID
  * @returns generic view builder based on ID provided.
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic view ID
  * @returns generic view ID
  */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
  * @param title - generic view title
  * @returns generic view builder based on title provided and (if provided) its ID.
  */
  title(title) {
    return this.clone({ title, id: this.spec.id || (0, import_kebabCase.default)(title) });
  }
  /** Get generic view title
  * @returns generic view title
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
  * @param icon - generic view icon
  * @returns generic view builder based on icon provided.
  */
  icon(icon) {
    return this.clone({ icon });
  }
  /** Get generic view icon
  * @returns generic view icon
  */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns generic view object based on path provided in options. See {@link BaseView}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { id, title, icon } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!title) {
      throw new SerializeError("`title` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return { id: validateId(id, options.path, options.index), title, icon };
  }
};
function isSerializable(view) {
  return typeof view.serialize === "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({ path, index }) : item;
}
var isComponentSpec = (spec) => isRecord$4(spec) && spec.type === "component";
var ComponentViewBuilder = class _ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? { ...componentOrSpec } : { options: {} };
    super();
    this.spec = spec;
    const userComponent = typeof componentOrSpec === "function" ? componentOrSpec : this.spec.component;
    if (userComponent) {
      this.spec = this.component(userComponent).spec;
    }
  }
  /** Set view Component
  * @param component - component view component. See {@link UserViewComponent}
  * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
  */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get view Component
  * @returns Partial component view. See {@link ComponentView}
  */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
  * @param options - component view options
  * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
  */
  options(options) {
    return this.clone({ options });
  }
  /** Get view Component options
  * @returns component view options. See {@link ComponentView}
  */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns component view based on path provided in options. See {@link ComponentView}
  *
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const base = super.serialize(options);
    const component2 = this.spec.component;
    if (typeof component2 !== "function") {
      throw new SerializeError("`component` is required and must be a function for `component()` view item", options.path, options.index).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    }
    return { ...base, component: component2, options: this.spec.options || {}, type: "component" };
  }
  /** Clone Component view builder (allows for options overriding)
  * @param withSpec - partial for component view option. See {@link ComponentView}
  * @returns component view builder. See {@link ComponentViewBuilder}
  */
  clone(withSpec) {
    const builder = new _ComponentViewBuilder();
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var FormViewBuilder = class _FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super();
    this.spec = { id: "editor", title: "Editor", ...spec ? spec : {} };
  }
  /**
  * Serialize Form view builder
  * @param options - Serialize options. See {@link SerializeOptions}
  * @returns form view builder based on path provided in options. See {@link FormView}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    return { ...super.serialize(options), type: "form" };
  }
  /**
  * Clone Form view builder (allows for options overriding)
  * @param withSpec - Partial form view builder options. See {@link FormView}
  * @returns form view builder. See {@link FormViewBuilder}
  */
  clone(withSpec) {
    const builder = new _FormViewBuilder();
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var form = (spec) => new FormViewBuilder(spec);
var component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = Object.freeze({ __proto__: null, ComponentViewBuilder, FormViewBuilder, GenericViewBuilder, component, form, maybeSerializeView });
var createDocumentChildResolver = (_ref89) => {
  let { resolveDocumentNode, getClient } = _ref89;
  return async (itemId, _ref90) => {
    let { params, path } = _ref90;
    let type = params.type;
    const parentPath = path.slice(0, path.length - 1);
    const currentSegment = path[path.length - 1];
    if (!type) {
      type = await resolveTypeForDocument(getClient, itemId);
    }
    if (!type) {
      throw new SerializeError("Failed to resolve document, and no type provided in parameters.", parentPath, currentSegment);
    }
    return resolveDocumentNode({ documentId: itemId, schemaType: type });
  };
};
var DocumentBuilder = class _DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /** Set Document Builder ID
  * @param id - document builder ID
  * @returns document builder based on ID provided. See {@link DocumentBuilder}
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get Document Builder ID
  * @returns document ID. See {@link PartialDocumentNode}
  */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
  * @param title - document title
  * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Document title
  * @returns document title. See {@link PartialDocumentNode}
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Document child
  * @param child - document child
  * @returns document builder based on child provided. See {@link DocumentBuilder}
  */
  child(child) {
    return this.clone({ child });
  }
  /** Get Document child
  * @returns document child. See {@link PartialDocumentNode}
  */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
  * @param documentId - document ID
  * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
  */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({ id: paneId, options: { ...this.spec.options || {}, id: documentId } });
  }
  /** Get Document ID
  * @returns document ID. See {@link DocumentOptions}
  */
  getDocumentId() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.id;
  }
  /** Set Document Type
  * @param documentType - document type
  * @returns document builder with document based on type provided. See {@link DocumentBuilder}
  */
  schemaType(documentType) {
    return this.clone({ options: { ...this.spec.options || {}, type: typeof documentType === "string" ? documentType : documentType.name } });
  }
  /** Get Document Type
  * @returns document type. See {@link DocumentOptions}
  */
  getSchemaType() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.type;
  }
  /** Set Document Template
  * @param templateId - document template ID
  * @param parameters - document template parameters
  * @returns document builder with document based on template provided. See {@link DocumentBuilder}
  */
  initialValueTemplate(templateId, parameters) {
    return this.clone({ options: { ...this.spec.options || {}, template: templateId, templateParameters: parameters } });
  }
  /** Get Document Template
  * @returns document template. See {@link DocumentOptions}
  */
  getInitialValueTemplate() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.template;
  }
  /** Get Document's initial value Template parameters
  * @returns document template parameters. See {@link DocumentOptions}
  */
  getInitialValueTemplateParameters() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.templateParameters;
  }
  /** Set Document views
  * @param views - document views. See {@link ViewBuilder} and {@link View}
  * @returns document builder with document based on views provided. See {@link DocumentBuilder}
  */
  views(views2) {
    return this.clone({ views: views2 });
  }
  /** Get Document views
  * @returns document views. See {@link ViewBuilder} and {@link View}
  */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
  */
  serialize() {
    let { path = [], index, hint } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const urlId = path[index || path.length - 1];
    const id = this.spec.id || urlId && "".concat(urlId) || "";
    const options = { id, type: void 0, template: void 0, templateParameters: void 0, ...this.spec.options };
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for document nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options || !options.id) {
      throw new SerializeError("document id (`id`) is required for document nodes", path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    }
    if (!options || !options.type) {
      throw new SerializeError("document type (`schemaType`) is required for document nodes", path, id, hint);
    }
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path));
    const viewIds = views2.map((view) => view.id);
    const dupes = (0, import_uniq2.default)(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0) {
      throw new SerializeError("document node has views with duplicate IDs: ".concat(dupes.join(",  ")), path, id, hint);
    }
    return { ...this.spec, child: this.spec.child || createDocumentChildResolver(this._context), id: validateId(id, path, index), type: "document", options: getDocumentOptions(options), views: views2 };
  }
  /** Clone Document builder
  * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
  * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
  */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const builder = new _DocumentBuilder(this._context);
    const options = { ...this.spec.options || {}, ...withSpec.options || {} };
    builder.spec = { ...this.spec, ...withSpec, options };
    return builder;
  }
};
function getDocumentOptions(spec) {
  const opts = { id: spec.id || "", type: spec.type || "*" };
  if (spec.template) {
    opts.template = spec.template;
  }
  if (spec.templateParameters) {
    opts.templateParameters = spec.templateParameters;
  }
  return opts;
}
function documentFromEditor(context, spec) {
  let doc = (spec == null ? void 0 : spec.type) ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({ schemaType: spec.type })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec)
    return doc;
  const { id, type, template, templateParameters } = spec.options;
  doc = doc.id(spec.id).documentId(id);
  if (type) {
    doc = doc.schemaType(type);
  }
  if (template) {
    doc = doc.initialValueTemplate(template, templateParameters);
  }
  if (spec.child) {
    doc = doc.child(spec.child);
  }
  return doc;
}
function documentFromEditorWithInitialValue(_ref91, templateId, parameters) {
  let { resolveDocumentNode, templates } = _ref91;
  const template = templates.find((t) => t.id === templateId);
  if (!template) {
    throw new Error('Template with ID "'.concat(templateId, '" not defined'));
  }
  return resolveDocumentNode({ schemaType: template.schemaType }).initialValueTemplate(templateId, parameters);
}
var layoutOptions = ["default", "card", "media", "detail", "block"];
var DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent");
var defaultIntentChecker = (intentName, params, _ref92) => {
  let { pane } = _ref92;
  var _a2, _b2;
  const isEdit = intentName === "edit";
  const isCreate = intentName === "create";
  const typedSpec = pane;
  const paneFilter = ((_a2 = typedSpec.options) == null ? void 0 : _a2.filter) || "";
  const paneParams = ((_b2 = typedSpec.options) == null ? void 0 : _b2.params) || {};
  const typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams);
  const initialValueTemplates = typedSpec.initialValueTemplates || [];
  if (isCreate && params.template) {
    return initialValueTemplates.some((tpl) => tpl.templateId === params.template);
  }
  return isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
var InitialValueTemplateItemBuilder = class _InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /** Set initial value template item builder ID
  * @param id - initial value template item ID
  * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get initial value template item builder ID
  * @returns initial value template item ID. See {@link InitialValueTemplateItem}
  */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
  * @param title - initial value template item title
  * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
  */
  title(title) {
    return this.clone({ title });
  }
  /** Get initial value template item title
  * @returns initial value template item title. See {@link InitialValueTemplateItem}
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
  * @param description - initial value template item description
  * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
  */
  description(description) {
    return this.clone({ description });
  }
  /** Get initial value template item description
  * @returns initial value template item description. See {@link InitialValueTemplateItem}
  */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
  * @param templateId - initial value template item template ID
  * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
  */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({ id: paneId, templateId });
  }
  /** Get initial value template item template ID
  * @returns initial value template item ID. See {@link InitialValueTemplateItem}
  */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
  * @param parameters - initial value template item parameters
  * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
  */
  parameters(parameters) {
    return this.clone({ parameters });
  }
  /** Get initial value template item template parameters
  * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
  */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
  */
  serialize() {
    let { path = [], index, hint } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { spec, _context } = this;
    const { templates } = _context;
    if (typeof spec.id !== "string" || !spec.id) {
      throw new SerializeError("`id` is required for initial value template item nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!spec.templateId) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const template = templates.find((t) => t.id === spec.templateId);
    if (!template) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return { id: spec.id, templateId: spec.id, schemaType: template.schemaType, type: "initialValueTemplateItem", description: spec.description || template.description, title: spec.title || template.title, subtitle: spec.subtitle, icon: spec.icon || template.icon, initialDocumentId: spec.initialDocumentId, parameters: spec.parameters };
  }
  /** Clone generic view builder (allows for options overriding)
  * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
  * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
  */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const builder = new _InitialValueTemplateItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec };
    return builder;
  }
};
function defaultInitialValueTemplateItems(context) {
  const { schema: schema2, getStructureBuilder, templates } = context;
  const typeNames = schema2.getTypeNames();
  const ordered = templates.filter((tpl) => {
    var _a2;
    return !((_a2 = tpl.parameters) == null ? void 0 : _a2.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType));
  return ordered.map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({ path, index }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const { schema: schema2, templates } = context;
  return templateItems.map((item) => {
    const template = templates.find((t) => t.id === item.templateId);
    const title = item.title || (template == null ? void 0 : template.title) || "Create";
    const params = {};
    if (template && template.schemaType) {
      params.type = template.schemaType;
    }
    if (item.templateId) {
      params.template = item.templateId;
    }
    const intentParams = item.parameters ? [params, item.parameters] : params;
    const schemaType = template && schema2.get(template.schemaType);
    const i18n = item.i18n || (template == null ? void 0 : template.i18n);
    let builder = new MenuItemBuilder(context).title(title).icon(template && template.icon || (schemaType == null ? void 0 : schemaType.icon) || AddIcon).intent({ type: "create", params: intentParams });
    if (i18n) {
      builder = builder.i18n(i18n);
    }
    return builder.serialize();
  });
}
function noChildResolver() {
  return void 0;
}
var shallowIntentChecker = (intentName, params, _ref93) => {
  let { pane, index } = _ref93;
  return index <= 1 && defaultIntentChecker(intentName, params, { pane, index });
};
var GenericListBuilder = class {
  constructor() {
    this.initialValueTemplatesSpecified = false;
    this.spec = {};
  }
  /** Set generic list ID
  * @param id - generic list ID
  * @returns generic list builder based on ID provided.
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic list ID
  * @returns generic list ID
  */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
  * @param title - generic list title
  * @returns generic list builder based on title and ID provided.
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get generic list title
  * @returns generic list title
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set generic list layout
  * @param defaultLayout - generic list layout key.
  * @returns generic list builder based on layout provided.
  */
  defaultLayout(defaultLayout) {
    return this.clone({ defaultLayout });
  }
  /** Get generic list layout
  * @returns generic list layout
  */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
  * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
  * @returns generic list builder based on menu items provided.
  */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get generic list menu items
  * @returns generic list menu items
  */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
  * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
  * @returns generic list builder based on menu item groups provided.
  */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get generic list menu item groups
  * @returns generic list menu item groups
  */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
  * @param child - generic list child. See {@link Child}
  * @returns generic list builder based on child provided (clone).
  */
  child(child) {
    return this.clone({ child });
  }
  /** Get generic list child
  * @returns generic list child
  */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
  * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
  * @returns generic list builder based on can handle intent provided.
  */
  canHandleIntent(canHandleIntent) {
    return this.clone({ canHandleIntent });
  }
  /** Get generic list can handle intent
  * @returns generic list can handle intent
  */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
  * @param enabled - allow / disallow for showing icons
  * @returns generic list builder based on display options (showIcons) provided.
  */
  showIcons() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({ displayOptions: { ...this.spec.displayOptions || {}, showIcons: enabled } });
  }
  /** Get generic list display options
  * @returns generic list display options (specifically showIcons)
  */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
  * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
  * @returns generic list builder based on templates provided.
  */
  initialValueTemplates(templates) {
    this.initialValueTemplatesSpecified = true;
    return this.clone({ initialValueTemplates: Array.isArray(templates) ? templates : [templates] });
  }
  /** Get generic list initial value templates
  * @returns generic list initial value templates
  */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns generic list object based on path provided in options. See {@link GenericList}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const id = this.spec.id || "";
    const path = options.path;
    const defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout)) {
      throw new SerializeError("`layout` must be one of ".concat(layoutOptions.map((item) => '"'.concat(item, '"')).join(", ")), path, id || options.index, this.spec.title);
    }
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map((item, i) => maybeSerializeInitialValueTemplateItem(item, i, path));
    return { id: validateId(id, options.path, id || options.index), title: this.spec.title, i18n: this.spec.i18n, type: "genericList", defaultLayout, child: this.spec.child || noChildResolver, canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker, displayOptions: this.spec.displayOptions, initialValueTemplates, menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, path)), menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, path)) };
  }
};
var validateFilter = (spec, options) => {
  var _a2;
  const filter = ((_a2 = spec.options) == null ? void 0 : _a2.filter.trim()) || "";
  if (["*", "{"].includes(filter[0])) {
    throw new SerializeError("`filter` cannot start with `".concat(filter[0], "` - looks like you are providing a query, not a filter"), options.path, spec.id, spec.title).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  }
  return filter;
};
var createDocumentChildResolverForItem = (context) => (itemId, options) => {
  var _a2;
  const parentItem = options.parent;
  const template = ((_a2 = options.params) == null ? void 0 : _a2.template) ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0;
  const type = template ? template.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then((schemaType) => schemaType ? context.resolveDocumentNode({ schemaType, documentId: itemId }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType(""));
};
var DocumentListBuilder = class _DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    this.spec = spec || {};
    this.initialValueTemplatesSpecified = Boolean(spec == null ? void 0 : spec.initialValueTemplates);
  }
  /** Set API version
  * @param apiVersion - API version
  * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
  */
  apiVersion(apiVersion) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, apiVersion } });
  }
  /** Get API version
  * @returns API version
  */
  getApiVersion() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.apiVersion;
  }
  /** Set Document list filter
  * @param filter - filter
  * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
  */
  filter(filter) {
    return this.clone({ options: { ...this.spec.options || {}, filter } });
  }
  /** Get Document list filter
  * @returns filter
  */
  getFilter() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.filter;
  }
  /** Set Document list schema type name
  * @param type - schema type name.
  * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
  */
  schemaType(type) {
    const schemaTypeName = typeof type === "string" ? type : type.name;
    return this.clone({ schemaTypeName });
  }
  /** Get Document list schema type name
  * @returns schema type name
  */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
  * @param params - parameters
  * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
  */
  params(params) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, params } });
  }
  /** Get Document list options' parameters
  * @returns options
  */
  getParams() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.params;
  }
  /** Set Document list default ordering
  * @param ordering - default sort ordering array. See {@link SortOrderingItem}
  * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
  */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering)) {
      throw new Error("`defaultOrdering` must be an array of order clauses");
    }
    return this.clone({ options: { ...this.spec.options || { filter: "" }, defaultOrdering: ordering } });
  }
  /** Get Document list default ordering
  * @returns default ordering. See {@link SortOrderingItem}
  */
  getDefaultOrdering() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.defaultOrdering;
  }
  /** Serialize Document list
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns document list object based on path provided in options. See {@link DocumentList}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    var _a2;
    if (typeof this.spec.id !== "string" || !this.spec.id) {
      throw new SerializeError("`id` is required for document lists", options.path, options.index, this.spec.title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!this.spec.options || !this.spec.options.filter) {
      throw new SerializeError("`filter` is required for document lists", options.path, this.spec.id, this.spec.title).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    }
    const hasSimpleFilter = ((_a2 = this.spec.options) == null ? void 0 : _a2.filter) === "_type == $type";
    if (!hasSimpleFilter && this.spec.options.filter && !this.spec.options.apiVersion) {
      console.warn("No apiVersion specified for document type list with custom filter: `".concat(this.spec.options.filter, "`. This will be required in the future. See %s for more info."), generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER));
    }
    return { ...super.serialize(options), type: "documentList", schemaTypeName: this.spec.schemaTypeName, child: this.spec.child || createDocumentChildResolverForItem(this._context), options: {
      ...this.spec.options,
      // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
      apiVersion: this.spec.options.apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
      filter: validateFilter(this.spec, options)
    } };
  }
  /** Clone Document list builder (allows for options overriding)
  * @param withSpec - override document list spec. See {@link PartialDocumentList}
  * @returns document list builder. See {@link DocumentListBuilder}
  */
  clone(withSpec) {
    const builder = new _DocumentListBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    if (!this.initialValueTemplatesSpecified) {
      builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec);
    }
    if (!builder.spec.schemaTypeName) {
      builder.spec.schemaTypeName = inferTypeName(builder.spec);
    }
    return builder;
  }
  /** Get Document list spec
  * @returns document list spec. See {@link PartialDocumentList}
  */
  getSpec() {
    return this.spec;
  }
};
function inferInitialValueTemplates(context, spec) {
  const { document: document2 } = context;
  const { schemaTypeName, options } = spec;
  const { filter, params } = options || { filter: "", params: {} };
  const typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter, params)));
  if (typeNames.length === 0) {
    return void 0;
  }
  return typeNames.flatMap((schemaType) => document2.resolveNewDocumentOptions({ type: "structure", schemaType })).map((option) => ({ ...option, icon: AddIcon }));
}
function inferTypeName(spec) {
  const { options } = spec;
  const { filter, params } = options || { filter: "", params: {} };
  const typeNames = getTypeNamesFromFilter(filter, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let typeNames = getTypeNamesFromEqualityFilter(filter, params);
  if (typeNames.length === 0) {
    typeNames = getTypeNamesFromInTypesFilter(filter, params);
  }
  return typeNames;
}
function getTypeNamesFromEqualityFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
  const matches = [];
  let match;
  while ((match = pattern.exec(filter)) !== null) {
    matches.push(match[1] || match[2]);
  }
  return matches.map((candidate) => {
    const typeName = candidate[0] === "$" ? params[candidate.slice(1)] : candidate;
    const normalized = (typeName || "").trim().replace(/^["']|["']$/g, "");
    return normalized;
  }).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pattern = /\b_type\s+in\s+\[(.*?)\]/;
  const matches = filter.match(pattern);
  if (!matches) {
    return [];
  }
  return matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean);
}
var getArgType = (thing) => {
  if (thing instanceof ListBuilder) {
    return "ListBuilder";
  }
  if (isPromise(thing)) {
    return "Promise";
  }
  return Array.isArray(thing) ? "array" : typeof thing;
};
var isListItem = (item) => {
  return item.type === "listItem";
};
var defaultCanHandleIntent = (intentName, params, context) => {
  const pane = context.pane;
  const items = pane.items || [];
  return items.filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context);
};
var resolveChildForItem = (itemId, options) => {
  const parentItem = options.parent;
  const items = parentItem.items.filter(isListItem);
  const target = (items.find((item) => item.id === itemId) || { child: void 0 }).child;
  if (!target || typeof target !== "function") {
    return target;
  }
  return typeof target === "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder) {
    return item.serialize({ path, index });
  }
  const listItem = item;
  if (listItem && listItem.type === "divider") {
    return item;
  }
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem);
    const helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError('List items must be of type "listItem", got "'.concat(gotWhat, '"').concat(helpText), path, index).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord$4(thing) && typeof thing.then === "function";
}
var ListBuilder = class _ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    this.spec = spec ? spec : {};
    this.initialValueTemplatesSpecified = Boolean(spec && spec.initialValueTemplates);
  }
  /**
  * Set list builder based on items provided
  * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
  * @returns list builder based on items provided. See {@link ListBuilder}
  */
  items(items) {
    return this.clone({ items });
  }
  /** Get list builder items
  * @returns list items. See {@link BuildableList}
  */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns list based on path in options. See {@link List}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const id = this.spec.id;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for lists", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const items = typeof this.spec.items === "undefined" ? [] : this.spec.items;
    if (!Array.isArray(items)) {
      throw new SerializeError("`items` must be an array of items", options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    }
    const path = (options.path || []).concat(id);
    const serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path));
    const dupes = serializedItems.filter((val, i) => (0, import_find2.default)(serializedItems, { id: val.id }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5);
      const dupeDesc = dupes.length > 5 ? "".concat(dupeIds.join(", "), "...") : dupeIds.join(", ");
      throw new SerializeError("List items with same ID found (".concat(dupeDesc, ")"), options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return { ...super.serialize(options), type: "list", canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent, child: this.spec.child || resolveChildForItem, items: serializedItems };
  }
  /**
  * Clone list builder and return new list builder based on context and spec provided
  * @param withSpec - list options. See {@link BuildableList}
  * @returns new list builder based on context and spec provided. See {@link ListBuilder}
  */
  clone(withSpec) {
    const builder = new _ListBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var ListItemBuilder = class _ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Set list item ID
  * @returns list item builder based on ID provided. See {@link ListItemBuilder}
  */
  id(id) {
    return this.clone({ id });
  }
  /**
  * Get list item ID
  * @returns list item ID. See {@link PartialListItem}
  */
  getId() {
    return this.spec.id;
  }
  /**
  * Set list item title
  * @returns list item builder based on title provided. See {@link ListItemBuilder}
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /**
  * Get list item title
  * @returns list item title. See {@link PartialListItem}
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /**
  * Set list item icon
  * @returns list item builder based on icon provided. See {@link ListItemBuilder}
  */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
  * Set if list item should show icon
  * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
  */
  showIcon() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({ displayOptions: { ...this.spec.displayOptions || {}, showIcon: enabled } });
  }
  /**
  * Check if list item should show icon
  * @returns true if it should show the icon, false if not, undefined if not set
  */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
  *Get list item icon
  * @returns list item icon. See {@link PartialListItem}
  */
  getIcon() {
    return this.spec.icon;
  }
  /**
  * Set list item child
  * @param child - list item child. See {@link UnserializedListItemChild}
  * @returns list item builder based on child provided. See {@link ListItemBuilder}
  */
  child(child) {
    return this.clone({ child });
  }
  /**
  * Get list item child
  * @returns list item child. See {@link PartialListItem}
  */
  getChild() {
    return this.spec.child;
  }
  /**
  * Set list item schema type
  * @param schemaType - list item schema type. See {@link SchemaType}
  * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
  */
  schemaType(schemaType) {
    return this.clone({ schemaType });
  }
  /**
  * Get list item schema type
  * @returns list item schema type. See {@link PartialListItem}
  */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      return this._context.schema.get(schemaType);
    }
    return this.spec.schemaType;
  }
  /** Serialize list item builder
  * @param options - serialization options. See {@link ListItemSerializeOptions}
  * @returns list item node based on path provided in options. See {@link ListItem}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { id, title, child } = this.spec;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for list items", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options.titleIsOptional && (typeof title !== "string" || !title)) {
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    let schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      const type = this._context.schema.get(schemaType);
      if (!type) {
        throw new SerializeError('Could not find type "'.concat(schemaType, '" in schema'), options.path, id).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      }
      schemaType = type;
    }
    const serializeOptions = { path: options.path.concat(id), hint: "child" };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild === "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => {
        return originalChild(itemId, { ...childOptions, serializeOptions });
      };
    }
    return { ...this.spec, id: validateId(id, options.path, options.index), schemaType, child: listChild, title, type: "listItem" };
  }
  /** Clone list item builder
  * @param withSpec - partial list item options. See {@link PartialListItem}
  * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
  */
  clone(withSpec) {
    const builder = new _ListItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType === "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({ schemaType, documentId }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
var DocumentListItemBuilder = class _DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec);
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Serialize document list item
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns document list item object based on path provided in options. See {@link DocumentListItem}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const spec = super.serialize({ ...options, titleIsOptional: true });
    if (!spec.schemaType) {
      throw new SerializeError("`schemaType` is required for document list items", options.path, options.index).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    }
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return { ...spec, child, schemaType: spec.schemaType, _id: spec.id };
  }
  /** Clone Document list item builder (allows for options overriding)
  * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
  * @returns document list item builder. See {@link DocumentListItemBuilder}
  */
  clone(withSpec) {
    const builder = new _DocumentListItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
function isDocumentListItem(item) {
  return isRecord$4(item) && typeof item.schemaType !== "undefined" && typeof item._id === "string";
}
var DocumentTypeListBuilder = class _DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context);
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Set Document type list child
  * @param child - Child component. See {@link Child}
  * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
  */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({ child });
  }
  /** Clone Document type list builder (allows for options overriding)
  * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
  * @returns document type list builder. See {@link DocumentTypeListBuilder}
  */
  clone(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new _DocumentTypeListBuilder(this._context);
    builder.spec = { ...this.spec, ...parent.getSpec(), ...withSpec || {} };
    return builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
  * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
  * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
  */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new _DocumentTypeListBuilder(this._context);
    const canHandleIntent = this.spec.canHandleIntent;
    const shouldOverride = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER;
    const override = shouldOverride ? { canHandleIntent: void 0 } : {};
    builder.spec = { ...parent.getSpec(), ...this.spec, ...withSpec || {}, ...override };
    return builder;
  }
};
function shouldShowIcon(schemaType) {
  const preview = schemaType.preview;
  return Boolean(preview && (preview.prepare || preview.select && preview.select.media));
}
var BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a2;
  return ((_a2 = schemaType.type) == null ? void 0 : _a2.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes(_ref94) {
  let { schema: schema2 } = _ref94;
  return schema2.getTypeNames().filter((n) => {
    const schemaType = schema2.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter((n) => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  const types = getDocumentTypes(context);
  return types.map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const { schema: schema2 } = context;
  const type = schema2.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || (0, import_startCase2.default)(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent;
    const parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    if (parentItem && parentItem.title) {
      list = list.title(parentItem.title);
    }
    return list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const { schema: schema2, resolveDocumentNode } = context;
  const schemaType = typeof typeNameOrSpec === "string" ? typeNameOrSpec : typeNameOrSpec.schemaType;
  const typeName = typeof schemaType === "string" ? schemaType : schemaType.name;
  const spec = typeof typeNameOrSpec === "string" ? { schemaType } : typeNameOrSpec;
  const type = schema2.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || (0, import_startCase2.default)(typeName);
  const showIcons = shouldShowIcon(type);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({ type: typeName }).schemaType(type).showIcons(showIcons).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{ id: "sorting", title: "Sort", i18n: { title: { key: "menu-item-groups.actions-group", ns: structureLocaleNamespace } } }, { id: "layout", title: "Layout", i18n: { title: { key: "menu-item-groups.layout-group", ns: structureLocaleNamespace } } }, { id: "actions", title: "Actions", i18n: { title: { key: "menu-item-groups.sorting-group", ns: structureLocaleNamespace } } }]).child(spec.child || ((documentId) => resolveDocumentNode({ schemaType: typeName, documentId }))).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(spec.menuItems || [
    // Create new (from action button) will be added in serialization step of GenericList
    // Sort by <Y>
    ...getOrderingMenuItemsForSchemaType(context, type),
    // Display as <Z>
    new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.compact-view", ns: structureLocaleNamespace } }).title("Compact view").icon(StackCompactIcon).action("setLayout").params({ layout: "default" }),
    new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.detailed-view", ns: structureLocaleNamespace } }).title("Detailed view").icon(StackIcon).action("setLayout").params({ layout: "detail" })
    // Create new (from menu) will be added in serialization step of GenericList
  ]);
}
function hasIcon(schemaType) {
  if (!schemaType || typeof schemaType === "string") {
    return false;
  }
  return Boolean(schemaType.icon);
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").i18n({ title: { key: "default-definition.content-title", ns: structureLocaleNamespace } }).items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder(_ref95) {
  let { defaultDocumentNode, source } = _ref95;
  const configContext = getConfigContextFromSource(source);
  const context = { ...source, getStructureBuilder: () => structureBuilder, resolveDocumentNode: (options) => {
    let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, { ...options, ...configContext })) || new DocumentBuilder(context);
    if (!builder.getId()) {
      builder = builder.id("documentEditor");
    }
    if (options.documentId) {
      builder = builder.documentId(getPublishedId(options.documentId));
    }
    return builder.schemaType(options.schemaType);
  } };
  const structureBuilder = { defaults: () => getDefaultStructure(context), documentTypeList: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return getDocumentTypeList(context, ...args);
  }, documentTypeListItem: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return getDocumentTypeListItem(context, ...args);
  }, documentTypeListItems: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return getDocumentTypeListItems(context, ...args);
  }, document: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return new DocumentBuilder(context, ...args);
  }, documentWithInitialValueTemplate: function() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return documentFromEditorWithInitialValue(context, ...args);
  }, defaultDocument: context.resolveDocumentNode, list: function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return new ListBuilder(context, ...args);
  }, listItem: function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return new ListItemBuilder(context, ...args);
  }, menuItem: function() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return new MenuItemBuilder(context, ...args);
  }, menuItemGroup: function() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return new MenuItemGroupBuilder(context, ...args);
  }, menuItemsFromInitialValueTemplateItems: function() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return menuItemsFromInitialValueTemplateItems(context, ...args);
  }, documentList: function() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return new DocumentListBuilder(context, ...args);
  }, documentListItem: function() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return new DocumentListItemBuilder(context, ...args);
  }, orderingMenuItem: function() {
    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      args[_key13] = arguments[_key13];
    }
    return getOrderingMenuItem(context, ...args);
  }, orderingMenuItemsForType: function() {
    for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
      args[_key14] = arguments[_key14];
    }
    return getOrderingMenuItemsForSchemaType(context, ...args);
  }, editor: function() {
    for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
      args[_key15] = arguments[_key15];
    }
    return documentFromEditor(context, ...args);
  }, defaultInitialValueTemplateItems: function() {
    for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
      args[_key16] = arguments[_key16];
    }
    return defaultInitialValueTemplateItems(context, ...args);
  }, initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, { id: templateId, parameters, templateId }), component: (spec) => {
    return (0, import_react_is2.isValidElementType)(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec);
  }, divider: () => ({ id: (0, import_uniqueId.default)("__divider__"), type: "divider" }), view: views, context };
  return structureBuilder;
}
function StructureToolProvider(_ref96) {
  let { defaultDocumentNode, structure: resolveStructure, children } = _ref96;
  const [layoutCollapsed, setLayoutCollapsed] = (0, import_react2.useState)(false);
  const source = useSource();
  const configContext = useConfigContextFromSource(source);
  const documentStore = useDocumentStore();
  const S = (0, import_react2.useMemo)(() => {
    return createStructureBuilder({ defaultDocumentNode, source });
  }, [defaultDocumentNode, source]);
  const rootPaneNode = (0, import_react2.useMemo)(() => {
    if (resolveStructure)
      return resolveStructure(S, { ...configContext, documentStore });
    return S.defaults();
  }, [S, resolveStructure, configContext, documentStore]);
  const features = (0, import_react2.useMemo)(() => ({ backButton: layoutCollapsed, resizablePanes: !layoutCollapsed, reviewChanges: !layoutCollapsed, splitPanes: !layoutCollapsed, splitViews: !layoutCollapsed }), [layoutCollapsed]);
  const structureTool2 = (0, import_react2.useMemo)(() => {
    return { features, layoutCollapsed, setLayoutCollapsed, rootPaneNode, structureContext: S.context };
  }, [features, layoutCollapsed, rootPaneNode, S.context]);
  return (0, import_jsx_runtime2.jsx)(StructureToolContext.Provider, { value: structureTool2, children });
}
function ErrorPane(props) {
  const { children, currentMinWidth, flex, minWidth, paneKey, title = "Error", tone = "critical" } = props;
  return (0, import_jsx_runtime2.jsxs)(Pane, { currentMinWidth, flex, id: paneKey, minWidth, tone, children: [(0, import_jsx_runtime2.jsx)(PaneHeader, { title }), (0, import_jsx_runtime2.jsx)(PaneContent, { overflow: "auto", children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 5, children }) })] });
}
function getWaitMessages(path) {
  const thresholds = [{ ms: 300, messageKey: "panes.resolving.default-message" }, { ms: 5e3, messageKey: "panes.resolving.slow-resolve-message" }];
  if (isDev) {
    const message = ["Check console for errors?", "Is your observable/promise resolving?", path.length > 0 ? "Structure path: ".concat(path.join(" ➝ ")) : ""];
    thresholds.push({ ms: 1e4, message: message.join("\n") });
  }
  const src = of(null);
  return merge(...thresholds.map((threshold) => src.pipe(mapTo("messageKey" in threshold ? { messageKey: threshold.messageKey } : { message: threshold.message }), delay(threshold.ms))));
}
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", { value: __freeze$7(raw || cooked.slice()) }));
var _a$7;
var DEFAULT_MESSAGE_KEY = "panes.resolving.default-message";
var Content = ut(Flex)(_a$7 || (_a$7 = __template$7(["\n  opacity: 0;\n  transition: opacity 200ms;\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n"])));
var LoadingPane = (0, import_react2.memo)((props) => {
  const { delay: delay2 = 300, flex, message: messageProp = getWaitMessages, minWidth, paneKey, path, selected, title, tone } = props;
  const { t } = useTranslation2(structureLocaleNamespace);
  const resolvedMessage = (0, import_react2.useMemo)(() => {
    if (typeof messageProp === "function") {
      return messageProp(path ? path.split(";") : []);
    }
    return messageProp;
  }, [messageProp, path]);
  const [currentMessage, setCurrentMessage] = (0, import_react2.useState)(() => {
    if (typeof resolvedMessage === "string")
      return resolvedMessage;
    return DEFAULT_MESSAGE_KEY;
  });
  (0, import_react2.useEffect)(() => {
    if (typeof resolvedMessage !== "object")
      return void 0;
    if (typeof resolvedMessage.subscribe === "function")
      return void 0;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, [resolvedMessage, t]);
  const [contentElement, setContentElement] = (0, import_react2.useState)(null);
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    if (!contentElement)
      return void 0;
    return _raf2(() => setMounted(true));
  }, [contentElement]);
  const content = (0, import_jsx_runtime2.jsx)(Content, { align: "center", "data-mounted": mounted ? "" : void 0, direction: "column", height: "fill", justify: "center", ref: setContentElement, children: (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true, title: title || currentMessage }) });
  return (0, import_jsx_runtime2.jsx)(Pane, { flex, id: paneKey, minWidth, selected, tone, children: (0, import_jsx_runtime2.jsx)(PaneContent, { children: content }) });
});
LoadingPane.displayName = "LoadingPane";
var isSanityDocument2 = (value) => isRecord$4(value) && typeof value._id === "string" && typeof value._type === "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = (0, import_react2.useState)(void 0);
  const [error, setError] = (0, import_react2.useState)(null);
  const { resolveProductionUrl } = useSource().document;
  const value$ = useAsObservable(value);
  if (error)
    throw error;
  (0, import_react2.useEffect)(() => {
    value$.pipe(
      // this so that the preview URL isn't fetched on every keystroke
      debounceTime(500),
      switchMap((document2) => isSanityDocument2(document2) ? from(resolveProductionUrl({ document: document2 })) : of(void 0)),
      catchError((e2) => {
        const message = isRecord$4(e2) && typeof e2.message === "string" ? e2.message : "Unknown error";
        throw new Error("An error was thrown while trying to get your preview url: ".concat(message));
      })
    ).subscribe({ next: setPreviewUrl, error: setError });
  }, [resolveProductionUrl, value$]);
  return previewUrl;
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {};
  const structureNodeTemplate = opts.templateName;
  if (opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate) {
    console.warn('Conflicting templates: URL says "'.concat(opts.urlTemplate, '", structure node says "').concat(structureNodeTemplate, '". Using "').concat(structureNodeTemplate, '".'));
  }
  const template = structureNodeTemplate || opts.urlTemplate;
  const typeTemplates = templates.filter((t) => t.schemaType === opts.documentType);
  const templateParams = { ...opts.templateParams, ...typeof payload === "object" ? payload || {} : {} };
  let templateName = template;
  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }
  return { templateName, templateParams };
}
var DocumentPaneProvider = (0, import_react2.memo)((props) => {
  const { children, index, pane, paneKey, onFocusPath } = props;
  const schema2 = useSchema();
  const templates = useTemplates();
  const { actions: documentActions2, badges: documentBadges2, unstable_fieldActions: fieldActionsResolver, unstable_languageFilter: languageFilterResolver, inspectors: inspectorsResolver } = useSource().document;
  const presenceStore = usePresenceStore();
  const paneRouter = usePaneRouter();
  const setPaneParams = paneRouter.setParams;
  const { features } = useStructureTool();
  const { push: pushToast } = useToast();
  const { options, menuItemGroups = DEFAULT_MENU_ITEM_GROUPS, title = null, views: viewsProp = [] } = pane;
  const paneOptions = useUnique(options);
  const documentIdRaw = paneOptions.id;
  const documentId = getPublishedId(documentIdRaw);
  const documentType = options.type;
  const params = useUnique(paneRouter.params) || EMPTY_PARAMS;
  const panePayload = useUnique(paneRouter.payload);
  const { templateName, templateParams } = (0, import_react2.useMemo)(() => getInitialValueTemplateOpts(templates, { documentType, templateName: paneOptions.template, templateParams: paneOptions.templateParameters, panePayload, urlTemplate: params.template }), [documentType, paneOptions, params, panePayload, templates]);
  const initialValueRaw = useInitialValue({ documentId, documentType, templateName, templateParams });
  const initialValue = useUnique(initialValueRaw);
  const { patch } = useDocumentOperation(documentId, documentType);
  const editState = useEditState(documentId, documentType);
  const { validation: validationRaw } = useValidationStatus(documentId, documentType);
  const connectionState = useConnectionState(documentId, documentType);
  const schemaType = schema2.get(documentType);
  const value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value;
  const [isDeleting, setIsDeleting] = (0, import_react2.useState)(false);
  const actions = (0, import_react2.useMemo)(() => documentActions2({ schemaType: documentType, documentId }), [documentActions2, documentId, documentType]);
  const badges = (0, import_react2.useMemo)(() => documentBadges2({ schemaType: documentType, documentId }), [documentBadges2, documentId, documentType]);
  const languageFilter = (0, import_react2.useMemo)(() => languageFilterResolver({ schemaType: documentType, documentId }), [documentId, documentType, languageFilterResolver]);
  const validation = useUnique(validationRaw);
  const views2 = useUnique(viewsProp);
  const [focusPath, setFocusPath] = (0, import_react2.useState)(() => params.path ? fromString(params.path) : EMPTY_ARRAY$9);
  const focusPathRef = (0, import_react2.useRef)(focusPath);
  const activeViewId = params.view || views2[0] && views2[0].id || null;
  const [timelineMode, setTimelineMode] = (0, import_react2.useState)("closed");
  const [timelineError, setTimelineError] = (0, import_react2.useState)(null);
  const timelineStore = useTimelineStore({ documentId, documentType, onError: setTimelineError, rev: params.rev, since: params.since });
  const onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime);
  const sinceAttributes = useTimelineSelector(timelineStore, (state2) => state2.sinceAttributes);
  const timelineDisplayed = useTimelineSelector(timelineStore, (state2) => state2.timelineDisplayed);
  const timelineReady = useTimelineSelector(timelineStore, (state2) => state2.timelineReady);
  const isPristine = useTimelineSelector(timelineStore, (state2) => state2.isPristine);
  const isDeleted = (0, import_react2.useMemo)(() => {
    if (!timelineReady) {
      return false;
    }
    return Boolean(!(editState == null ? void 0 : editState.draft) && !(editState == null ? void 0 : editState.published)) && !isPristine;
  }, [editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, isPristine, timelineReady]);
  const previewUrl = usePreviewUrl(value);
  const [presence, setPresence] = (0, import_react2.useState)([]);
  (0, import_react2.useEffect)(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors2 = (0, import_react2.useMemo)(() => inspectorsResolver({ documentId, documentType }), [documentId, documentType, inspectorsResolver]);
  const [inspectorName, setInspectorName] = (0, import_react2.useState)(() => params.inspect || null);
  const inspectParamRef = (0, import_react2.useRef)(params.inspect);
  (0, import_react2.useEffect)(() => {
    if (inspectParamRef.current !== params.inspect) {
      inspectParamRef.current = params.inspect;
      setInspectorName(params.inspect || null);
    }
  }, [params.inspect]);
  const currentInspector = inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === inspectorName);
  const resolvedChangesInspector = inspectors2.find((i) => i.name === HISTORY_INSPECTOR_NAME);
  const changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME;
  const { t } = useTranslation2(structureLocaleNamespace);
  const inspectOpen = params.inspect === "on";
  const compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null;
  const fieldActions = (0, import_react2.useMemo)(() => schemaType ? fieldActionsResolver({ documentId, documentType, schemaType }) : [], [documentId, documentType, fieldActionsResolver, schemaType]);
  const ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError);
  const displayed = (0, import_react2.useMemo)(() => onOlderRevision ? timelineDisplayed || { _id: value._id, _type: value._type } : value, [onOlderRevision, timelineDisplayed, value]);
  const setTimelineRange = (0, import_react2.useCallback)((newSince, newRev) => {
    setPaneParams({ ...params, since: newSince, rev: newRev || void 0 });
  }, [params, setPaneParams]);
  const handleFocus = (0, import_react2.useCallback)((nextFocusPath) => {
    setFocusPath(nextFocusPath);
    if (focusPathRef.current !== nextFocusPath) {
      focusPathRef.current = nextFocusPath;
      onFocusPath == null ? void 0 : onFocusPath(nextFocusPath);
    }
    presenceStore.setLocation([{ type: "document", documentId, path: nextFocusPath, lastActiveAt: (/* @__PURE__ */ new Date()).toISOString() }]);
  }, [documentId, onFocusPath, presenceStore, setFocusPath]);
  const handleBlur = (0, import_react2.useCallback)((blurredPath) => {
    if (disableBlurRef.current) {
      return;
    }
    setFocusPath(EMPTY_ARRAY$9);
    if (focusPathRef.current !== EMPTY_ARRAY$9) {
      focusPathRef.current = EMPTY_ARRAY$9;
      onFocusPath == null ? void 0 : onFocusPath(EMPTY_ARRAY$9);
    }
  }, [onFocusPath, setFocusPath]);
  const patchRef = (0, import_react2.useRef)(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = (0, import_react2.useCallback)((event) => patchRef.current(event), []);
  const closeInspector = (0, import_react2.useCallback)((closeInspectorName) => {
    var _a2, _b2, _c2, _d2;
    const inspector = closeInspectorName && inspectors2.find((i) => i.name === closeInspectorName);
    if (closeInspectorName && !inspector) {
      console.warn('No inspector named "'.concat(closeInspectorName, '"'));
      return;
    }
    if (!currentInspector) {
      return;
    }
    if (inspector) {
      const result = (_b2 = (_a2 = inspector.onClose) == null ? void 0 : _a2.call(inspector, { params })) != null ? _b2 : { params };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({ ...result.params, inspect: void 0 });
      return;
    }
    if (currentInspector) {
      const result = (_d2 = (_c2 = currentInspector.onClose) == null ? void 0 : _c2.call(currentInspector, { params })) != null ? _d2 : { params };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({ ...result.params, inspect: void 0 });
    }
  }, [currentInspector, inspectors2, params, setPaneParams]);
  const openInspector = (0, import_react2.useCallback)((nextInspectorName, paneParams) => {
    var _a2, _b2, _c2, _d2;
    const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
    if (!nextInspector) {
      console.warn('No inspector named "'.concat(nextInspectorName, '"'));
      return;
    }
    if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
      setPaneParams({ ...params, ...paneParams, inspect: nextInspector.name });
      return;
    }
    let currentParams = params;
    if (currentInspector) {
      const closeResult = (_b2 = (_a2 = nextInspector.onClose) == null ? void 0 : _a2.call(nextInspector, { params: currentParams })) != null ? _b2 : { params: currentParams };
      currentParams = closeResult.params;
    }
    const result = (_d2 = (_c2 = nextInspector.onOpen) == null ? void 0 : _c2.call(nextInspector, { params: currentParams })) != null ? _d2 : { params: currentParams };
    setInspectorName(nextInspector.name);
    inspectParamRef.current = nextInspector.name;
    setPaneParams({ ...result.params, ...paneParams, inspect: nextInspector.name });
  }, [currentInspector, inspectors2, params, setPaneParams]);
  const handleHistoryClose = (0, import_react2.useCallback)(() => {
    if (resolvedChangesInspector) {
      closeInspector(resolvedChangesInspector.name);
    }
  }, [closeInspector, resolvedChangesInspector]);
  const handleHistoryOpen = (0, import_react2.useCallback)(() => {
    if (!features.reviewChanges) {
      return;
    }
    if (resolvedChangesInspector) {
      openInspector(resolvedChangesInspector.name);
    }
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]);
  const handlePaneClose = (0, import_react2.useCallback)(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = (0, import_react2.useCallback)(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleLegacyInspect = (0, import_react2.useCallback)(function() {
    let toggle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !inspectOpen;
    if (toggle) {
      setPaneParams({ ...params, inspect: "on" });
    } else {
      setPaneParams((0, import_omit2.default)(params, "inspect"));
    }
  }, [inspectOpen, params, setPaneParams]);
  const handleMenuAction = (0, import_react2.useCallback)((item) => {
    if (item.action === "production-preview" && previewUrl) {
      window.open(previewUrl);
      return true;
    }
    if (item.action === "inspect") {
      toggleLegacyInspect(true);
      return true;
    }
    if (item.action === "reviewChanges") {
      handleHistoryOpen();
      return true;
    }
    if (typeof item.action === "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
      const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length);
      const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
      if (nextInspector) {
        if (nextInspector.name === inspectorName) {
          closeInspector(nextInspector.name);
        } else {
          openInspector(nextInspector.name);
        }
        return true;
      }
    }
    return false;
  }, [closeInspector, handleHistoryOpen, inspectorName, inspectors2, openInspector, previewUrl, toggleLegacyInspect]);
  const handleLegacyInspectClose = (0, import_react2.useCallback)(() => toggleLegacyInspect(false), [toggleLegacyInspect]);
  const [openPath, onSetOpenPath] = (0, import_react2.useState)([]);
  const [fieldGroupState, onSetFieldGroupState] = (0, import_react2.useState)();
  const [collapsedPaths, onSetCollapsedPath] = (0, import_react2.useState)();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = (0, import_react2.useState)();
  const handleOnSetCollapsedPath = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = (0, import_react2.useCallback)((path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)), []);
  const requiredPermission = value._createdAt ? "update" : "create";
  const liveEdit = Boolean(schemaType == null ? void 0 : schemaType.liveEdit);
  const docId = value._id ? value._id : "dummy-id";
  const docPermissionsInput = (0, import_react2.useMemo)(() => {
    return { ...value, _id: liveEdit ? getPublishedId(docId) : getDraftId(docId) };
  }, [liveEdit, value, docId]);
  const [permissions, isPermissionsLoading] = useDocumentValuePermissions({ document: docPermissionsInput, permission: requiredPermission });
  const isNonExistent = !(value == null ? void 0 : value._id);
  const readOnly = (0, import_react2.useMemo)(() => {
    var _a2;
    const hasNoPermission = !isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted);
    const updateActionDisabled = !isActionEnabled(schemaType, "update");
    const createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create");
    const reconnecting = connectionState === "reconnecting";
    const isLocked = (_a2 = editState.transactionSyncLock) == null ? void 0 : _a2.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked || isDeleting || isDeleted;
  }, [connectionState, editState.transactionSyncLock, isNonExistent, isDeleted, isDeleting, isPermissionsLoading, permissions == null ? void 0 : permissions.granted, ready, revTime, schemaType]);
  const formState = useFormState(schemaType, { value: displayed, readOnly, comparisonValue: compareValue, focusPath, openPath, collapsedPaths, presence, validation, collapsedFieldSets, fieldGroupState, changesOpen });
  const formStateRef = (0, import_react2.useRef)(formState);
  formStateRef.current = formState;
  const setOpenPath = (0, import_react2.useCallback)((path) => {
    const ops = getExpandOperations(formStateRef.current, path);
    ops.forEach((op) => {
      if (op.type === "expandPath") {
        onSetCollapsedPath((prevState) => setAtPath(prevState, op.path, false));
      }
      if (op.type === "expandFieldSet") {
        onSetCollapsedFieldSets((prevState) => setAtPath(prevState, op.path, false));
      }
      if (op.type === "setSelectedGroup") {
        onSetFieldGroupState((prevState) => setAtPath(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = { actions, activeViewId, badges, changesOpen, closeInspector, collapsedFieldSets, collapsedPaths, compareValue, connectionState, displayed, documentId, documentIdRaw, documentType, editState, fieldActions, focusPath, inspector: currentInspector || null, inspectors: inspectors2, onBlur: handleBlur, onChange: handleChange, onFocus: handleFocus, onPathOpen: setOpenPath, onHistoryClose: handleHistoryClose, onHistoryOpen: handleHistoryOpen, onInspectClose: handleLegacyInspectClose, onMenuAction: handleMenuAction, onPaneClose: handlePaneClose, onPaneSplit: handlePaneSplit, onSetActiveFieldGroup: handleSetActiveFieldGroup, onSetCollapsedPath: handleOnSetCollapsedPath, onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet, openInspector, index, inspectOpen, validation, menuItemGroups: menuItemGroups || [], paneKey, previewUrl, ready, schemaType, isPermissionsLoading, permissions, setTimelineMode, setTimelineRange, setIsDeleting, isDeleting, isDeleted, timelineError, timelineMode, timelineStore, title, value, views: views2, formState, unstable_languageFilter: languageFilter };
  (0, import_react2.useEffect)(() => {
    if (connectionState === "reconnecting") {
      pushToast({ id: "sanity/structure/reconnecting", status: "warning", title: t("panes.document-pane-provider.reconnecting.title") });
    }
  }, [connectionState, pushToast, t]);
  const disableBlurRef = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(() => {
    var _a2;
    if (ready && params.path) {
      const { path, ...restParams } = params;
      const pathFromUrl = resolveKeyedPath((_a2 = formStateRef.current) == null ? void 0 : _a2.value, fromString(path));
      disableBlurRef.current = true;
      setFocusPath(pathFromUrl);
      setOpenPath(pathFromUrl);
      if (focusPathRef.current !== pathFromUrl) {
        focusPathRef.current = pathFromUrl;
        onFocusPath == null ? void 0 : onFocusPath(pathFromUrl);
      }
      const timeout = setTimeout(() => {
        disableBlurRef.current = false;
      }, 0);
      paneRouter.setParams(restParams);
      return () => clearTimeout(timeout);
    }
    return void 0;
  }, [params, documentId, onFocusPath, setOpenPath, ready, paneRouter]);
  return (0, import_jsx_runtime2.jsx)(DocumentPaneContext.Provider, { value: documentPane, children });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
var IGNORE_OPS = ["patch", "commit"];
var DocumentOperationResults = (0, import_react2.memo)(function DocumentOperationResults2() {
  const { push: pushToast } = useToast();
  const { documentId, documentType } = useDocumentPane();
  const event = useDocumentOperationEvent(documentId, documentType);
  const prevEvent = (0, import_react2.useRef)(event);
  const paneRouter = usePaneRouter();
  const { t } = useTranslation2(structureLocaleNamespace);
  (0, import_react2.useEffect)(() => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    if (event.type === "error") {
      pushToast({
        closable: true,
        duration: 3e4,
        // 30s
        status: "error",
        title: t("panes.document-operation-results.operation-error", { context: event.op }),
        description: (0, import_jsx_runtime2.jsxs)("details", { children: [(0, import_jsx_runtime2.jsx)("summary", { children: t("panes.document-operation-results.error.summary.title") }), event.error.message] })
      });
    }
    if (event.type === "success" && !IGNORE_OPS.includes(event.op)) {
      pushToast({ closable: true, status: "success", title: t("panes.document-operation-results.operation-success", { context: event.op }) });
    }
    if (event.type === "success" && event.op === "delete") {
      cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0);
    }
    prevEvent.current = event;
    return () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast, t]);
  return null;
});
function useStructureToolSetting(namespace, key, defaultValue) {
  const settingsStore = useSettingsStore();
  const [value, setValue] = (0, import_react2.useState)(defaultValue);
  const structureToolSettings = (0, import_react2.useMemo)(() => settingsStore.forNamespace("structure-tool"), [settingsStore]);
  const settings = (0, import_react2.useMemo)(() => {
    if (namespace) {
      return structureToolSettings.forNamespace(namespace).forKey(key);
    }
    return structureToolSettings.forKey(key);
  }, [structureToolSettings, namespace, key]);
  (0, import_react2.useEffect)(() => {
    const sub = settings.listen(defaultValue).subscribe({ next: setValue });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, key, namespace, settings]);
  const set2 = (0, import_react2.useCallback)((newValue) => {
    setValue(newValue);
    settings.set(newValue);
  }, [settings]);
  return (0, import_react2.useMemo)(() => [value, set2], [set2, value]);
}
var VIEW_MODE_PARSED = { id: "parsed", title: "document-inspector.view-mode.parsed" };
var VIEW_MODE_RAW = { id: "raw", title: "document-inspector.view-mode.raw-json" };
var VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW];
var lru = (0, import_hashlru.default)(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  if (cached === void 0) {
    lru.set(keyPath, Array.isArray(value) || isRecord$4(value));
    return isExpanded(keyPath, value);
  }
  return cached;
}
function toggleExpanded(event) {
  const { path } = event;
  const current = lru.get(path);
  if (current === void 0) {
    return;
  }
  lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges();
    range.selectNodeContents(element);
    sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  const selectAll = event.keyCode === 65 && (event.metaKey || event.ctrlKey);
  if (!selectAll) {
    return;
  }
  event.preventDefault();
  selectElement(event.currentTarget);
}
function isDocumentLike(value) {
  return isRecord$4(value) && isString(value._id) && isString(value._type);
}
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", { value: __freeze$6(raw || cooked.slice()) }));
var _a$6;
var JSONInspectorWrapper = ut.div((_ref97) => {
  let { theme } = _ref97;
  const { color, fonts, space } = theme.sanity;
  return at(_a$6 || (_a$6 = __template$6(["\n    & .json-inspector,\n    & .json-inspector .json-inspector__selection {\n      font-family: ", ";\n      font-size: ", "px;\n      line-height: ", "px;\n      color: var(--card-code-fg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf {\n      padding-left: ", ";\n    }\n\n    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {\n      padding-top: ", ";\n      padding-left: 0;\n    }\n\n    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__line {\n      display: block;\n      position: relative;\n      cursor: default;\n    }\n\n    & .json-inspector .json-inspector__line::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: -200px;\n      right: -50px;\n      bottom: 0;\n      z-index: -1;\n      pointer-events: none;\n    }\n\n    & .json-inspector .json-inspector__line:hover::after {\n      background: var(--card-code-bg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {\n      content: '▸ ';\n      margin-left: calc(0 - ", " + 3px);\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    &\n      .json-inspector\n      .json-inspector__leaf_expanded.json-inspector__leaf_composite\n      > .json-inspector__line::before {\n      content: '▾ ';\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    & .json-inspector .json-inspector__radio,\n    & .json-inspector .json-inspector__flatpath {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__value {\n      margin-left: ", ";\n    }\n\n    &\n      .json-inspector\n      > .json-inspector__leaf_root\n      > .json-inspector__line\n      > .json-inspector__key\n      + .json-inspector__value {\n      margin: 0;\n    }\n\n    & .json-inspector .json-inspector__key {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_helper,\n    & .json-inspector .json-inspector__value_null {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__not-found {\n      padding-top: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_string {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_boolean {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_number {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__show-original {\n      display: inline-block;\n      padding: 0 6px;\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__show-original:hover {\n      color: inherit;\n    }\n\n    & .json-inspector .json-inspector__show-original::before {\n      content: '↔';\n    }\n\n    & .json-inspector .json-inspector__show-original:hover::after {\n      content: ' expand';\n    }\n  "])), fonts.code.family, fonts.code.sizes[1].fontSize, fonts.code.sizes[1].lineHeight, rem(space[4]), rem(space[3]), rem(space[4]), fonts.code.sizes[1].fontSize, fonts.code.sizes[1].lineHeight, fonts.code.sizes[1].fontSize, fonts.code.sizes[1].lineHeight, rem(space[4] / 2), color.syntax.property, color.syntax.constant, rem(space[3]), color.syntax.string, color.syntax.boolean, color.syntax.number);
});
function Search(props) {
  const { onChange, query } = props;
  const handleChange = (0, import_react2.useCallback)((event) => onChange(event.target.value), [onChange]);
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime2.jsx)(TextInput, { icon: SearchIcon, onChange: handleChange, placeholder: t("document-inspector.search.placeholder"), radius: 2, value: query || "" });
}
function InspectDialog(props) {
  const { value } = props;
  const { onInspectClose, paneKey } = useDocumentPane();
  const dialogIdPrefix = "".concat(paneKey, "_inspect_");
  const [viewModeId, onViewModeChange] = useStructureToolSetting("structure-tool", "inspect-view-preferred-view-mode-".concat(paneKey), "parsed");
  const viewMode = VIEW_MODES.find((mode) => mode.id === viewModeId);
  const setParsedViewMode = (0, import_react2.useCallback)(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]);
  const setRawViewMode = (0, import_react2.useCallback)(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]);
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime2.jsx)(Dialog2, { bodyHeight: "fill", id: "".concat(dialogIdPrefix, "dialog"), header: isDocumentLike(value) ? (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "document-inspector.dialog.title", components: { DocumentTitle: () => (0, import_jsx_runtime2.jsx)("em", { children: (0, import_jsx_runtime2.jsx)(DocTitle, { document: value }) }) } }) : (0, import_jsx_runtime2.jsx)("em", { children: t("document-inspector.dialog.title-no-value") }), onClose: onInspectClose, onClickOutside: onInspectClose, padding: false, width: 2, children: (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", children: [(0, import_jsx_runtime2.jsx)(Card, { padding: 3, paddingTop: 0, shadow: 1, style: { position: "sticky", bottom: 0, zIndex: 3 }, children: (0, import_jsx_runtime2.jsxs)(TabList, { space: 1, children: [(0, import_jsx_runtime2.jsx)(Tab2, { "aria-controls": "".concat(dialogIdPrefix, "tabpanel"), id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_PARSED.id), label: t(VIEW_MODE_PARSED.title), onClick: setParsedViewMode, selected: viewMode === VIEW_MODE_PARSED }), (0, import_jsx_runtime2.jsx)(Tab2, { "aria-controls": "".concat(dialogIdPrefix, "tabpanel"), id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_RAW.id), label: t(VIEW_MODE_RAW.title), onClick: setRawViewMode, selected: viewMode === VIEW_MODE_RAW })] }) }), (0, import_jsx_runtime2.jsxs)(TabPanel, { "aria-labelledby": "".concat(dialogIdPrefix, "tab-").concat(viewModeId), flex: 1, id: "".concat(dialogIdPrefix, "tabpanel"), overflow: "auto", padding: 4, style: { outline: "none" }, children: [viewMode === VIEW_MODE_PARSED && (0, import_jsx_runtime2.jsx)(JSONInspectorWrapper, { children: (0, import_jsx_runtime2.jsx)(import_react_json_inspector.default, { data: value, isExpanded, onClick: toggleExpanded, search: Search }) }), viewMode === VIEW_MODE_RAW && (0, import_jsx_runtime2.jsx)(Code, { language: "json", tabIndex: 0, onKeyDown: maybeSelectAll, onDoubleClick: select, onFocus: select, size: 1, children: JSON.stringify(value, null, 2) })] })] }) });
}
function SpacerButton(_ref98) {
  let { size } = _ref98;
  return (0, import_jsx_runtime2.jsx)(Button2, { "aria-hidden": true, disabled: true, size, style: { pointerEvents: "none", visibility: "hidden", width: 0 }, text: "-" });
}
function Banner(props) {
  const { action, content, icon: Icon5, tone = "transparent", ...rest } = props;
  return (0, import_jsx_runtime2.jsx)(Card, { borderBottom: true, paddingX: 4, paddingY: 2, tone, ...rest, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, children: [Icon5 && (0, import_jsx_runtime2.jsx)(Text, { size: 0, children: (0, import_jsx_runtime2.jsx)(Icon5, {}) }), (0, import_jsx_runtime2.jsx)(Flex, { align: "center", flex: 1, gap: 2, paddingY: 3, children: content }), (0, import_jsx_runtime2.jsx)(SpacerButton, {}), action && (0, import_jsx_runtime2.jsx)(Button2, { as: action == null ? void 0 : action.as, mode: "ghost", onClick: action == null ? void 0 : action.onClick, text: action.text, tone: action.tone || "default" })] }) });
}
function DeletedDocumentBanner(_ref99) {
  let { revisionId } = _ref99;
  const { documentId, documentType } = useDocumentPane();
  const { restore } = useDocumentOperation(documentId, documentType);
  const { navigateIntent } = useRouter();
  const handleRestore = (0, import_react2.useCallback)(() => {
    if (revisionId) {
      restore.execute(revisionId);
      navigateIntent("edit", { id: documentId, type: documentType });
    }
  }, [documentId, documentType, navigateIntent, restore, revisionId]);
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime2.jsx)(Banner, { action: revisionId ? { onClick: handleRestore, text: t("banners.deleted-document-banner.restore-button.text") } : void 0, content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t("banners.deleted-document-banner.text") }), "data-testid": "deleted-document-banner", icon: ReadOnlyIcon });
}
function PermissionCheckBanner(_ref100) {
  let { granted, requiredPermission } = _ref100;
  const currentUser = useCurrentUser();
  const listFormat = useListFormat({ style: "short" });
  const { t } = useTranslation2(structureLocaleNamespace);
  if (granted)
    return null;
  const roleTitles = ((currentUser == null ? void 0 : currentUser.roles) || []).map((role) => role.title);
  const roles = listFormat.formatToParts(roleTitles).map((part) => part.type === "element" ? (0, import_jsx_runtime2.jsx)("code", { children: part.value }, part.value) : part.value);
  return (0, import_jsx_runtime2.jsx)(Banner, { content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "banners.permission-check-banner.missing-permission", components: { Roles: () => (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: roles }) }, values: { count: roles.length, roles: roleTitles }, context: requiredPermission }) }), "data-testid": "permission-check-banner", icon: ReadOnlyIcon });
}
var ReferenceChangedBanner = (0, import_react2.memo)(() => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g;
  const documentPreviewStore = useDocumentPreviewStore();
  const { params, groupIndex, routerPanesState, replaceCurrent, BackLink: BackLink3 } = usePaneRouter();
  const routerReferenceId = (_a2 = routerPanesState[groupIndex]) == null ? void 0 : _a2[0].id;
  const parentGroup = routerPanesState[groupIndex - 1];
  const parentSibling = parentGroup == null ? void 0 : parentGroup[0];
  const parentId = parentSibling == null ? void 0 : parentSibling.id;
  const hasHistoryOpen = Boolean((_b2 = parentSibling == null ? void 0 : parentSibling.params) == null ? void 0 : _b2.rev);
  const parentRefPath = (0, import_react2.useMemo)(() => {
    return (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null;
  }, [params == null ? void 0 : params.parentRefPath]);
  const { t } = useTranslation2(structureLocaleNamespace);
  const referenceInfo = useMemoObservable(() => {
    const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
    if (!parentId || !parentRefPathSegment || !parentRefPath) {
      return of({ loading: false });
    }
    const publishedId = getPublishedId(parentId);
    const path = fromString(parentRefPathSegment);
    const keyedSegmentIndex = path.findIndex((p) => typeof p == "object" && "_key" in p);
    return concat(
      // emit a loading state instantly
      of({ loading: true }),
      // then emit the values from watching the published ID's path
      documentPreviewStore.unstable_observePathsDocumentPair(publishedId, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)).pipe(
        // this debounce time is needed to prevent flashing banners due to
        // the router state updating faster than the content-lake state. we
        // debounce to wait for more emissions because the value pulled
        // initially could be stale.
        debounceTime(750),
        map((_ref101) => {
          let { draft, published } = _ref101;
          var _a22;
          return { loading: false, result: { availability: { draft: draft.availability, published: published.availability }, refValue: (_a22 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a22._ref } };
        })
      )
    );
  }, [documentPreviewStore, parentId, parentRefPath], { loading: true });
  const handleReloadReference = (0, import_react2.useCallback)(() => {
    var _a22;
    if (referenceInfo.loading)
      return;
    if ((_a22 = referenceInfo.result) == null ? void 0 : _a22.refValue) {
      replaceCurrent({ id: referenceInfo.result.refValue, params });
    }
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  const shouldHide = (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !((_c2 = referenceInfo.result) == null ? void 0 : _c2.availability.draft.available) && !((_d2 = referenceInfo.result) == null ? void 0 : _d2.availability.published.available) || // if the references are the same, then hide the reference changed banner
    ((_e2 = referenceInfo.result) == null ? void 0 : _e2.refValue) === routerReferenceId
  );
  if (shouldHide)
    return null;
  return (0, import_jsx_runtime2.jsx)(Banner, { action: ((_f2 = referenceInfo.result) == null ? void 0 : _f2.refValue) ? { onClick: handleReloadReference, icon: SyncIcon, text: t("banners.reference-changed-banner.reason-changed.reload-button.text") } : { as: BackLink3, icon: CloseIcon, text: t("banners.reference-changed-banner.reason-removed.close-button.text") }, "data-testid": "reference-changed-banner", content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: ((_g = referenceInfo.result) == null ? void 0 : _g.refValue) ? t("banners.reference-changed-banner.reason-changed.text") : t("banners.reference-changed-banner.reason-removed.text") }), icon: WarningOutlineIcon, tone: "caution" });
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
function useDocumentTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane();
  const subscribed = Boolean(documentValue) && connectionState === "connected";
  const { error, value } = useDocumentPreview({ enabled: subscribed, schemaType, value: documentValue });
  if (connectionState !== "connected") {
    return { error: void 0, title: void 0 };
  }
  if (title) {
    return { error: void 0, title };
  }
  if (!documentValue) {
    return { error: void 0, title: "New ".concat((schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)) };
  }
  if (error) {
    return { error: "Error: ".concat(error.message), title: void 0 };
  }
  return { error: void 0, title: value == null ? void 0 : value.title };
}
function usePrevious(value) {
  const ref = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast();
  const wasEnabled = usePrevious(params.enabled);
  (0, import_react2.useEffect)(() => {
    if (!wasEnabled && params.enabled) {
      toast.push({ ...params, duration: LONG_ENOUGH_BUT_NOT_TOO_LONG });
    }
    if (wasEnabled && !params.enabled) {
      toast.push({
        ...params,
        // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
        duration: 0.01
      });
    }
  }, [params, toast, wasEnabled]);
}
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", { value: __freeze$5(raw || cooked.slice()) }));
var _a$5;
var _b$3;
var TitleContainer = ut(Stack)(_b$3 || (_b$3 = __template$5(["\n  ", "\n"])), (_ref102) => {
  let { theme } = _ref102;
  return at(_a$5 || (_a$5 = __template$5(["\n      @supports not (container-type: inline-size) {\n        display: none !important;\n      }\n\n      container-type: inline-size;\n\n      [data-heading] {\n        font-size: ", "px;\n        line-height: ", "px;\n        overflow-wrap: break-word;\n      }\n\n      @container (max-width: 560px) {\n        [data-heading] {\n          font-size: ", "px;\n          line-height: ", "px;\n        }\n      }\n\n      @container (max-width: 420px) {\n        [data-heading] {\n          font-size: ", "px;\n          line-height: ", "px;\n        }\n      }\n    "])), theme.sanity.fonts.heading.sizes[4].fontSize, theme.sanity.fonts.heading.sizes[4].lineHeight, theme.sanity.fonts.heading.sizes[3].fontSize, theme.sanity.fonts.heading.sizes[3].lineHeight, theme.sanity.fonts.heading.sizes[2].fontSize, theme.sanity.fonts.heading.sizes[2].lineHeight);
});
var FormHeader = (_ref103) => {
  let { documentId, schemaType, title } = _ref103;
  var _a2;
  const isSingleton = documentId === schemaType.name;
  const { t } = useTranslation(structureLocaleNamespace);
  if (schemaType.__experimental_formPreviewTitle === false) {
    return null;
  }
  return (0, import_jsx_runtime2.jsxs)(TitleContainer, { marginBottom: 6, space: 4, children: [!isSingleton && (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (_a2 = schemaType.title) != null ? _a2 : schemaType.name }), (0, import_jsx_runtime2.jsx)(Heading, { as: "h2", "data-heading": true, muted: !title, children: title != null ? title : t("document-view.form-view.form-title-fallback") })] });
};
var preventDefault = (ev) => ev.preventDefault();
var FormView = (0, import_react2.forwardRef)(function FormView2(props, ref) {
  var _a2;
  const { hidden, margins } = props;
  const { collapsedFieldSets, collapsedPaths, displayed: value, editState, documentId, documentType, fieldActions, onChange, validation, ready, formState, onFocus, onBlur, onSetCollapsedPath, onPathOpen, onSetCollapsedFieldSet, onSetActiveFieldGroup } = useDocumentPane();
  const documentStore = useDocumentStore();
  const presence = useDocumentPresence(documentId);
  const { title } = useDocumentTitle();
  const patchChannel = (0, import_react2.useMemo)(() => createPatchChannel(), []);
  const isLocked = (_a2 = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a2.enabled;
  const { t } = useTranslation2(structureLocaleNamespace);
  useConditionalToast({ id: "sync-lock-".concat(documentId), status: "warning", enabled: isLocked, title: t("document-view.form-view.sync-lock-toast.title"), description: t("document-view.form-view.sync-lock-toast.description") });
  (0, import_react2.useEffect)(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(tap((event) => {
      if (event.type === "mutation") {
        patchChannel.publish(prepareMutationEvent(event));
      }
      if (event.type === "rebase") {
        patchChannel.publish(prepareRebaseEvent(event));
      }
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = Boolean(value == null ? void 0 : value._rev);
  (0, import_react2.useEffect)(() => {
    if (hasRev) {
      patchChannel.publish({ type: "mutation", patches: [], snapshot: value });
    }
  }, [hasRev]);
  const [formRef, setFormRef] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (ready && !(formState == null ? void 0 : formState.focusPath.length) && formRef) {
      focusFirstDescendant(formRef);
    }
  }, [ready]);
  const setRef = (0, import_react2.useCallback)((node) => {
    setFormRef(node);
    if (typeof ref === "function") {
      ref(node);
    } else if (ref) {
      ref.current = node;
    }
  }, [ref]);
  if (!ready) {
    return (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true });
  }
  return (0, import_jsx_runtime2.jsx)(Container, { hidden, paddingX: 4, paddingTop: 5, paddingBottom: 9, sizing: "border", width: 1, children: (0, import_jsx_runtime2.jsx)(PresenceOverlay, { margins, children: (0, import_jsx_runtime2.jsx)(Box, { as: "form", onSubmit: preventDefault, ref: setRef, children: ready ? formState === null || hidden ? (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { children: t("document-view.form-view.form-hidden") }) }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(FormHeader, { documentId, schemaType: formState.schemaType, title }), (0, import_jsx_runtime2.jsx)(FormBuilder, { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, collapsedFieldSets, collapsedPaths, focusPath: formState.focusPath, changed: formState.changed, focused: formState.focused, groups: formState.groups, id: "root", members: formState.members, onChange, onFieldGroupSelect: onSetActiveFieldGroup, onPathBlur: onBlur, onPathFocus: onFocus, onPathOpen, onSetFieldSetCollapsed: onSetCollapsedFieldSet, onSetPathCollapsed: onSetCollapsedPath, presence, readOnly: formState.readOnly, schemaType: formState.schemaType, validation, value: (
    // note: the form state doesn't have a typed concept of a "document" value
    // but these should be compatible
    formState.value
  ) })] }) : (0, import_jsx_runtime2.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [(0, import_jsx_runtime2.jsx)(Spinner, { muted: true }), (0, import_jsx_runtime2.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, size: 1, children: t("document-view.form-view.loading") }) })] }) }) }) }) });
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return { type: "mutation", snapshot: event.document, patches: fromMutationPatches(event.origin, patches) };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean);
  const localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return { type: "rebase", snapshot: event.document, patches: fromMutationPatches("remote", remotePatches).concat(fromMutationPatches("local", localPatches)) };
}
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", { value: __freeze$4(raw || cooked.slice()) }));
var _a$4;
var DocumentBox = ut(Box)({ position: "relative" });
var Scroller = ut(ScrollContainer)((_ref104) => {
  let { $disabled } = _ref104;
  if ($disabled) {
    return { height: "100%" };
  }
  return at(_a$4 || (_a$4 = __template$4(["\n    height: 100%;\n    overflow: auto;\n    position: relative;\n    scroll-behavior: smooth;\n    outline: none;\n  "])));
});
var DocumentPanel = function DocumentPanel2(props) {
  const { footerHeight, headerHeight, isInspectOpen, rootElement, setDocumentPanelPortalElement } = props;
  const { activeViewId, displayed, documentId, editState, inspector, value, views: views2, ready, schemaType, permissions, isPermissionsLoading, isDeleting, isDeleted, timelineStore } = useDocumentPane();
  const { collapsed: layoutCollapsed } = usePaneLayout();
  const { collapsed } = usePane();
  const parentPortal = usePortal();
  const { features } = useStructureTool();
  const portalRef = (0, import_react2.useRef)(null);
  const [documentScrollElement, setDocumentScrollElement] = (0, import_react2.useState)(null);
  const formContainerElement = (0, import_react2.useRef)(null);
  const requiredPermission = value._createdAt ? "update" : "create";
  const activeView = (0, import_react2.useMemo)(() => views2.find((view) => view.id === activeViewId) || views2[0] || { type: "form" }, [activeViewId, views2]);
  const portalElement = features.splitPanes ? portalRef.current || parentPortal.element : parentPortal.element;
  const margins = (0, import_react2.useMemo)(() => {
    if (layoutCollapsed) {
      return [headerHeight || 0, 0, footerHeight ? footerHeight + 2 : 2, 0];
    }
    return [0, 0, 2, 0];
  }, [layoutCollapsed, footerHeight, headerHeight]);
  const formViewHidden = activeView.type !== "form";
  const activeViewNode = (0, import_react2.useMemo)(() => activeView.type === "component" && activeView.component && (0, import_react2.createElement)(activeView.component, { document: { draft: (editState == null ? void 0 : editState.draft) || null, displayed: displayed || value, historical: displayed, published: (editState == null ? void 0 : editState.published) || null }, documentId, options: activeView.options, schemaType }), [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]);
  const lastNonDeletedRevId = useTimelineSelector(timelineStore, (state2) => state2.lastNonDeletedRevId);
  (0, import_react2.useEffect)(() => {
    if (!(documentScrollElement == null ? void 0 : documentScrollElement.scrollTo))
      return;
    documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]);
  (0, import_react2.useEffect)(() => {
    if (portalElement) {
      setDocumentPanelPortalElement(portalElement);
    }
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = (0, import_react2.useMemo)(() => {
    return isInspectOpen ? (0, import_jsx_runtime2.jsx)(InspectDialog, { value: displayed || value }) : null;
  }, [isInspectOpen, displayed, value]);
  const showInspector = Boolean(!collapsed && inspector);
  return (0, import_jsx_runtime2.jsx)(PaneContent, { children: (0, import_jsx_runtime2.jsxs)(Flex, { height: "fill", children: [(features.resizablePanes || !showInspector) && (0, import_jsx_runtime2.jsx)(DocumentBox, { flex: 2, overflow: "hidden", children: (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, __unstable_elements: { documentScrollElement }, children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: documentScrollElement, children: (0, import_jsx_runtime2.jsxs)(VirtualizerScrollInstanceProvider, { scrollElement: documentScrollElement, containerElement: formContainerElement, children: [activeView.type === "form" && !isPermissionsLoading && ready && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(PermissionCheckBanner, { granted: Boolean(permissions == null ? void 0 : permissions.granted), requiredPermission }), !isDeleting && isDeleted && (0, import_jsx_runtime2.jsx)(DeletedDocumentBanner, { revisionId: lastNonDeletedRevId }), (0, import_jsx_runtime2.jsx)(ReferenceChangedBanner, {})] }), (0, import_jsx_runtime2.jsxs)(Scroller, { $disabled: layoutCollapsed || false, "data-testid": "document-panel-scroller", ref: setDocumentScrollElement, children: [(0, import_jsx_runtime2.jsx)(FormView, { hidden: formViewHidden, margins, ref: formContainerElement }, documentId + (ready ? "_ready" : "_pending")), activeViewNode] }), inspectDialog, (0, import_jsx_runtime2.jsx)("div", { "data-testid": "document-panel-portal", ref: portalRef })] }) }) }) }), showInspector && (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: rootElement, children: (0, import_jsx_runtime2.jsx)(DocumentInspectorPanel, { documentId, documentType: schemaType.name, flex: 1 }) })] }) });
};
var POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"];
var DIALOG_WIDTH_TO_UI_WIDTH = { small: 0, medium: 1, large: 2, full: "auto" };
function ConfirmDialog(props) {
  const { dialog, referenceElement } = props;
  return (0, import_jsx_runtime2.jsx)(Popover, { content: (0, import_jsx_runtime2.jsx)(ConfirmDialogContent, { dialog }), fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, open: true, placement: "top", portal: true, preventOverflow: true, referenceElement });
}
function ConfirmDialogContent(props) {
  const { dialog } = props;
  const {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog;
  const { t } = useTranslation2(structureLocaleNamespace);
  const { isTopLayer } = useLayer();
  const [element, setElement] = (0, import_react2.useState)(null);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (isTopLayer)
      onCancel();
  }, [isTopLayer, onCancel]);
  const handleGlobalKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape" && isTopLayer)
      onCancel();
  }, [isTopLayer, onCancel]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", ref: setElement, style: { minWidth: 320 - 16, maxWidth: 400 }, children: [(0, import_jsx_runtime2.jsx)(Box, { flex: 1, overflow: "auto", padding: 4, children: (0, import_jsx_runtime2.jsx)(Text, { children: message }) }), (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 3, style: { borderTop: "1px solid var(--card-border-color)" }, children: (0, import_jsx_runtime2.jsxs)(Grid, { columns: 2, gap: 2, children: [(0, import_jsx_runtime2.jsx)(Button, { icon: cancelButtonIcon, onClick: onCancel, mode: "ghost", text: cancelButtonText || t("confirm-dialog.cancel-button.fallback-text") }), (0, import_jsx_runtime2.jsx)(Button, { icon: confirmButtonIcon, onClick: onConfirm, text: confirmButtonText || t("confirm-dialog.confirm-button.fallback-text"), tone })] }) })] });
}
function ModalDialog(props) {
  const { dialog } = props;
  const dialogId = (0, import_react2.useId)();
  const footer = dialog.footer && (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 3, children: dialog.footer });
  return (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "fullscreen", children: (0, import_jsx_runtime2.jsx)(Dialog, { __unstable_hideCloseButton: dialog.showCloseButton === false, footer, header: dialog.header, id: dialogId, onClose: dialog.onClose, onClickOutside: dialog.onClose, width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width], children: (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: dialog.content }) }) });
}
function PopoverDialog(props) {
  const { dialog, referenceElement } = props;
  return (0, import_jsx_runtime2.jsx)(Popover, { content: (0, import_jsx_runtime2.jsx)(PopoverDialogContent, { dialog }), fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, open: true, placement: "top", portal: true, preventOverflow: true, referenceElement });
}
function PopoverDialogContent(props) {
  const { dialog } = props;
  const { content, onClose } = dialog;
  const { isTopLayer } = useLayer();
  const [element, setElement] = (0, import_react2.useState)(null);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (isTopLayer)
      onClose();
  }, [isTopLayer, onClose]);
  const handleGlobalKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape" && isTopLayer)
      onClose();
  }, [isTopLayer, onClose]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return (0, import_jsx_runtime2.jsx)("div", { ref: setElement, children: content });
}
function DocumentActionPortalProvider(props) {
  const { children } = props;
  const { element, elements } = usePortal();
  const portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, children });
}
function ActionStateDialog(props) {
  const { dialog, referenceElement = null } = props;
  const modalId = (0, import_react2.useId)();
  if (dialog.type === "confirm") {
    return (0, import_jsx_runtime2.jsx)(ConfirmDialog, { dialog, referenceElement });
  }
  if (dialog.type === "popover") {
    return (0, import_jsx_runtime2.jsx)(PopoverDialog, { dialog, referenceElement });
  }
  if (dialog.type === "dialog" || !dialog.type) {
    return (0, import_jsx_runtime2.jsx)(DocumentActionPortalProvider, { children: (0, import_jsx_runtime2.jsx)(ModalDialog, { dialog }) });
  }
  if (dialog.type === "custom") {
    return (0, import_jsx_runtime2.jsx)(DocumentActionPortalProvider, { children: dialog == null ? void 0 : dialog.component });
  }
  const unknownModal = dialog;
  console.warn("Unsupported modal type ".concat(unknownModal.type));
  return (0, import_jsx_runtime2.jsx)(Dialog2, { id: modalId, onClose: unknownModal.onClose, onClickOutside: unknownModal.onClose, width: 1, children: unknownModal.content || // eslint-disable-next-line i18next/no-literal-string
  (0, import_jsx_runtime2.jsxs)(Text, { size: 1, children: ["Unexpected modal type (", (0, import_jsx_runtime2.jsx)("code", { children: unknownModal.type }), ")"] }) });
}
function ActionMenuButton(props) {
  const { actionStates, disabled } = props;
  const idPrefix = (0, import_react2.useId)();
  const [actionIndex, setActionIndex] = (0, import_react2.useState)(-1);
  const [referenceElement, setReferenceElement] = (0, import_react2.useState)(null);
  const handleAction = (0, import_react2.useCallback)((idx) => {
    setActionIndex(idx);
  }, []);
  const popoverProps = (0, import_react2.useMemo)(() => ({ placement: "top-end", portal: true, preventOverflow: true }), []);
  const currentAction = actionStates[actionIndex];
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(MenuButton2, { id: "".concat(idPrefix, "-action-menu"), button: (0, import_jsx_runtime2.jsx)(ContextMenuButton, { "aria-label": t("buttons.action-menu-button.aria-label"), disabled, "data-testid": "action-menu-button", size: "large", tooltipProps: { content: t("buttons.action-menu-button.tooltip") } }), menu: (0, import_jsx_runtime2.jsx)(Menu, { padding: 1, children: actionStates.map((actionState, idx) => (0, import_jsx_runtime2.jsx)(ActionMenuListItem, { actionState, disabled, index: idx, onAction: handleAction }, idx)) }), popover: popoverProps, ref: setReferenceElement }), currentAction && currentAction.dialog && (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime2.jsx)(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) })] });
}
function ActionMenuListItem(props) {
  const { actionState, disabled, index, onAction } = props;
  const { onHandle } = actionState;
  const handleClick = (0, import_react2.useCallback)(() => {
    onAction(index);
    if (onHandle)
      onHandle();
  }, [index, onAction, onHandle]);
  const hotkeys = (0, import_react2.useMemo)(() => {
    return actionState.shortcut ? String(actionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1)) : void 0;
  }, [actionState.shortcut]);
  return (0, import_jsx_runtime2.jsx)(MenuItem2, { "data-testid": "action-".concat(actionState.label.replace(" ", "")), disabled: disabled || Boolean(actionState.disabled), hotkeys, icon: actionState.icon, onClick: handleClick, text: actionState.label, tone: actionState.tone, ...actionState.disabled && { tooltipProps: { content: actionState.title } } });
}
function DocumentStatusBarActionsInner(props) {
  const { disabled, showMenu, states } = props;
  const [firstActionState, ...menuActionStates] = states;
  const [buttonElement, setButtonElement] = (0, import_react2.useState)(null);
  const tooltipContent = (0, import_react2.useMemo)(() => {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut)
      return null;
    return (0, import_jsx_runtime2.jsxs)(Flex, { style: { maxWidth: 300 }, align: "center", gap: 3, children: [firstActionState.title && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: firstActionState.title }), firstActionState.shortcut && (0, import_jsx_runtime2.jsx)(Hotkeys, { fontSize: 1, style: { marginTop: -4, marginBottom: -4 }, keys: String(firstActionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase()) })] });
  }, [firstActionState]);
  return (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, children: [firstActionState && (0, import_jsx_runtime2.jsx)(LayerProvider, { zOffset: 200, children: (0, import_jsx_runtime2.jsx)(Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: (0, import_jsx_runtime2.jsx)(Stack, { children: (0, import_jsx_runtime2.jsx)(Button2, { "data-testid": "action-".concat(firstActionState.label), disabled: disabled || Boolean(firstActionState.disabled), icon: firstActionState.icon, onClick: firstActionState.onHandle, ref: setButtonElement, size: "large", text: firstActionState.label, tone: firstActionState.tone || "primary" }) }) }) }), showMenu && menuActionStates.length > 0 && (0, import_jsx_runtime2.jsx)(ActionMenuButton, { actionStates: menuActionStates, disabled }), firstActionState && firstActionState.dialog && (0, import_jsx_runtime2.jsx)(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement })] });
}
var DocumentStatusBarActions = (0, import_react2.memo)(function DocumentStatusBarActions2() {
  const { actions, connectionState, documentId, editState } = useDocumentPane();
  if (!actions || !editState) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(RenderActionCollectionState, { actions, actionProps: editState, children: (_ref105) => {
    let { states } = _ref105;
    return (0, import_jsx_runtime2.jsx)(DocumentStatusBarActionsInner, { disabled: connectionState !== "connected", showMenu: actions.length > 1, states }, documentId);
  } });
});
var HistoryStatusBarActions = (0, import_react2.memo)(function HistoryStatusBarActions2() {
  const { connectionState, editState, timelineStore } = useDocumentPane();
  const revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime);
  const revision = (revTime == null ? void 0 : revTime.id) || "";
  const disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision;
  const actionProps = (0, import_react2.useMemo)(() => ({ ...editState || {}, revision }), [editState, revision]);
  const historyActions = (0, import_react2.useMemo)(() => [HistoryRestoreAction], []);
  return (0, import_jsx_runtime2.jsx)(RenderActionCollectionState, { actions: historyActions, actionProps, children: (_ref106) => {
    let { states } = _ref106;
    return (0, import_jsx_runtime2.jsx)(DocumentStatusBarActionsInner, { disabled: connectionState !== "connected" || Boolean(disabled), showMenu: false, states });
  } });
});
function useResizeObserver(_ref107) {
  let { element, onResize } = _ref107;
  (0, import_react2.useLayoutEffect)(() => {
    if (element) {
      resizeObserver.observe(element, onResize);
    }
    return () => {
      if (element) {
        resizeObserver.unobserve(element);
      }
    };
  }, [element, onResize]);
}
var BADGE_TONES = { primary: "primary", success: "positive", warning: "caution", danger: "critical" };
function DocumentBadgesInner(_ref108) {
  let { states } = _ref108;
  if (states.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(Inline, { space: 1, children: states.map((badge, index) => (0, import_jsx_runtime2.jsx)(Tooltip, { content: badge.title, disabled: !badge.title, placement: "top", portal: true, children: (0, import_jsx_runtime2.jsx)(Badge, { fontSize: 1, mode: "outline", paddingX: 2, paddingY: 1, radius: 4, tone: badge.color ? BADGE_TONES[badge.color] : void 0, style: { whiteSpace: "nowrap" }, children: badge.label }) }, String(index))) });
}
function DocumentBadges() {
  const { badges, editState } = useDocumentPane();
  if (!editState || !badges)
    return null;
  return (0, import_jsx_runtime2.jsx)(RenderBadgeCollectionState, { badges, badgeProps: editState, children: (_ref109) => {
    let { states } = _ref109;
    return (0, import_jsx_runtime2.jsx)(DocumentBadgesInner, { states });
  } });
}
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", { value: __freeze$3(raw || cooked.slice()) }));
var _a$3;
var _b$2;
var _c;
var StyledMotionPath = ut(motion.path)(_a$3 || (_a$3 = __template$3(["\n  transform-origin: center;\n"])));
var Circle = (props) => (0, import_jsx_runtime2.jsx)(motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props });
var Arrows = (props) => (0, import_jsx_runtime2.jsx)(StyledMotionPath, { fill: "none", d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811", ...props });
var Checkmark = (props) => (0, import_jsx_runtime2.jsx)(motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props });
var rotateAnimation = ht(_b$2 || (_b$2 = __template$3(["\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"])));
var RotateGroup = ut.g(_c || (_c = __template$3(["\n  transform-origin: center;\n\n  &[data-rotate] {\n    animation: ", " 1s ease-in-out infinite;\n  }\n"])), rotateAnimation);
var root = { syncing: { scale: 1, transition: { duration: 0 } }, saved: { scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1], transition: { duration: 0.5, delay: 0.2 } }, changes: { transition: { duration: 0 } } };
var circle = { syncing: { strokeDasharray: "0, 0, 23, 3, 23, 3", strokeDashoffset: 10, opacity: 1, transition: { duration: 0 } }, saved: { strokeDasharray: "0, 0, 23, 0, 23, 0", strokeDashoffset: 10, opacity: 1, transition: { duration: 0.2 } }, changes: { strokeDasharray: "0, 60, 23, 0, 23, 0", strokeDashoffset: 0, opacity: 0, transition: { duration: 0.5 } } };
var arrows = { syncing: { opacity: 1, transition: { duration: 0 } }, saved: { opacity: 0, transition: { duration: 0.2 } }, changes: { opacity: 0 } };
var checkmark = { syncing: { pathLength: 0, transition: { duration: 0 } }, saved: { pathLength: 1, transition: { delay: 0.4, duration: 0.3 } }, changes: { pathLength: 0, transition: { duration: 0.2 } } };
function AnimatedStatusIcon(props) {
  const { status } = props;
  if (!status) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", stroke: "currentColor", strokeWidth: "1.2", "data-sanity-icon": "animated-status-icon", children: (0, import_jsx_runtime2.jsxs)(motion.g, { variants: root, initial: status, animate: status, children: [(0, import_jsx_runtime2.jsxs)(RotateGroup, { "data-rotate": status === "changes" ? void 0 : "", children: [(0, import_jsx_runtime2.jsx)(Arrows, { variants: arrows, initial: status, animate: status }), (0, import_jsx_runtime2.jsx)(Circle, { variants: circle, initial: status, animate: status })] }), (0, import_jsx_runtime2.jsx)(Checkmark, { variants: checkmark, initial: status, animate: status })] }) });
}
var STATUS_DICTIONARY = { saved: { i18nKey: "status-bar.document-status-pulse.status.saved.text", tone: "positive" }, syncing: { i18nKey: "status-bar.document-status-pulse.status.syncing.text", tone: "default" } };
var DocumentStatusPulse = (props) => {
  const { status } = props;
  const { t } = useTranslation2(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing") {
    return null;
  }
  const currentStatus = STATUS_DICTIONARY[status];
  return (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime2.jsx)(TextWithTone, { size: 1, tone: currentStatus.tone, children: (0, import_jsx_runtime2.jsx)(AnimatedStatusIcon, { status }) }), (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t(currentStatus.i18nKey) })] });
};
var SYNCING_TIMEOUT = 1e3;
var SAVED_TIMEOUT = 3e3;
function DocumentStatusLine(_ref110) {
  let { singleLine } = _ref110;
  const { documentId, documentType, editState, value } = useDocumentPane();
  const [status, setStatus] = (0, import_react2.useState)(null);
  const syncState = useSyncState(documentId, documentType);
  const lastUpdated = value == null ? void 0 : value._updatedAt;
  (0, import_react2.useEffect)(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]);
  (0, import_react2.useLayoutEffect)(() => {
    setStatus(null);
  }, [documentId]);
  (0, import_react2.useLayoutEffect)(() => {
    if (syncState.isSyncing) {
      setStatus("syncing");
    }
  }, [syncState.isSyncing, lastUpdated]);
  if (status) {
    return (0, import_jsx_runtime2.jsx)(DocumentStatusPulse, { status: status || void 0 });
  }
  return (0, import_jsx_runtime2.jsx)(Tooltip, { content: (0, import_jsx_runtime2.jsx)(DocumentStatus, { absoluteDate: true, draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }), placement: "top", children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, children: [(0, import_jsx_runtime2.jsx)(DocumentStatusIndicator, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }), (0, import_jsx_runtime2.jsx)(DocumentStatus, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published, singleLine })] }) });
}
var CONTAINER_BREAKPOINT = 480;
function DocumentStatusBar(props) {
  const { actionsBoxRef } = props;
  const { editState, timelineStore } = useDocumentPane();
  const showingRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const [collapsed, setCollapsed] = (0, import_react2.useState)(null);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const handleResize = (0, import_react2.useCallback)((event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, []);
  useResizeObserver({ element: rootElement, onResize: handleResize });
  const shouldRender = (editState == null ? void 0 : editState.ready) && typeof collapsed === "boolean";
  return (0, import_jsx_runtime2.jsx)(Flex, { direction: "column", ref: setRootElement, sizing: "border", children: shouldRender && (0, import_jsx_runtime2.jsxs)(Flex, { align: "stretch", gap: 1, justify: "space-between", paddingY: 2, paddingLeft: 4, paddingRight: 3, children: [(0, import_jsx_runtime2.jsxs)(Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [(0, import_jsx_runtime2.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime2.jsx)(DocumentStatusLine, { singleLine: !collapsed }), (0, import_jsx_runtime2.jsx)(SpacerButton, { size: "large" })] }), (0, import_jsx_runtime2.jsx)(DocumentBadges, {})] }), (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", justify: "flex-end", ref: actionsBoxRef, style: { flexShrink: 0, marginLeft: "auto" }, children: [(0, import_jsx_runtime2.jsx)(SpacerButton, { size: "large" }), showingRevision ? (0, import_jsx_runtime2.jsx)(HistoryStatusBarActions, {}) : (0, import_jsx_runtime2.jsx)(DocumentStatusBarActions, {})] })] }) });
}
function KeyboardShortcutResponder(props) {
  const { actionsBoxElement, activeIndex, as = "div", children, id, onActionStart, onKeyDown, rootRef, states, ...rest } = props;
  const activeAction = states[activeIndex];
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    const matchingStates = states.filter((state2) => state2.shortcut && (0, import_is_hotkey.default)(state2.shortcut, event));
    const matchingState = matchingStates[0];
    if (matchingStates.length > 1) {
      console.warn('Keyboard shortcut conflict: More than one document action matches the shortcut "'.concat(matchingState.shortcut, '"'));
    }
    if (matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault();
      matchingState.onHandle();
      onActionStart(states.indexOf(matchingState));
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onActionStart, onKeyDown, states]);
  return (0, import_react2.createElement)(as, { id, onKeyDown: handleKeyDown, tabIndex: -1, ...rest, ref: rootRef }, [children, activeAction && activeAction.dialog && (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime2.jsx)(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) })]);
}
var DocumentActionShortcuts = import_react2.default.memo((props) => {
  const { actionsBoxElement, as = "div", children, ...rest } = props;
  const { actions, editState } = useDocumentPane();
  const [activeIndex, setActiveIndex] = (0, import_react2.useState)(-1);
  const onActionStart = (0, import_react2.useCallback)((idx) => {
    setActiveIndex(idx);
  }, []);
  const actionProps = (0, import_react2.useMemo)(() => editState && {
    ...editState,
    // @todo: what to call here?
    onComplete: () => void 0,
    // @todo: get revision string
    revision: void 0
  }, [editState]);
  if (!actionProps || !actions)
    return null;
  return (0, import_jsx_runtime2.jsx)(RenderActionCollectionState, { actionProps, actions, children: (_ref111) => {
    let { states } = _ref111;
    return (0, import_jsx_runtime2.jsx)(KeyboardShortcutResponder, { ...rest, activeIndex, actionsBoxElement, as, onActionStart, states, children });
  } });
});
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
function DocumentHeaderTabs() {
  const { activeViewId, paneKey, views: views2 } = useDocumentPane();
  const tabPanelId = "".concat(paneKey, "tabpanel");
  return (0, import_jsx_runtime2.jsx)(TabList, { space: 1, children: views2.map((view, index) => {
    var _a2;
    return (0, import_jsx_runtime2.jsx)(DocumentHeaderTab, { icon: view.icon, id: "".concat(paneKey, "tab-").concat(view.id), isActive: activeViewId === view.id, label: view.title, tabPanelId, viewId: index === 0 ? null : (_a2 = view.id) != null ? _a2 : null }, view.id);
  }) });
}
function DocumentHeaderTab(props) {
  const { icon, id, isActive, label, tabPanelId, viewId, ...rest } = props;
  const { ready } = useDocumentPane();
  const { setView } = usePaneRouter();
  const handleClick = (0, import_react2.useCallback)(() => setView(viewId), [setView, viewId]);
  return (0, import_jsx_runtime2.jsx)(Tab2, { ...rest, "aria-controls": tabPanelId, disabled: !ready, icon, id, label, onClick: handleClick, selected: isActive });
}
function DocumentHeaderTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane();
  const subscribed = Boolean(documentValue) && connectionState === "connected";
  const { error, value } = useDocumentPreview({ enabled: subscribed, schemaType, value: documentValue });
  const { t } = useTranslation2(structureLocaleNamespace);
  if (connectionState !== "connected") {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  }
  if (title) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: title });
  }
  if (!documentValue) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t("panes.document-header-title.new.text", { schemaType: (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name) }) });
  }
  if (error) {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t("panes.document-header-title.error.text", { error: error.message }) });
  }
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime2.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("panes.document-header-title.untitled.text") }) });
}
var DocumentPanelHeader = (0, import_react2.memo)((0, import_react2.forwardRef)(function DocumentPanelHeader2(_props, ref) {
  const { menuItems } = _props;
  const { onMenuAction, onPaneClose, onPaneSplit, menuItemGroups, schemaType, timelineStore, ready, views: views2, unstable_languageFilter } = useDocumentPane();
  const { features } = useStructureTool();
  const { index, BackLink: BackLink3, hasGroupSiblings } = usePaneRouter();
  const { actions: fieldActions } = useFieldActions();
  const menuNodes = (0, import_react2.useMemo)(() => resolveMenuNodes({ actionHandler: onMenuAction, fieldActions, menuItems, menuItemGroups }), [onMenuAction, fieldActions, menuItemGroups, menuItems]);
  const menuButtonNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const showTabs = views2.length > 1;
  const rev = useTimelineSelector(timelineStore, (state2) => state2.revTime);
  const { collapsed, isLast } = usePane();
  const tabIndex = isLast && !collapsed ? -1 : 0;
  const showSplitPaneButton = features.splitViews && onPaneSplit && views2.length > 1;
  const showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings;
  const showPaneGroupCloseButton = !showSplitPaneCloseButton && !features.backButton;
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { delay: TOOLTIP_DELAY_PROPS, children: (0, import_jsx_runtime2.jsx)(PaneHeader, { border: true, ref, loading: !ready, title: (0, import_jsx_runtime2.jsx)(DocumentHeaderTitle, {}), tabs: showTabs && (0, import_jsx_runtime2.jsx)(DocumentHeaderTabs, {}), tabIndex, backButton: features.backButton && index > 0 && (0, import_jsx_runtime2.jsx)(Button2, { as: BackLink3, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: { content: t("pane-header.back-button.text") } }), subActions: (0, import_jsx_runtime2.jsx)(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }), actions: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, children: [unstable_languageFilter.length > 0 && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: unstable_languageFilter.map((languageFilterComponent, idx) => {
    return (0, import_react2.createElement)(languageFilterComponent, {
      // eslint-disable-next-line react/no-array-index-key
      key: "language-filter-".concat(idx),
      schemaType
    });
  }) }), menuButtonNodes.map((item) => (0, import_jsx_runtime2.jsx)(PaneHeaderActionButton, { node: item }, item.key)), (0, import_jsx_runtime2.jsx)(PaneContextMenuButton, { nodes: contextMenuNodes }, "context-menu"), showSplitPaneButton && (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": t("buttons.split-pane-button.aria-label"), icon: SplitVerticalIcon, mode: "bleed", onClick: onPaneSplit, tooltipProps: { content: t("buttons.split-pane-button.tooltip") } }, "split-pane-button"), showSplitPaneCloseButton && (0, import_jsx_runtime2.jsx)(Button2, { icon: CloseIcon, mode: "bleed", onClick: onPaneClose, tooltipProps: { content: t("buttons.split-pane-close-button.title") } }, "close-view-button"), showPaneGroupCloseButton && (0, import_jsx_runtime2.jsx)(Button2, { icon: CloseIcon, mode: "bleed", tooltipProps: { content: t("buttons.split-pane-close-group-button.title") }, as: BackLink3 }, "close-view-button")] }) }) });
}));
var InspectorMenuItem = (0, import_react2.memo)(function InspectorMenuItem2(props) {
  const { documentId, documentType, index, setMenuItem, useMenuItem: useMenuItem2 } = props;
  const node = useUnique(useMenuItem2({ documentId, documentType }));
  (0, import_react2.useEffect)(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]);
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const { documentId, documentType, inspectors: inspectors2, onMenuItems } = props;
  const len = inspectors2.length;
  const lenRef = (0, import_react2.useRef)(len);
  const [menuItems, setMenuItems] = (0, import_react2.useState)(() => Array.from(new Array(len)));
  const menuItemsRef = (0, import_react2.useRef)(menuItems);
  (0, import_react2.useEffect)(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++) {
        newFieldActions[i] = menuItemsRef.current[i];
      }
      lenRef.current = len;
      setMenuItems(() => {
        menuItemsRef.current = newFieldActions;
        return newFieldActions;
      });
    }
  }, [len]);
  const setMenuItem = (0, import_react2.useCallback)((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      next[index] = node;
      menuItemsRef.current = next;
      return next;
    });
  }, []);
  (0, import_react2.useEffect)(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]);
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: inspectors2.map((inspector, inspectorIndex) => inspector.useMenuItem && (0, import_jsx_runtime2.jsx)(InspectorMenuItem, { documentId, documentType, index: inspectorIndex, setMenuItem, useMenuItem: inspector.useMenuItem }, inspector.name)) });
}
function getInspectorItems(_ref112) {
  let { currentInspector, hasValue, inspectors: inspectors2, inspectorMenuItems } = _ref112;
  return inspectors2.map((inspector, index) => {
    var _a2;
    const menuItem = inspectorMenuItems[index];
    if (!menuItem || menuItem.hidden)
      return null;
    return { action: "".concat(INSPECT_ACTION_PREFIX).concat(inspector.name), group: menuItem.showAsAction ? void 0 : "inspectors", icon: menuItem.icon, isDisabled: !hasValue, selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name, shortcut: (_a2 = menuItem.hotkeys) == null ? void 0 : _a2.join("+"), showAsAction: menuItem.showAsAction, title: menuItem.title, tone: menuItem.tone };
  }).filter(Boolean);
}
function getInspectItem(_ref113) {
  let { hasValue, t } = _ref113;
  return { action: "inspect", group: "inspectors", title: t("document-inspector.menu-item.title"), icon: JsonIcon, isDisabled: !hasValue, shortcut: "Ctrl+Alt+I" };
}
function getProductionPreviewItem(_ref114) {
  let { previewUrl, t } = _ref114;
  if (!previewUrl)
    return null;
  return { action: "production-preview", group: "links", title: t("production-preview.menu-item.title"), icon: EarthAmericasIcon, shortcut: "Ctrl+Alt+O" };
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params);
  const items = [
    // Get production preview item
    getProductionPreviewItem(params)
  ].filter(Boolean);
  return [
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
function DocumentLayoutError(props) {
  const { documentType, value, currentMinWidth, paneKey, minWidth } = props;
  const { t } = useTranslation2();
  return (0, import_jsx_runtime2.jsx)(ErrorPane, { currentMinWidth, flex: 2.5, minWidth, paneKey, title: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "panes.document-pane.document-unknown-type.title", values: { documentType } }), tone: "caution", children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [documentType && (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "panes.document-pane.document-unknown-type.text", values: { documentType } }) }), !documentType && (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: t("panes.document-pane.document-unknown-type.without-schema.text") }), isDev && value && /* eslint-disable i18next/no-literal-string */
  (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Text, { as: "p", children: "Here is the JSON representation of the document:" }), (0, import_jsx_runtime2.jsx)(Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: (0, import_jsx_runtime2.jsx)(Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })] })] }) });
}
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", { value: __freeze$2(raw || cooked.slice()) }));
var _a$2;
var EMPTY_ARRAY$2 = [];
var DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
];
var StyledChangeConnectorRoot = ut(ChangeConnectorRoot)(_a$2 || (_a$2 = __template$2(["\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n  min-width: 0;\n"])));
function DocumentLayout() {
  const { changesOpen, documentId, documentType, fieldActions, inspectOpen, inspector, inspectors: inspectors2, onFocus, onHistoryOpen, onMenuAction, onPathOpen, paneKey, schemaType, value } = useDocumentPane();
  const { features } = useStructureTool();
  const { t } = useTranslation(structureLocaleNamespace);
  const { collapsed: layoutCollapsed } = usePaneLayout();
  const zOffsets = useZIndex();
  const previewUrl = usePreviewUrl(value);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const [footerElement, setFooterElement] = (0, import_react2.useState)(null);
  const [headerElement, setHeaderElement] = (0, import_react2.useState)(null);
  const [actionsBoxElement, setActionsBoxElement] = (0, import_react2.useState)(null);
  const [documentPanelPortalElement, setDocumentPanelPortalElement] = (0, import_react2.useState)(null);
  const [inspectorMenuItems, setInspectorMenuItems] = (0, import_react2.useState)([]);
  const [rootFieldActionNodes, setRootFieldActionNodes] = (0, import_react2.useState)([]);
  const footerRect = useElementRect(footerElement);
  const headerRect = useElementRect(headerElement);
  const footerHeight = footerRect == null ? void 0 : footerRect.height;
  const headerHeight = headerRect == null ? void 0 : headerRect.height;
  const currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  const minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  const currentInspector = (0, import_react2.useMemo)(() => inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === (inspector == null ? void 0 : inspector.name)), [inspectors2, inspector == null ? void 0 : inspector.name]);
  const hasValue = Boolean(value);
  const menuItems = (0, import_react2.useMemo)(() => getMenuItems({ currentInspector, features, hasValue, inspectorMenuItems, inspectors: inspectors2, previewUrl, t }), [currentInspector, features, hasValue, inspectorMenuItems, inspectors2, previewUrl, t]);
  const handleKeyUp = (0, import_react2.useCallback)((event) => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if ((0, import_is_hotkey.default)(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          onMenuAction(item);
          return;
        }
      }
    }
  }, [onMenuAction, menuItems]);
  const onConnectorSetFocus = (0, import_react2.useCallback)((path) => {
    onPathOpen(path);
    onFocus(path);
  }, [onPathOpen, onFocus]);
  if (!schemaType) {
    return (0, import_jsx_runtime2.jsx)(DocumentLayoutError, { currentMinWidth, documentType, minWidth, paneKey, value });
  }
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [inspectors2.length > 0 && (0, import_jsx_runtime2.jsx)(DocumentInspectorMenuItemsResolver, { documentId, documentType, inspectors: inspectors2, onMenuItems: setInspectorMenuItems }), fieldActions.length > 0 && schemaType && (0, import_jsx_runtime2.jsx)(FieldActionsResolver, { actions: fieldActions, documentId, documentType, onActions: setRootFieldActionNodes, path: EMPTY_ARRAY$2, schemaType }), (0, import_jsx_runtime2.jsx)(FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY$2, children: (0, import_jsx_runtime2.jsxs)(DocumentActionShortcuts, { actionsBoxElement, as: Pane, currentMinWidth, "data-testid": "document-pane", flex: 2.5, id: paneKey, minWidth, onKeyUp: handleKeyUp, rootRef: setRootElement, children: [(0, import_jsx_runtime2.jsx)(DocumentPanelHeader, { ref: setHeaderElement, menuItems }), (0, import_jsx_runtime2.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.portal, children: (0, import_jsx_runtime2.jsx)(Flex, { direction: "column", flex: 1, height: layoutCollapsed ? void 0 : "fill", children: (0, import_jsx_runtime2.jsx)(StyledChangeConnectorRoot, { "data-testid": "change-connector-root", isReviewChangesOpen: changesOpen, onOpenReviewChanges: onHistoryOpen, onSetFocus: onConnectorSetFocus, children: (0, import_jsx_runtime2.jsx)(DocumentPanel, { footerHeight: footerHeight || null, headerHeight: headerHeight || null, isInspectOpen: inspectOpen, rootElement, setDocumentPanelPortalElement }) }) }) }), (0, import_jsx_runtime2.jsx)(PortalProvider, { __unstable_elements: { [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement }, children: (0, import_jsx_runtime2.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.portal, children: (0, import_jsx_runtime2.jsx)(PaneFooter, { ref: setFooterElement, children: (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { delay: TOOLTIP_DELAY_PROPS, children: (0, import_jsx_runtime2.jsx)(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement }) }) }) }) }), (0, import_jsx_runtime2.jsx)(DocumentOperationResults, {})] }) })] });
}
function pick(plugin) {
  var _a2, _b2;
  return (_b2 = (_a2 = plugin.document) == null ? void 0 : _a2.components) == null ? void 0 : _b2.unstable_layout;
}
function useDocumentLayoutComponent() {
  return useMiddlewareComponents({ pick, defaultComponent: DocumentLayout });
}
var DocumentPane = (0, import_react2.memo)(function DocumentPane2(props) {
  const { name: parentSourceName } = useSource();
  return (0, import_jsx_runtime2.jsx)(SourceProvider, { name: props.pane.source || parentSourceName, children: (0, import_jsx_runtime2.jsx)(DocumentPaneInner, { ...props }) });
});
function DocumentPaneInner(props) {
  var _a2;
  const { pane, paneKey } = props;
  const { resolveNewDocumentOptions } = useSource().document;
  const paneRouter = usePaneRouter();
  const options = usePaneOptions(pane.options, paneRouter.params);
  const { documentType, isLoaded: isDocumentLoaded } = useDocumentType(options.id, options.type);
  const DocumentLayout2 = useDocumentLayoutComponent();
  const templateItems = (0, import_react2.useMemo)(() => {
    return resolveNewDocumentOptions({ type: "document", documentId: options.id, schemaType: options.type });
  }, [options.id, options.type, resolveNewDocumentOptions]);
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({ templateItems });
  const isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading;
  const providerProps = (0, import_react2.useMemo)(() => {
    return isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props;
  }, [props, documentType, isLoaded, options]);
  const { ReferenceChildLink: ReferenceChildLink3, handleEditReference, groupIndex, routerPanesState } = paneRouter;
  const childParams = ((_a2 = routerPanesState[groupIndex + 1]) == null ? void 0 : _a2[0].params) || {};
  const routerPanesStateLength = routerPanesState.length;
  const { parentRefPath } = childParams;
  const activePath = (0, import_react2.useMemo)(() => {
    return parentRefPath ? { path: fromString(parentRefPath), state: (
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    ) } : { path: [], state: "none" };
  }, [parentRefPath, groupIndex, routerPanesStateLength]);
  const { t } = useTranslation2(structureLocaleNamespace);
  if (options.type === "*" && !isLoaded) {
    return (0, import_jsx_runtime2.jsx)(LoadingPane, { flex: 2.5, minWidth: 320, paneKey, title: t("panes.document-pane.document-not-found.loading") });
  }
  if (!documentType) {
    return (0, import_jsx_runtime2.jsx)(ErrorPane, { flex: 2.5, minWidth: 320, paneKey, title: t("panes.document-pane.document-not-found.title"), children: (0, import_jsx_runtime2.jsx)(Stack, { space: 4, children: (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "panes.document-pane.document-not-found.text", values: { id: options.id } }) }) }) });
  }
  return (0, import_jsx_runtime2.jsx)(DocumentPaneProvider, { ...providerProps, children: (0, import_jsx_runtime2.jsx)(ReferenceInputOptionsProvider, { EditReferenceLinkComponent: ReferenceChildLink3, onEditReference: handleEditReference, initialValueTemplateItems: templatePermissions, activePath, children: (0, import_jsx_runtime2.jsx)(DocumentLayout2, { documentId: options.id, documentType: options.type }) }) }, "".concat(documentType, "-").concat(options.id));
}
function usePaneOptions(options) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const templates = useTemplates();
  return (0, import_react2.useMemo)(() => {
    if (options.type && options.type !== "*") {
      return options;
    }
    const templateName = options.template || params.template;
    const template = templateName ? templates.find((t) => t.id === templateName) : void 0;
    const documentType = template == null ? void 0 : template.schemaType;
    if (!documentType) {
      return options;
    }
    return { ...options, type: documentType };
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return { ...props, pane: { ...props.pane, options: { ...options, type: documentType } } };
}
var PARTIAL_PAGE_LIMIT = 100;
var FULL_LIST_LIMIT = 2e3;
var DEFAULT_ORDERING = { by: [{ field: "_updatedAt", direction: "desc" }] };
var EMPTY_RECORD = {};
function removePublishedWithDrafts(documents) {
  return collate(documents).map((entry) => {
    const doc = entry.draft || entry.published;
    return { ...doc, hasPublished: !!entry.published, hasDraft: !!entry.draft };
  });
}
var RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
function getTypeNameFromSingleTypeFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const matches = filter.match(RE_TYPE_NAME_IN_FILTER);
  if (!matches) {
    return null;
  }
  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, "");
  if (match[0] === "$") {
    const k = match.slice(1);
    const v = params[k];
    return typeof v === "string" ? v : null;
  }
  return match;
}
function isSimpleTypeFilter(filter) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter.trim());
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy2 = order.by.map((by) => {
    if (by.mapWith) {
      return by;
    }
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    if (!fieldType) {
      return by;
    }
    if (fieldExtendsType(fieldType, "datetime")) {
      return { ...by, mapWith: "dateTime" };
    }
    if (fieldType.jsonType === "string") {
      return { ...by, mapWith: "lower" };
    }
    return by;
  });
  return orderBy2.every((item, index) => item === order.by[index]) ? order : { ...order, by: orderBy2 };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current) {
      return void 0;
    }
    if (typeof segment === "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    const isArrayAccessor = isKeySegment(segment) || isIndexSegment(segment);
    if (!isArrayAccessor || current.jsonType !== "array") {
      return void 0;
    }
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType) {
      return void 0;
    }
    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType) {
      return void 0;
    }
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type)) {
    return void 0;
  }
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  while (current) {
    if (current.name === ofType) {
      return true;
    }
    if (!current.type && current.jsonType === ofType) {
      return true;
    }
    current = current.type;
  }
  return false;
}
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", { value: __freeze$1(raw || cooked.slice()) }));
var _a$1;
var _b$1;
var RootBox = ut(Box)(_a$1 || (_a$1 = __template$1(["\n  position: relative;\n"])));
var CommandListBox = ut(Box)(_b$1 || (_b$1 = __template$1(["\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n"])));
var SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const { layout } = props;
  return (0, import_jsx_runtime2.jsx)(Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: SKELETON_ITEMS.map((num) => (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { isPlaceholder: true, layout }, num)) });
}
function DocumentListPaneContent(props) {
  const { childItemId, error, filterIsSimpleTypeConstraint, hasMaxItems, hasSearchQuery, isActive, isLazyLoading, isLoading, items, layout, loadingVariant, onListChange, onRetry, paneTitle, searchInputElement, showIcons } = props;
  const schema2 = useSchema();
  const { collapsed: layoutCollapsed } = usePaneLayout();
  const { collapsed, index } = usePane();
  const [shouldRender, setShouldRender] = (0, import_react2.useState)(false);
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleEndReached = (0, import_react2.useCallback)(() => {
    if (isLoading || isLazyLoading || !shouldRender)
      return;
    onListChange();
  }, [isLazyLoading, isLoading, onListChange, shouldRender]);
  (0, import_react2.useEffect)(() => {
    if (collapsed)
      return void 0;
    const timer2 = setTimeout(() => {
      setShouldRender(true);
    }, 0);
    return () => {
      clearTimeout(timer2);
    };
  }, [collapsed, items]);
  const renderItem2 = (0, import_react2.useCallback)((item, _ref115) => {
    let { activeIndex } = _ref115;
    const publishedId = getPublishedId(item._id);
    const isSelected = childItemId === publishedId;
    const pressed = !isActive && isSelected;
    const selected = isActive && isSelected;
    const isLastItem = activeIndex === items.length - 1;
    const showSpinner = isLastItem && isLazyLoading;
    const showMaxItemsMessage = isLastItem && hasMaxItems;
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(PaneItem, { icon: showIcons === false ? false : void 0, id: publishedId, layout, marginBottom: 1, pressed, schemaType: schema2.get(item._type), selected, value: item }), showSpinner && (0, import_jsx_runtime2.jsx)(LoadingBlock, {}), showMaxItemsMessage && (0, import_jsx_runtime2.jsx)(Box, { marginY: 1, paddingX: 3, paddingY: 4, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, size: 1, children: t("panes.document-list-pane.max-items.text", { limit: FULL_LIST_LIMIT }) }) })] });
  }, [childItemId, isActive, items.length, layout, schema2, showIcons, hasMaxItems, isLazyLoading, t]);
  const noDocumentsContent = (0, import_react2.useMemo)(() => {
    if (hasSearchQuery) {
      return (0, import_jsx_runtime2.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime2.jsx)(Container, { width: 1, children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, children: t("panes.document-list-pane.no-documents.text") }) }) }) });
    }
    return (0, import_jsx_runtime2.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime2.jsx)(Container, { width: 1, children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, children: filterIsSimpleTypeConstraint ? t("panes.document-list-pane.no-documents-of-type.text") : t("panes.document-list-pane.no-matching-documents.text") }) }) }) });
  }, [filterIsSimpleTypeConstraint, hasSearchQuery, t]);
  const mainContent = (0, import_react2.useMemo)(() => {
    if (!shouldRender) {
      return null;
    }
    if (error) {
      return (0, import_jsx_runtime2.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime2.jsx)(Container, { width: 1, children: (0, import_jsx_runtime2.jsxs)(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [(0, import_jsx_runtime2.jsx)(Heading, { as: "h3", children: t("panes.document-list-pane.error.title") }), (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: (0, import_jsx_runtime2.jsx)(Translate, { t, i18nKey: "panes.document-list-pane.error.text", values: { error: error.message }, components: { Code: (_ref116) => {
        let { children } = _ref116;
        return (0, import_jsx_runtime2.jsx)("code", { children });
      } } }) }), onRetry && (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsx)(Button2, { icon: SyncIcon, onClick: onRetry, text: t("panes.document-list-pane.error.retry-button.text"), tone: "primary" }) })] }) }) });
    }
    if (!isLoading && items.length === 0) {
      return noDocumentsContent;
    }
    if (loadingVariant === "initial" && isLoading) {
      return (0, import_jsx_runtime2.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime2.jsx)(LoadingView, { layout }) });
    }
    if (loadingVariant === "spinner" && isLoading) {
      return null;
    }
    const key = "".concat(index, "-").concat(collapsed);
    return (0, import_jsx_runtime2.jsx)(RootBox, { overflow: "hidden", height: "fill", children: (0, import_jsx_runtime2.jsx)(CommandListBox, { children: (0, import_jsx_runtime2.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: paneTitle, canReceiveFocus: true, inputElement: searchInputElement, itemHeight: 51, items, onEndReached: handleEndReached, onlyShowSelectionWhenActive: true, overscan: 10, paddingBottom: 1, paddingX: 3, renderItem: renderItem2, wrapAround: false }, key) }) });
  }, [
    collapsed,
    error,
    handleEndReached,
    index,
    isLoading,
    items,
    layout,
    loadingVariant,
    // noDocumentsContent,
    onRetry,
    renderItem2,
    searchInputElement,
    shouldRender
  ]);
  return (0, import_jsx_runtime2.jsx)(PaneContent, { overflow: layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto", children: mainContent });
}
var DocumentListPaneHeader = (0, import_react2.memo)((_ref117) => {
  let { contentAfter, index, initialValueTemplates = [], menuItemGroups = [], menuItems = [], setLayout, setSortOrder, title } = _ref117;
  const { features } = useStructureTool();
  const { collapsed, isLast } = usePane();
  const tabIndex = isLast && !collapsed ? -1 : 0;
  const actionHandlers = (0, import_react2.useMemo)(() => {
    return { setLayout: (_ref118) => {
      let { layout: value } = _ref118;
      setLayout(value);
    }, setSortOrder: (sort) => {
      setSortOrder(sort);
    } };
  }, [setLayout, setSortOrder]);
  return (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { delay: TOOLTIP_DELAY_PROPS, children: (0, import_jsx_runtime2.jsx)(PaneHeader, { actions: (0, import_jsx_runtime2.jsx)(PaneHeaderActions, { initialValueTemplateItems: initialValueTemplates, actionHandlers, menuItemGroups, menuItems }), backButton: features.backButton && index > 0 && (0, import_jsx_runtime2.jsx)(Button2, { as: BackLink, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: { content: "Back" } }), contentAfter, tabIndex, title }) });
});
DocumentListPaneHeader.displayName = "DocumentListPaneHeader";
function listenSearchQuery(options) {
  const { client, schema: schema2, sort, limit, params, filter, searchQuery, staticTypeNames, maxFieldDepth } = options;
  const sortBy2 = sort.by;
  const extendedProjection = sort == null ? void 0 : sort.extendedProjection;
  const events$ = defer(() => {
    return client.listen("*[".concat(filter, "]"), params, { events: ["welcome", "mutation", "reconnect"], includeResult: false, visibility: "query" });
  }).pipe(mergeMap((ev, i) => {
    const isFirst = i === 0;
    if (isFirst && ev.type !== "welcome") {
      return throwError(() => new Error(ev.type === "reconnect" ? "Could not establish EventSource connection" : 'Received unexpected type of first event "'.concat(ev.type, '"')));
    }
    return of(ev);
  }), share());
  const [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === "welcome");
  return merge(welcome$.pipe(take(1)), mutationAndReconnect$.pipe(throttleTime(1e3, asyncScheduler, { leading: true, trailing: true }))).pipe(exhaustMapWithTrailing((event) => {
    const typeNames$ = staticTypeNames ? of(staticTypeNames) : client.observable.fetch("array::unique(*[".concat(filter, "][]._type)"), params);
    return typeNames$.pipe(mergeMap((typeNames) => {
      const types = getSearchTypesWithMaxDepth(getSearchableTypes(schema2).filter((type) => {
        return typeNames.includes(type.name);
      }), maxFieldDepth);
      const searchTerms = { filter, query: searchQuery || "", types };
      const searchOptions = { __unstable_extendedProjection: extendedProjection, comments: ["findability-source: ".concat(searchQuery ? "list-query" : "list")], limit, params, sort: sortBy2 };
      const { query: createdQuery, params: createdParams } = createSearchQuery(searchTerms, searchOptions);
      const doFetch = () => client.observable.fetch(createdQuery, createdParams);
      if (event.type === "mutation" && event.visibility !== "query") {
        return timer(1200).pipe(mergeMap(doFetch));
      }
      return doFetch();
    }));
  }));
}
var EMPTY_ARRAY$1 = [];
var INITIAL_STATE = { error: null, onRetry: void 0, result: null };
var INITIAL_QUERY_RESULTS = { result: null, error: null };
function useDocumentList(opts) {
  const { filter, params: paramsProp, sortOrder, searchQuery, apiVersion } = opts;
  const client = useClient({ ...DEFAULT_STUDIO_CLIENT_OPTIONS, apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion });
  const schema2 = useSchema();
  const maxFieldDepth = useSearchMaxFieldDepth();
  const [resultState, setResult] = (0, import_react2.useState)(INITIAL_STATE);
  const { onRetry, error, result } = resultState;
  const documents = result == null ? void 0 : result.documents;
  const items = (0, import_react2.useMemo)(() => documents ? removePublishedWithDrafts(documents) : EMPTY_ARRAY$1, [documents]);
  const [isLazyLoading, setIsLazyLoading] = (0, import_react2.useState)(false);
  const [hasFullList, setHasFullList] = (0, import_react2.useState)(false);
  const [shouldFetchFullList, setShouldFetchFullList] = (0, import_react2.useState)(false);
  const typeNameFromFilter = (0, import_react2.useMemo)(() => getTypeNameFromSingleTypeFilter(filter, paramsProp), [filter, paramsProp]);
  const isLoading = result === null && !error;
  const hasMaxItems = (documents == null ? void 0 : documents.length) === FULL_LIST_LIMIT;
  const onListChange = (0, import_react2.useCallback)(() => {
    if (isLoading || hasFullList || shouldFetchFullList)
      return;
    setShouldFetchFullList(true);
  }, [isLoading, hasFullList, shouldFetchFullList]);
  const handleSetResult = (0, import_react2.useCallback)((res) => {
    var _a2, _b2;
    if (res.error) {
      setResult(res);
      return;
    }
    const documentsLength = ((_b2 = (_a2 = res.result) == null ? void 0 : _a2.documents) == null ? void 0 : _b2.length) || 0;
    const isLoadingMoreItems = !res.error && (res == null ? void 0 : res.result) === null && shouldFetchFullList;
    if (isLoadingMoreItems) {
      setIsLazyLoading(true);
      return;
    }
    if (documentsLength < PARTIAL_PAGE_LIMIT && documentsLength !== 0 && !shouldFetchFullList) {
      setHasFullList(true);
    }
    if ((res == null ? void 0 : res.result) === null) {
      setResult((prev) => ({ ...prev.error ? res : prev }));
      return;
    }
    setIsLazyLoading(false);
    setResult(res);
  }, [shouldFetchFullList]);
  const queryResults$ = (0, import_react2.useMemo)(() => {
    const onRetry$ = new Subject();
    const _onRetry = () => onRetry$.next();
    const limit = shouldFetchFullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT;
    const sort = sortOrder || DEFAULT_ORDERING;
    return listenSearchQuery({ client, filter, limit, params: paramsProp, schema: schema2, searchQuery: searchQuery || "", sort, staticTypeNames: typeNameFromFilter ? [typeNameFromFilter] : void 0, maxFieldDepth }).pipe(map((results) => ({ result: { documents: results }, error: null })), startWith(INITIAL_QUERY_RESULTS), catchError((err2) => {
      if (err2 instanceof ProgressEvent) {
        return throwError(() => new Error("Request error"));
      }
      return throwError(() => err2);
    }), catchError((err2, caught$) => {
      return concat(of({ result: null, error: err2 }), merge(fromEvent(window, "online"), onRetry$).pipe(take(1), mergeMap(() => caught$)));
    }), scan((prev, next) => ({ ...prev, ...next, onRetry: _onRetry })));
  }, [client, filter, paramsProp, schema2, searchQuery, shouldFetchFullList, sortOrder, typeNameFromFilter, maxFieldDepth]);
  (0, import_react2.useEffect)(() => {
    const sub = queryResults$.subscribe(handleSetResult);
    return () => {
      sub.unsubscribe();
    };
  }, [handleSetResult, queryResults$]);
  const reset = (0, import_react2.useCallback)(() => {
    setHasFullList(false);
    setIsLazyLoading(false);
    setResult(INITIAL_STATE);
    setShouldFetchFullList(false);
  }, []);
  (0, import_react2.useEffect)(() => {
    reset();
  }, [reset, filter, paramsProp, sortOrder, searchQuery]);
  return { error, hasMaxItems, isLazyLoading, isLoading, isSearchReady: !error, items, onListChange, onRetry };
}
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
var _b;
var EMPTY_ARRAY = [];
var rotate = ht(_a || (_a = __template(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var AnimatedSpinnerIcon = ut(SpinnerIcon)(_b || (_b = __template(["\n  animation: ", " 500ms linear infinite;\n"])), rotate);
function useShallowUnique(value) {
  const valueRef = (0, import_react2.useRef)(value);
  if (!(0, import_shallow_equals2.default)(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
var addSelectedStateToMenuItems = (options) => {
  const { menuItems, sortOrderRaw, layout } = options;
  return menuItems == null ? void 0 : menuItems.map((item) => {
    var _a2, _b2, _c2, _d2;
    if ((_a2 = item.params) == null ? void 0 : _a2.layout) {
      return { ...item, selected: layout === ((_b2 = item.params) == null ? void 0 : _b2.layout) };
    }
    if ((_c2 = item == null ? void 0 : item.params) == null ? void 0 : _c2.by) {
      return { ...item, selected: (0, import_isEqual2.default)(sortOrderRaw == null ? void 0 : sortOrderRaw.by, ((_d2 = item == null ? void 0 : item.params) == null ? void 0 : _d2.by) || EMPTY_ARRAY) };
    }
    return { ...item, selected: false };
  });
};
var DocumentListPane = (0, import_react2.memo)(function DocumentListPane2(props) {
  const { childItemId, index, isActive, isSelected, pane, paneKey } = props;
  const schema2 = useSchema();
  const { name: parentSourceName } = useSource();
  const { defaultLayout = "default", displayOptions, initialValueTemplates = EMPTY_ARRAY, menuItemGroups, menuItems, options } = pane;
  const { apiVersion, defaultOrdering = EMPTY_ARRAY, filter } = options;
  const params = useShallowUnique(options.params || EMPTY_RECORD);
  const sourceName = pane.source;
  const typeName = (0, import_react2.useMemo)(() => getTypeNameFromSingleTypeFilter(filter, params), [filter, params]);
  const showIcons = (displayOptions == null ? void 0 : displayOptions.showIcons) !== false;
  const [layout, setLayout] = useStructureToolSetting(typeName, "layout", defaultLayout);
  const { t } = useTranslation2(structureLocaleNamespace);
  const { title } = useI18nText(pane);
  const [searchQuery, setSearchQuery] = (0, import_react2.useState)("");
  const [searchInputValue, setSearchInputValue] = (0, import_react2.useState)("");
  const [searchInputElement, setSearchInputElement] = (0, import_react2.useState)(null);
  const showSearchLoadingRef = (0, import_react2.useRef)(false);
  const defaultSortOrder = (0, import_react2.useMemo)(() => {
    return (defaultOrdering == null ? void 0 : defaultOrdering.length) > 0 ? { by: defaultOrdering } : DEFAULT_ORDERING;
  }, [defaultOrdering]);
  const [sortOrderRaw, setSortOrder] = useStructureToolSetting(typeName, "sortOrder", defaultSortOrder);
  const sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema2.get(typeName)) : sortOrderRaw;
  const sortOrder = useUnique(sortWithOrderingFn);
  const filterIsSimpleTypeConstraint = isSimpleTypeFilter(filter);
  const { error, hasMaxItems, isLazyLoading, isLoading, isSearchReady, items, onListChange, onRetry } = useDocumentList({ apiVersion, filter, params, searchQuery: searchQuery == null ? void 0 : searchQuery.trim(), sortOrder });
  const menuItemsWithSelectedState = (0, import_react2.useMemo)(() => addSelectedStateToMenuItems({ menuItems, sortOrderRaw, layout }), [layout, menuItems, sortOrderRaw]);
  const handleQueryChange = useObservableCallback((event$) => {
    return event$.pipe(map((event) => event.target.value), tap(setSearchInputValue), debounce((value) => value === "" ? of("") : timer(300)), tap(setSearchQuery));
  }, []);
  const handleClearSearch = (0, import_react2.useCallback)(() => {
    setSearchQuery("");
    setSearchInputValue("");
  }, []);
  const handleSearchKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape") {
      handleClearSearch();
    }
  }, [handleClearSearch]);
  (0, import_react2.useEffect)(() => {
    if (showSearchLoadingRef.current === false && !isLoading) {
      showSearchLoadingRef.current = true;
    }
    return () => {
      showSearchLoadingRef.current = false;
    };
  }, [isLoading]);
  (0, import_react2.useEffect)(() => {
    handleClearSearch();
    showSearchLoadingRef.current = false;
  }, [paneKey, handleClearSearch]);
  const loadingVariant = (0, import_react2.useMemo)(() => {
    const showSpinner = isLoading && items.length === 0 && showSearchLoadingRef.current;
    if (showSpinner)
      return "spinner";
    return "initial";
  }, [isLoading, items.length]);
  const searchInput = (0, import_jsx_runtime2.jsx)(Box, { paddingX: 3, paddingBottom: 3, children: (0, import_jsx_runtime2.jsx)(TextInput, { "aria-label": t("panes.document-list-pane.search-input.aria-label"), autoComplete: "off", border: false, clearButton: Boolean(searchQuery), disabled: !isSearchReady, fontSize: [2, 2, 1], icon: loadingVariant === "spinner" ? AnimatedSpinnerIcon : SearchIcon, onChange: handleQueryChange, onClear: handleClearSearch, onKeyDown: handleSearchKeyDown, padding: 2, placeholder: t("panes.document-list-pane.search-input.placeholder"), radius: 2, ref: setSearchInputElement, spellCheck: false, value: searchInputValue }) });
  return (0, import_jsx_runtime2.jsx)(SourceProvider, { name: sourceName || parentSourceName, children: (0, import_jsx_runtime2.jsxs)(Pane, { currentMaxWidth: 350, "data-ui": "DocumentListPane", id: paneKey, maxWidth: 640, minWidth: 320, selected: isSelected, children: [_DEBUG, (0, import_jsx_runtime2.jsx)(DocumentListPaneHeader, { contentAfter: searchInput, index, initialValueTemplates, menuItemGroups, menuItems: menuItemsWithSelectedState, setLayout, setSortOrder, title }), (0, import_jsx_runtime2.jsx)(DocumentListPaneContent, { childItemId, error, filterIsSimpleTypeConstraint, hasMaxItems, hasSearchQuery: Boolean(searchQuery), isActive, isLazyLoading, isLoading, items, layout, loadingVariant, onListChange, onRetry, paneTitle: title, searchInputElement, showIcons }, paneKey)] }) });
});

export {
  require_isNumber,
  require_camelCase,
  require_kebabCase,
  structureLocaleNamespace,
  PaneRouterContext,
  BackLink,
  usePaneLayout,
  ChildLink,
  ReferenceChildLink,
  ParameterizedLink,
  usePaneRouter,
  ConfirmDeleteDialogContainer,
  Pane,
  usePane,
  PaneContent,
  PaneHeader,
  PaneLayout,
  PaneHeaderActions,
  PaneItem,
  useDocumentPane,
  _DEBUG,
  LOADING_PANE,
  setActivePanes,
  useStructureTool,
  DocumentInspectorHeader,
  structureTool,
  SerializeError,
  HELP_URL,
  maybeSerializeMenuItem,
  MenuItemBuilder,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  maybeSerializeMenuItemGroup,
  MenuItemGroupBuilder,
  ComponentBuilder,
  GenericViewBuilder,
  maybeSerializeView,
  ComponentViewBuilder,
  FormViewBuilder,
  form,
  component,
  DocumentBuilder,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  DEFAULT_INTENT_HANDLER,
  defaultIntentChecker,
  InitialValueTemplateItemBuilder,
  defaultInitialValueTemplateItems,
  maybeSerializeInitialValueTemplateItem,
  menuItemsFromInitialValueTemplateItems,
  shallowIntentChecker,
  GenericListBuilder,
  DocumentListBuilder,
  getTypeNamesFromFilter,
  ListBuilder,
  ListItemBuilder,
  DocumentListItemBuilder,
  isDocumentListItem,
  DocumentTypeListBuilder,
  createStructureBuilder,
  StructureToolProvider,
  LoadingPane,
  DocumentPaneProvider,
  useDocumentTitle,
  DocumentPane,
  DocumentListPane
};
/*! Bundled license information:

sanity/lib/_chunks/structure-BXyPLY49.js:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=chunk-NANETPD7.js.map
